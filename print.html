<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>BPC-PRP</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="title-page.html"><strong aria-hidden="true">1.</strong> Uvod</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> OS Linux</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="linux/distro.html"><strong aria-hidden="true">2.1.</strong> Distribuce</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> Instalace</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="linux/install/multiboot.html"><strong aria-hidden="true">2.2.1.</strong> Multiboot</a></li><li class="chapter-item expanded "><a href="linux/install/virtualbox.html"><strong aria-hidden="true">2.2.2.</strong> VirtualBox</a></li><li class="chapter-item expanded "><a href="linux/install/vmware.html"><strong aria-hidden="true">2.2.3.</strong> VmWare</a></li></ol></li><li class="chapter-item expanded "><a href="linux/filesystem.html"><strong aria-hidden="true">2.3.</strong> Souborový systém</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.</strong> Příkazový řádek</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="linux/shell/run.html"><strong aria-hidden="true">2.4.1.</strong> Otevření příkazového řádku</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.2.</strong> Soubory</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="linux/shell/touch.html"><strong aria-hidden="true">2.4.2.1.</strong> Vytvoření</a></li><li class="chapter-item expanded "><a href="linux/shell/cp.html"><strong aria-hidden="true">2.4.2.2.</strong> Kopírování</a></li><li class="chapter-item expanded "><a href="linux/shell/mv.html"><strong aria-hidden="true">2.4.2.3.</strong> Přesun</a></li><li class="chapter-item expanded "><a href="linux/shell/rm.html"><strong aria-hidden="true">2.4.2.4.</strong> Smazání</a></li><li class="chapter-item expanded "><a href="linux/shell/chmod.html"><strong aria-hidden="true">2.4.2.5.</strong> Změna práv</a></li><li class="chapter-item expanded "><a href="linux/shell/cat.html"><strong aria-hidden="true">2.4.2.6.</strong> Zjištění obsahu</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.3.</strong> Složky</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="linux/shell/mkdir.html"><strong aria-hidden="true">2.4.3.1.</strong> Vytvoření</a></li><li class="chapter-item expanded "><a href="linux/shell/rmdir.html"><strong aria-hidden="true">2.4.3.2.</strong> Smazání</a></li><li class="chapter-item expanded "><a href="linux/shell/pwd.html"><strong aria-hidden="true">2.4.3.3.</strong> Zjištění aktuální</a></li><li class="chapter-item expanded "><a href="linux/shell/cd.html"><strong aria-hidden="true">2.4.3.4.</strong> Změna aktuální</a></li><li class="chapter-item expanded "><a href="linux/shell/ls.html"><strong aria-hidden="true">2.4.3.5.</strong> Výpis souborů</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.4.</strong> Editace souborů</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="linux/shell/nano.html"><strong aria-hidden="true">2.4.4.1.</strong> Pomocí GNU nano</a></li><li class="chapter-item expanded "><a href="linux/shell/vim.html"><strong aria-hidden="true">2.4.4.2.</strong> Pomocí GNU vim</a></li></ol></li><li class="chapter-item expanded "><a href="linux/shell/wget.html"><strong aria-hidden="true">2.4.5.</strong> Stahování souborů z internetu</a></li><li class="chapter-item expanded "><a href="linux/shell/man.html"><strong aria-hidden="true">2.4.6.</strong> Manuálové stránky</a></li><li class="chapter-item expanded "><a href="linux/shell/sudo.html"><strong aria-hidden="true">2.4.7.</strong> Zvýšení oprávnění</a></li><li class="chapter-item expanded "><a href="linux/shell/apt.html"><strong aria-hidden="true">2.4.8.</strong> Instalace balíčků</a></li><li class="chapter-item expanded "><a href="linux/shell/mc.html"><strong aria-hidden="true">2.4.9.</strong> Souborový manažer</a></li></ol></li><li class="chapter-item expanded "><a href="linux/footer.html"><strong aria-hidden="true">2.5.</strong> Slovo závěrem</a></li></ol></li><li class="chapter-item expanded "><a href="git/index.html"><strong aria-hidden="true">3.</strong> Git</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="git/install.html"><strong aria-hidden="true">3.1.</strong> Instalace</a></li><li class="chapter-item expanded "><a href="git/purpose.html"><strong aria-hidden="true">3.2.</strong> Účel</a></li><li class="chapter-item expanded "><a href="git/terminology.html"><strong aria-hidden="true">3.3.</strong> Terminologie</a></li><li class="chapter-item expanded "><a href="git/commands.html"><strong aria-hidden="true">3.4.</strong> Příkazy</a></li><li class="chapter-item expanded "><a href="git/excercises.html"><strong aria-hidden="true">3.5.</strong> Příklady k procvičení</a></li><li class="chapter-item expanded "><a href="git/seealso.html"><strong aria-hidden="true">3.6.</strong> Doporučená literatura</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> CMake</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="cmake/cmakelists.html"><strong aria-hidden="true">4.1.</strong> Struktura CMakeLists.txt</a></li><li class="chapter-item expanded "><a href="cmake/build.html"><strong aria-hidden="true">4.2.</strong> Kompilůace z příkazová řádky</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> CLion</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="clion/uvod.html"><strong aria-hidden="true">5.1.</strong> Úvod k CLion</a></li><li class="chapter-item expanded "><a href="clion/install.html"><strong aria-hidden="true">5.2.</strong> Instalace</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Projekt</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="clion/open_cmake.html"><strong aria-hidden="true">5.3.1.</strong> Otevření cmake projektu</a></li><li class="chapter-item expanded "><a href="clion/newproj.html"><strong aria-hidden="true">5.3.2.</strong> Nový cmake projekt</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> Kompilace a spouštění</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="clion/build.html"><strong aria-hidden="true">5.4.1.</strong> Kompilace programu</a></li><li class="chapter-item expanded "><a href="clion/run.html"><strong aria-hidden="true">5.4.2.</strong> Spuštění programu</a></li><li class="chapter-item expanded "><a href="clion/debug.html"><strong aria-hidden="true">5.4.3.</strong> Ladění programu</a></li></ol></li><li class="chapter-item expanded "><a href="clion/remote.html"><strong aria-hidden="true">5.5.</strong> Profil vzdáleného ladění</a></li><li class="chapter-item expanded "><a href="clion/troubleshoot.html"><strong aria-hidden="true">5.6.</strong> Troubleshooting</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.</strong> Integrace Gitu v CLionu</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="clion/git/pull.html"><strong aria-hidden="true">5.7.1.</strong> Aktualizace ze serveru</a></li><li class="chapter-item expanded "><a href="clion/git/commit.html"><strong aria-hidden="true">5.7.2.</strong> Potvrzení změn</a></li><li class="chapter-item expanded "><a href="clion/git/push.html"><strong aria-hidden="true">5.7.3.</strong> Odeslání změn na server</a></li><li class="chapter-item expanded "><a href="clion/git/log.html"><strong aria-hidden="true">5.7.4.</strong> Log</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> C++/Algoritmizace</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="cpp/jazyk.html"><strong aria-hidden="true">6.1.</strong> Jazyk</a></li><li class="chapter-item expanded "><a href="cpp/cli.html"><strong aria-hidden="true">6.2.</strong> C++</a></li><li class="chapter-item expanded "><a href="cpp/kontejnery.html"><strong aria-hidden="true">6.3.</strong> Kontejnery</a></li><li class="chapter-item expanded "><a href="cpp/algoritmy.html"><strong aria-hidden="true">6.4.</strong> Algoritmy</a></li><li class="chapter-item expanded "><a href="cpp/patterns.html"><strong aria-hidden="true">6.5.</strong> Návrhové vzory</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> ROS</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ros/ros.html"><strong aria-hidden="true">7.1.</strong> Robotic Operating System</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Principy</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="principy/superloop.html"><strong aria-hidden="true">8.1.</strong> Supersmyčka a zpětnovazební řízení</a></li><li class="chapter-item expanded "><a href="principy/mediator.html"><strong aria-hidden="true">8.2.</strong> Mediator - Protokolový eventový parser</a></li><li class="chapter-item expanded "><a href="principy/controller.html"><strong aria-hidden="true">8.3.</strong> Stavový controller</a></li><li class="chapter-item expanded "><a href="principy/protostack.html"><strong aria-hidden="true">8.4.</strong> Procházení komunikačním protokolem ISO/OSI</a></li><li class="chapter-item expanded "><a href="principy/splitfiles.html"><strong aria-hidden="true">8.5.</strong> Organizace projektu / práce v týmu</a></li><li class="chapter-item expanded "><a href="principy/isolate.html"><strong aria-hidden="true">8.6.</strong> Oddělení modulů - Zrychlení kompilace</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">BPC-PRP</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="praktická-robotika-a-zpracování-obrazu-bpc-prp-online-skripta"><a class="header" href="#praktická-robotika-a-zpracování-obrazu-bpc-prp-online-skripta">Praktická robotika a zpracování obrazu (BPC-PRP) online skripta</a></h1>
<p>Tento text představuje online skripta předmětu BPC-PRP - povinného předmětu 3. rocniku bakalářského studijního oboru Automatizační a měřicí technika na Fakultě elektrotechniky a komunikačních technologií Vysokého Učení Technického v Brně.</p>
<p>Skripta rovněž obsahují texty týkajici se dalších oblastí robotiky, které již ale nejsou vyžadovány samotnou náplní předmětu.</p>
<h2 id="autoři"><a class="header" href="#autoři">Autoři</a></h2>
<p>Ing. Adam Ligocki, Ph.D.</p>
<p>Ing. Tomáš Lázna</p>
<p>Ing. Petr Gábrlík</p>
<p>Ing. Tomáš Jílek, Ph.D.</p>
<p>Ing. František Burian, Ph.D.</p>
<p>Ing. Tomáš Horeličan</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="distribuce-linuxu"><a class="header" href="#distribuce-linuxu">Distribuce Linuxu</a></h2>
<p>Hovoříme-li o operačním systému <strong>Linux</strong>, máme na mysli jádro operačního systému, které je spravováno autoritou (autor <strong>Linus Benedict Torvalds</strong>) a ta zajišťuje integritu veškerého kódu, který je do jádra OS zaintegrován.</p>
<p>Pro interakci jádra operačního systému s okolím je třeba přidružených programů (např balíčkovacích systémů, grafického rozhraní, a dalšího podpůrného software). Sadu těchto programů souhrnně označujeme <strong>Distribuce</strong>.</p>
<p>Distribuce  je dodávána a garantována konkrétní právnickou osobou (komerční subjekt, organizace, atd.). Distribuce jsou většinou vzájemně nekompatibilní na binární úrovni.</p>
<p>Často používané distribuce:</p>
<ul>
<li><strong>Debian</strong> 
<ul>
<li>nejstabilnější distribuce, nepodporuje však nový hardware (stable obsahuje 2-5 let starý kód)</li>
<li>správa balíčků 'apt'</li>
</ul>
</li>
<li><strong>Ubuntu</strong> 
<ul>
<li>derivát Debianu</li>
<li>Nejrozšířenějí distribuce na domácích stanicích.</li>
<li>Snahou je urychlit testování a distribuci k uživatelům bez znatelného snížení nestability</li>
<li>správa balíčků 'apt'</li>
</ul>
</li>
<li><strong>Mint</strong> 
<ul>
<li>derivát Ubuntu. </li>
<li>Snaha o grafické rozhraní které zachovává idiomy MS Windows. </li>
<li>Doporučený pro přechod z MS Windows</li>
<li>správa balíčků 'apt'</li>
</ul>
</li>
<li><strong>RaspberryOS</strong> (dříve <strong>Raspbian</strong>) 
<ul>
<li>derivát Debianu upravený pro minipočítač Raspberry Pi</li>
<li>správa balíčků 'apt'</li>
</ul>
</li>
<li><strong>Arch Linux</strong> 
<ul>
<li>Distribuce orienovaná na nejaktuálnější jádro. </li>
<li>Nižší stabilita ale vyšší kompatibilita s nejnovějším hw. </li>
<li>Doporučeno pro pokročilejší uživatele i vzhledem k široké konfigurovatelnosti </li>
<li>správa balíčků 'yay'</li>
</ul>
</li>
<li><strong>Fedora</strong> 
<ul>
<li>Derivát RedHat Enterprise Linux</li>
<li>správa balíčků 'rpm'</li>
</ul>
</li>
<li><strong>ElementaryOS</strong> 
<ul>
<li>Minimalistická a rychlá distribuce. </li>
<li>Vhodná pro starší a slabé počítače.</li>
<li>správa balíčků 'apt'</li>
</ul>
</li>
</ul>
<p>... a mnoho dalších (výčet není konečný)</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="instalace-linuxu-vedle-windows"><a class="header" href="#instalace-linuxu-vedle-windows">Instalace Linuxu vedle Windows</a></h3>
<p>Tuto metodu zvolte, pokud chcete mít linux rychlý, nebo máte postarší stroj</p>
<h4 id="tvorba-instalačního-média"><a class="header" href="#tvorba-instalačního-média">Tvorba instalačního média</a></h4>
<h4 id="rozdělení-disku--vytvoření-prostoru-pro-instalaci"><a class="header" href="#rozdělení-disku--vytvoření-prostoru-pro-instalaci">Rozdělení disku / vytvoření prostoru pro instalaci</a></h4>
<h4 id="zahájení-instalace-linuxu"><a class="header" href="#zahájení-instalace-linuxu">Zahájení Instalace Linuxu</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h3 id="instalace-linuxu-s-použitím-virtulizace-virtualbox"><a class="header" href="#instalace-linuxu-s-použitím-virtulizace-virtualbox">Instalace Linuxu s použitím virtulizace VirtualBox</a></h3>
<h4 id="instalace-virtualboxu"><a class="header" href="#instalace-virtualboxu">Instalace VirtualBoxu</a></h4>
<p>VirtualBox si nainstalujte podle návodu na příslušném operačním systému.</p>
<p>Postup pro <a href="https://www.virtualbox.org/wiki/Downloads">Windows a Mac</a>.</p>
<p>Pro Linux instalace záleží na distribuci a používaném baličkovacím systému. Na Debianu použijte příkaz <code>sudo apt install virtualbox</code>. Poté bude možné VB aktivovat z terminálu voláním <code>virtualbox</code>, nebo skrze ikonku v seznamu nainstalovaných programů.</p>
<p><img src="linux/install/../../images/vb.png" alt="VB" /></p>
<h4 id="příprava-instalačního-média"><a class="header" href="#příprava-instalačního-média">Příprava instalačního média</a></h4>
<p>Stáhněte si obraz instalačního disku <a href="https://ubuntu.com/download/desktop">Ubuntu 20.04</a>.</p>
<h4 id="vytvoření-virtuáního-stroje"><a class="header" href="#vytvoření-virtuáního-stroje">Vytvoření virtuáního stroje</a></h4>
<p>Pomocí tlačítka &quot;New&quot; vytvořte nový virtuální stroj. Pojmenujte si jej, zvolte typ operačního systému, nastavte velikost operační paměti (vhodné 4GB a více), vytvořte nový virtuální disk, vyberte typ virtuálního disku (VDI), zvolte dynamickou alokaci 
disku a na poslední obrazovce vyberte umístění virtuálního disku na svém počítači a zvolte maximální možnou velikost virtuálního disku (32 - 64GB).</p>
<p>Nyní v hlavní obrazovce Virtual Boxu zvolte nově vytvořený virtuální stroj a přejděte do nastavení.</p>
<p>V záložce &quot;System&quot; můžete měnit velikost dedikované operační paměti, měnit počet jader procesorů, která budou pro virtuální stroj dostupná (je doporučeno dvě a více) a také můžete zapínat/vypínat HW akceleraci pro virtuální stroj.</p>
<p>Dále v záložce &quot;Display&quot; světšete množství dedikované video paměti na maximum (128MB).</p>
<p>V záložce &quot;Storage&quot; klikněte na položku s obrázkem CD a následně úplně v pravo klikněte pravým na ikonku CD s malou šipečkou. Tím otevřete okno pro nastavení cesty k instalačnímu obrazu Ubuntu, které jsme dříve stáhli na počítač. Zavřete nastavení tlačítkem OK.</p>
<p><img src="linux/install/../../images/vb_storage.png" alt="VB" /></p>
<p>Nyní v hlavním okně Virtual Boxu aktivujte virtuální stroj tlačítkem start.</p>
<p>Pokud je vše nastaveno korektně, stroj nabootuje z instalačního obrazu.</p>
<h4 id="zahájení-instalace-linuxu-1"><a class="header" href="#zahájení-instalace-linuxu-1">Zahájení Instalace Linuxu</a></h4>
<p><img src="linux/install/../../images/ubuntu_install_1.png" alt="VB" /></p>
<p>Zvolte jazyk operačního systému (doporučena angličtina), zvolte rozložení klávesnice (doporučeno English US), a nechte pokračovat &quot;Normal Installation&quot;.</p>
<p>Dále se Vás proces dotáže, zda chcete &quot;Smazat disk a nainstalovat Ubuntu&quot;. Protože instalujeme do virtuálního stroje, necháme rozdělení disku na instalátoru. </p>
<p>Nyní zvolte časové pásmo a dále si vytvořte účet s heslem.</p>
<p>A dále už jen počkejte, až se systém doinstaluje a provede se reset virtuálního stoje.</p>
<p>Po opětovném nabootování v horní liště okna virtuálního stroje zvolte záložku &quot;Devices&quot; a &quot;Insert Guest Additions CD Image&quot;. Za okamžik vyskočí okno, které se dotáže zda má aktivovat autorun vloženého CD. Souhlaste. Systém si vyžádá heslo a poté se doinstalují ovladače pro virtualizovaný hardware.</p>
<p>Po dalším restartu máte připarevený virtuální stroj s nainstalovaným Linuxem Ubuntu 20.04.</p>
<p><img src="linux/install/../../images/ubuntu_rdy.png" alt="VB" /></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="instalace-linuxu-s-použitím-virtulizace-vmware"><a class="header" href="#instalace-linuxu-s-použitím-virtulizace-vmware">Instalace Linuxu s použitím virtulizace VmWare</a></h3>
<h4 id="instalace-vmware-player"><a class="header" href="#instalace-vmware-player">Instalace VmWare Player</a></h4>
<h4 id="příprava-instalačního-média-1"><a class="header" href="#příprava-instalačního-média-1">Příprava instalačního média</a></h4>
<h4 id="vytvoření-virtuálního-stroje"><a class="header" href="#vytvoření-virtuálního-stroje">Vytvoření virtuálního stroje</a></h4>
<h4 id="zahájení-instalace-linuxu-2"><a class="header" href="#zahájení-instalace-linuxu-2">Zahájení instalace Linuxu</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h2 id="orientace-v-systému"><a class="header" href="#orientace-v-systému">Orientace v systému</a></h2>
<p>Souborová struktura Linuxu se odvozuje od tzv. kořene (root), který značíme jako <code>/</code> (vzdáleny ekvivalent <code>C:/</code> na Windows).</p>
<p>V kořenovém adresáři pak nalezneme složky jako:</p>
<ul>
<li><code>bin/</code> - obsahuje binárky (spustitelné soubory operačního systému).</li>
<li><code>home/</code> - adresář, který obsahuje domovské složky uživatelů, tj vaše soubory.</li>
<li><code>dev/</code> - obsahuje soubory které mapují hardware počítače (interní a externí disky, sériovou linku, usb, síťové rozhraní, atd.).</li>
<li><code>tmp/</code> - dočasná složka. Zde si programy odkládají svá dočasná data.</li>
<li><code>media/</code> - místo kde se připojují externí disky.</li>
<li><code>etc/</code> - složka obsahuje konfiguraci systému a všech nainstalovaných aplikací</li>
</ul>
<p>V Linuxu neexistuje ekvivalent fyzického dělení na disky. Fyzické disky lze připojit do libovolné složky. Ze zadané cesty k souboru 
tedy nelze přímo usoudit na kterém fyzickém disku se data nacházejí. To je velmi odlišné od Windows kde cesta vždy začíná písmenem 
fyzického disku, a možnost připojit disk do složky přichází až od systému souborů NTFS.</p>
<p>Složka <code>tmp</code> vede na většině distribucí do virtuálního disku v paměťi RAM počítače. Je tedy extrémně rychlá, ale za cenu že se při 
vypnutí počítače smaže. Spousta nástrojů ji používá pro vytvoření mezivýsledků kompilace.</p>
<p>Po příhlášení do konzole se obvykle nacházíte v domovském adresáři, tj na místě <code>/home/&lt;jmeno_uzivatele&gt;/</code></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="spuštění-příkazového-řádku"><a class="header" href="#spuštění-příkazového-řádku">Spuštění příkazového řádku</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h3 id="vytvoření-souboru"><a class="header" href="#vytvoření-souboru">Vytvoření souboru</a></h3>
<p><code>touch</code> - (touch file)</p>
<p>Vytvoří soubor na disku</p>
<pre><code class="language-bash">touch  jmeno_souboru      ...      Vytvoří soubor jmeno_souboru na disku.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="kopírování-souboru"><a class="header" href="#kopírování-souboru">Kopírování souboru</a></h3>
<p><code>cp</code> - (copy)</p>
<pre><code class="language-shell">cp zdrojovy_soubor cilovy_soubor                    ...      vytvoří novou kopii zdrojovy_soubor nazvanou cilovy_soubor
cp ../secter.txt secret_folder/supersecret.txt      ...      vem soubor secret.txt, který se nachází o složku výš a zkopíruj ji do složky secret_folder. Kopie původního souboru se bude jmenovat &quot;supersecret.txt&quot;     
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="p5esun-souboru"><a class="header" href="#p5esun-souboru">P5esun souboru</a></h3>
<p><code>mv</code> - (move)</p>
<p>Příkaz původně pro přesun souboru, hlavně se však využívá pro přejmenováni soborů.</p>
<pre><code class="language-bash">mv old_name.txt new_name.html      ...      přejmenuje soubor &quot;old%name.txt&quot; na &quot;new_name.html&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="smazání-souboru"><a class="header" href="#smazání-souboru">Smazání souboru</a></h3>
<p><code>rm</code> - (remove)</p>
<p>Smaže soubor/složku.</p>
<pre><code class="language-bash">rm old_file.txt      ...      vymaže soubor &quot;old_file.txt&quot;
rm -r my_folder      ...      smaže složku. Při mazání složky vždy musíme použít modifikátor rekurze (-r). Ten říká, že se má rekurzivně smazat také obsah složky.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="změna-práv-k-souboru"><a class="header" href="#změna-práv-k-souboru">Změna práv k souboru</a></h3>
<p><code>chmod</code> - (change file mode)</p>
<p>Změní přístupová práva k souboru.</p>
<pre><code class="language-shell">chmod 777 /dev/ttyUSB0      ...      umožní všem uživatelům PC přístup na USB port s pořadovým číslem 0. Pro detail fungováni přístupových práv ve file systému viz [7].
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="vypsání-obsahu-souboru"><a class="header" href="#vypsání-obsahu-souboru">Vypsání obsahu souboru</a></h3>
<p><code>cat</code> - (Concatenate FILE(s) to standard output)</p>
<p>Program vypíše do termínálu obsah souboru.</p>
<pre><code class="language-shell">cat ~/my_config_file.txt      ...      vytiskne v terminálu obsah zvoleného souboru
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="vytvoření-nového-adresáře"><a class="header" href="#vytvoření-nového-adresáře">Vytvoření nového adresáře</a></h3>
<p><code>mkdir</code> - (make directory)</p>
<pre><code class="language-bash">mkdir my_folder      ...      vytvoří nový adresář s názvem &quot;my_folder&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="smazání-složky"><a class="header" href="#smazání-složky">Smazání složky</a></h3>
<p><code>rmdir</code> - (remove directory)</p>
<p>Smaže složku z disku. Složka musí být prázdná</p>
<pre><code class="language-bash">rmdir my_folder      ...      smaže složku.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="zjištění-aktuální-nastavené-složky"><a class="header" href="#zjištění-aktuální-nastavené-složky">Zjištění aktuální nastavené složky</a></h3>
<p><code>pwd</code> - print working directory</p>
<p>Vypíše aktuální složku.</p>
<pre><code class="language-shell">pwd
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="zm2na-aktuáln9ho-adresáře"><a class="header" href="#zm2na-aktuáln9ho-adresáře">Zm2na aktuáln9ho adresáře</a></h3>
<p><code>cd</code> - (change directory)</p>
<p>Změna složky.</p>
<pre><code class="language-shell">cd my_directory      ...      přesun do adresáře s názvem my_directory
cd ~                 ...      návrat do domovské složky (v linuxu nazýváme &quot;home&quot;)
cd ..                ...      návrat o adresář výš (dvojtečka)
cd /                 ...      návrat do kořene file systému (v linuxu nazýváme &quot;root&quot;)
cd ../my_folder      ...      vrať se o adresář výš a pak se přesuň do adresáře &quot;my_folder&quot;
cd .                 ...      přesuň se do &quot;současného adresáře&quot;. V podstatě nic neudělá. Příklad ilustruje existenci symbolu pro aktuální adresář (tečka).
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="výpis-souborů-ve-složce"><a class="header" href="#výpis-souborů-ve-složce">Výpis souborů ve složce</a></h3>
<p><code>ls</code> - (list)</p>
<p>Vypiš všechny soubory a složky (složka je taky typ souboru) v aktuálním bodě file systému.</p>
<pre><code class="language-shell">ls
ls -la      ...      vypíše všechny soubory, včetně sktytých a přidá k výpisu detailní informace
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="editace-textu-pomocí-gnu-nano"><a class="header" href="#editace-textu-pomocí-gnu-nano">Editace textu pomocí GNU nano</a></h3>
<p><code>nano</code></p>
<p>Editace textu podobná poznámkovému bloku</p>
<pre><code class="language-bash">nano jmeno_souboru    --- zahájí editaci souboru
</code></pre>
<p>Klávesové ovládání:</p>
<p><code>Ctrl + X</code> - ukončení programu. Program se zeptá, zda má uložit změny</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="editace-textu-pomocí-gnu-vim"><a class="header" href="#editace-textu-pomocí-gnu-vim">Editace textu pomocí GNU vim</a></h3>
<p><code>vim</code> (visual editor improved)</p>
<p>Editor textu, který pracuje v příkazovém režimu, tedy uživatel zadává editoru příkazy a editor na základě těchto příkazů upravuje text. </p>
<p>Pro jeho použití je nutné si zapamatovat velké množství příkazů a klávesových zkratek. Pokud to však zvládnete, může 
být práce s ním rychlejší než s nano. Není doporučován začátečníkům.</p>
<p>Kdyby se Vám přeci jen povedlo vim zapnout, vězte že jej vypnete kobinací kláves <code>Shift + Z + Z</code> (držíme shift a dvakrát zmáčkneme klávesu 'Z').</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="stahování-souborů-ze-sítě-pomocí-gnu-wget"><a class="header" href="#stahování-souborů-ze-sítě-pomocí-gnu-wget">Stahování souborů ze sítě pomocí GNU wget</a></h3>
<p><code>wget</code></p>
<p>Program pro stahování souborů ze sítě.</p>
<p>Příklad stažení posledního releasu wordpresu:</p>
<pre><code class="language-shell">wget https://wordpress.org/latest.zip
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="manuálové-stránky"><a class="header" href="#manuálové-stránky">Manuálové stránky</a></h3>
<p><code>man</code> - (manual) referenční manuál operačního systému</p>
<p>Rychlá pomoc když zapomenu, jak pracovat s daným programem</p>
<pre><code class="language-shell">man ls      ...      vytiskne v terminálu manuál k programu ls
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="eskalace-oprávnění"><a class="header" href="#eskalace-oprávnění">Eskalace oprávnění</a></h3>
<p><code>sudo</code></p>
<p>Meta příkaz. Operace specifikovaná za tímto příkazem bude provedena v režimu oprávnění administrátora operačního systému. 
Obvykle používáme, když zasahujeme do systémových souborů.</p>
<pre><code class="language-shell">sudo mkdir /etc/config      ...      vytvoří složku &quot;config&quot; v systémovém adresáři &quot;/etc&quot;.
sudo rm -r /                ...      příkaz rekurzivně smaže celý adresář &quot;root&quot; (v podstatě smaže celý disk včetně OS)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="balíčkovací-systém"><a class="header" href="#balíčkovací-systém">Balíčkovací systém</a></h3>
<p><code>apt</code></p>
<p>Jedná se o Balíčkovací systém Debianu. Na Linuxu nejčastěji instalumeme programy tak, že si jej stáhneme z veřejného repozitáře, 
tedy obvykle ověřeného a bezpečného serveru.</p>
<p>Při instalaci musíme vždy disponovat administrátorskými právy.</p>
<p>Příklad instalace balíčku s názvem 'git':</p>
<pre><code class="language-shell">sudo apt update                  --- aktualizuj záznamy o repozitářích na internetu 
sudo apt install git             --- nainstaluj program git
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="souborový-manažer"><a class="header" href="#souborový-manažer">Souborový manažer</a></h3>
<p><code>mc</code></p>
<p>Midnight Commander - grafické prostředí pro pohyb v souborovém systému. Připomíná MS Dos.</p>
<pre><code class="language-shell">mc
</code></pre>
<p>Vypíná se klávesou <code>F10</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="slovo-na-závěre"><a class="header" href="#slovo-na-závěre">Slovo na závěre</a></h3>
<p>Pokud jste v Linuxu nováčky, hlavně se nebote experimentovat. Ideálně si nainstalulte systém do Virtual Boxu a udělejte si zálohu virtuálního disku. Když se Vás podaří systém rozhasit, stačí si natánout backup a jedete dál.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git---verzovací-systém"><a class="header" href="#git---verzovací-systém">Git - Verzovací systém</a></h1>
<p>Git je distribuovaný systém pro verzováni a management zálohování zdrojových kódů. Obecně ale Git funguje dobře pro verzování libovolného textu. Primární motivací k výuce Gitu v rámci tohoto předmětu je fakt, že Git je dnes nejrozšířenějí 
verzovací systém v komerční sféře a zároveň je na webu dostupná obrovská paleta Git-based online verzovacích služeb.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="instalace-gitu-na-linuxu"><a class="header" href="#instalace-gitu-na-linuxu">Instalace Gitu na Linuxu</a></h2>
<p>V případě, že pracujeme na distribuci Debian, Git nainstalujeme následovně:</p>
<pre><code>sudo apt install git
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="princip-fungování"><a class="header" href="#princip-fungování">Princip fungování</a></h2>
<p>Primární funkcí Gitu je verzování textových souborů. Jedním dechem je potřeba dodta, že Git NENÍ vhodny pro verzování binárních souborů. Vyvíjíme-li tedy program a verzujeme vývoj v Gitu, vždy verzujeme pouuze zdrojové kódy, nikdy ne zkompilované spustitelné soubory (binárky).</p>
<p>Zároveň Git umožňuje velmi efektivní spolupráci mnoha lidí na stejném projektu (repozitáři). Vývojáři mohou pracovat společně, případně každý na separátním branchi. Důležité pravidlo však je, že dva lidé nesmí přepsat stejný řádek kódu ve dvou různých commitech. To způsobi tzv. konflikt. Obecné doporučení je, aby dva lidé neměnili stejný soubor.</p>
<p>Ve srovnání s SVN je ale Git tzv. decentralizovaný systém. To znamená, že v systému repozitářů neexistuje žaden nadřazeny, důležitější repozitář, či něco ve smyslu centrálního serveru. Všechny repozitáře mají stejnou funkcionalitu a jsou schopny udržovat kompletní historii celého repozitáře a ponohodnotně komunikovat se všemi ostatními klony. Praxe je však taková, že obvykle existuje repozitář, který funguje jako centrální místo pro výměnu commitů mezi vývojáři. Takový repozitář se obvykle jmenuje &quot;origin&quot;. Důležité však je, že kterýkolik repozitář, si může z originu stáhnout kompletní historii a tak v případě selhání originu nedojde ke ztrátě dat, protože každý vývojář může mít jeho plnohodnotnou kopii na svém počítačí.</p>
<p>Obvykla práce s Gitem vypadá následovně:</p>
<ul>
<li>Na serveru vytvoříme repozitář projektu.</li>
<li>vývojáři si naklonujou repozitář na lokální počítače. Z jejich pohledu loklálních repozitářů je server tzv &quot;origin&quot;.</li>
<li>vývojáři na lokálních počítačích vytváří kód a commitujou.</li>
<li>na konci dne každý vývojáž pushne (nahraje) své denní commity na origin.</li>
<li>na druhý den ráno si každý fetchne (stáhne) commity kolegů z dne předchozího.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="základní-terminologie"><a class="header" href="#základní-terminologie">Základní terminologie</a></h2>
<p>Vymezme si několik základních pojmů, abychom si rozuměli.</p>
<h3 id="repozitář-repo"><a class="header" href="#repozitář-repo">repozitář (repo)</a></h3>
<p>Sada verzovaných souborů a záznamy o jejich historii. Pokud je repozitář uložen na našem počítači, nazýváme jej lokální repozitář (local repo). Jeli uložen na jiném stroji, hovoříme o vzdáleném repozitáři (remote repo).</p>
<h3 id="klonování-cloning"><a class="header" href="#klonování-cloning">klonování (cloning)</a></h3>
<p>Stažení repozitáře z remote repa. Klonujeme v okamžiku, kdy na lokálním počítači repozitář neexistuje.</p>
<h3 id="snapshot"><a class="header" href="#snapshot">snapshot</a></h3>
<p>Stav repozitáře v konkrétním bodě v historii.</p>
<h3 id="diff"><a class="header" href="#diff">diff</a></h3>
<p>Rozdíl mezi dvěmi snapshoty. Tedy rozdíl stavu verzovaných souborů.</p>
<h3 id="commit"><a class="header" href="#commit">commit</a></h3>
<p>Záznam, který obsahuje referenci na předchozí, následujicí snapshot a diff mezi nimi. Zároveň každý commit má svůj unikátní dvaceti bytový hash, který jej jednoznačně identifikuje v rámci repozitáře.</p>
<h3 id="push"><a class="header" href="#push">push</a></h3>
<p>Nahrání nových comitů na remote repo.</p>
<h3 id="fetch"><a class="header" href="#fetch">fetch</a></h3>
<p>Stažení commitů z remote repo na lokál. Fetchujeme, pokud na lokále máme repozitář naklonovaný, ale nemáme stažené nejnovější commity.</p>
<h3 id="větev-branch"><a class="header" href="#větev-branch">větev (branch)</a></h3>
<p>Řetězec na sebe navazujicích commitů. Ze základu má každý repozitáž jednu větev (&quot;master&quot;, někdy &quot;main&quot;). Probíha-li však vývoj několika funkcionalit vedle sebe, je možné tyto vývoje rozdělit do zvláštnich větví a připojit je spátky k hlavní větni, až je funkcionalita dokončená.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="přehled-příkazů"><a class="header" href="#přehled-příkazů">Přehled příkazů</a></h2>
<h3 id="git-init"><a class="header" href="#git-init">git init</a></h3>
<p>Inicializace repozitře. Z obvyklé složky v souborovém systému vytvořím repozitář.</p>
<p>Repozitář se od obyčejné složky liší tím, že v sobě obsahuje skrytou složku s názvem .git a ta obsahuje historii repozitáře.</p>
<pre><code>git init     ...      inicializuje repozitář
</code></pre>
<h3 id="git-add"><a class="header" href="#git-add">git add</a></h3>
<p>Příkaz přidává změny vytvořené od posledního commitu do tzv. indexu. Index je soubor změn, které budou součástí nejbližšího commitu. Díky mezistupni index je možné commitnout jen některé změny, které jsme od posledního commitu vytvořili.</p>
<pre><code>git add myfile.txt     ...      přidá do indexu změny provedené nad souborem myfile.txt
git add .              ...      přidá do indexu všechny aktuální změny
</code></pre>
<h3 id="git-commit"><a class="header" href="#git-commit">git commit</a></h3>
<p>Vytvoř nový commit, který je odvozený od posledního commitu v současné větví, a zahrni do commitu změny (diffy), které jsou v indexu.</p>
<pre><code>git commit -m &quot;komentář k danému commitu&quot;     ...      vytvoří nový commit v rámci větve, ve které se nacházíme
</code></pre>
<h3 id="git-checkout"><a class="header" href="#git-checkout">git checkout</a></h3>
<p>Příkaz slouží k přecházení mezi snapshoty.</p>
<pre><code>git checkout .          ...     vrať větev do stavu posledního commitu (zahoď všechny do té doby vytvořené změny)
git checkout abcdef     ...     přepni mě do stavu, který vznikl po commitu s hexadecimálním označením abcdef
git checkout master     ...     přepni mě do stavu posledního dostupného commitu na větvi master
</code></pre>
<h3 id="git-clone"><a class="header" href="#git-clone">git clone</a></h3>
<p>Příkaz vytvoří klon vzdáleného repozitáře na lokále. Klonujeme-li, není potřeba inicializovat repozitář pomocí git init. Metadata repozitáře se stáhnou automaticky s obsahem.</p>
<pre><code>git clone https://adresa_vzdaleneho_repozitare.git     ...      vytvoří klon daného repozitáře na lokálním stroji
</code></pre>
<h3 id="git-remote"><a class="header" href="#git-remote">git remote</a></h3>
<p>Příkaz vytvoří klon vzdáleného repozitáře na lokále. Klonujeme-li, není potřeba inicializovat repozitář pomocí git init. Metadata repozitáře se stáhnou automaticky s obsahem.</p>
<pre><code>git remote -v                                            ...      vypíše konfiguraci vzdálených repozitářů
git remote add origin https://adresa_repozitare.git      ...      přidá do lokálního repozitáře alias vzdáleného repozitáře s danou adresou
git remote remove origin                                 ...      smaže alias origin na vzdálený repozitář  
</code></pre>
<h3 id="git-push"><a class="header" href="#git-push">git push</a></h3>
<p>Odešle nové commity vytvořené na lokále na vzdálený repozitář.</p>
<pre><code>git push origin master     ...     odešle na mastera nové commity vytvořené v rámci větvě (branche) master
</code></pre>
<h3 id="git-fetch"><a class="header" href="#git-fetch">git fetch</a></h3>
<p>Stáhne z remotu commity do lokálního repozitáře. Stažené komity se ale nestanou součástí větve. Změny zůstanou pouze zapsány v paměti.</p>
<pre><code>git fetch origin           ...     stáhne nové commity ve všech větvích z originu na lokál
git fetch origin master    ...     stáhne nové commity pouze pro větev master z originu na lokál
</code></pre>
<h3 id="git-merge"><a class="header" href="#git-merge">git merge</a></h3>
<p>Na aktuální větví vytvoří nový commit tak, že spojí naagregované diffy dvou různých větví. Tím pádem se v součacné větvi objeví všechny změny, které byly vytvořeny v jiné větví. Větve se tak spojí.</p>
<pre><code>git merge cool_branch        ...      na současné větví vytvoří nový commit, který obsahuje všechny změny větve cool_branch
</code></pre>
<h3 id="git-pull"><a class="header" href="#git-pull">git pull</a></h3>
<p>Kombinace příkazů git fetch a git merge. Obvykle se používá při stažení změn ze serveru. Příkaz nejprve stáhne commity z vzdáleného repozítáře (provede fetch) a následně je připojí do současné větve (provede merge).</p>
<pre><code>git pull origin master        ...      stáhne z originu nové commity na větvi master a přidá je do lokální větve master
</code></pre>
<h3 id="git-diff"><a class="header" href="#git-diff">git diff</a></h3>
<p>Vytiskne rozdíl stavu repozitáře mezi dvěma commity.</p>
<pre><code>git diff abcdef 012345        ...      vytiskne rozdíl mezi commity, které jsou identifikovány hexadecimálními hashy abcdef a 012345
</code></pre>
<h3 id="git-status"><a class="header" href="#git-status">git status</a></h3>
<p>Zobrazí současný stav změn provedených od posledního commitu, včetně zobrazení změn, které jsou již přidány do indexu.</p>
<pre><code>git status        ...      vytiskne současný stav změn
</code></pre>
<h3 id="git-log"><a class="header" href="#git-log">git log</a></h3>
<p>Vytiskne chronologicky výpis commitů spolu s jejich metadaty (časem vytvoření commitu, popiskem, identifikačním hashem, atd.)</p>
<pre><code>git log        ...      vytiskne historii současné větve
</code></pre>
<h3 id="git-stash"><a class="header" href="#git-stash">git stash</a></h3>
<p>Slouží pro ukládání a načítání změn do zásobníku. Vhodné například, když si všimnete, že píšete kód na jiné větvi, než byl záměr. Pomocí git stash uložíte změny do zásobníku, přepnete se na jinou větev a změny si ze zásobníku vytáhnete.</p>
<pre><code>git stash        ...      Uloží změny provedené od posledního commitu do zásobníku a vrátí větev do stavu, v jakém byla po posledním commitu (jako by jste zdrojový kód nikdy nenapsali).
git stash pop      ...      Vytáhne změny uložené ze zásobníku a aplikuje je na současný stav (jako by jste kód právě ručně napsali).
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cvičení"><a class="header" href="#cvičení">Cvičení</a></h2>
<p>Několik scénářů se kterými se můžete během vývoje software potkat. Vyzkoušejte si je opakovaně, aby jste si vryli do paměti způsob práce s Gitem. Zároveň doporučuji si příklady nejprvé projít v příkazové řádce, aby jste chápali zůpsob, jakým Git funguje na nejnižší vrstvě a následně si cvičení absolvovali i v grafickém rozhraní Vašecho vývojového prostředí.</p>
<h3 id="základní-obsluha"><a class="header" href="#základní-obsluha">Základní obsluha</a></h3>
<ul>
<li>Vytvořte si repozitář.</li>
<li>Vytvořte v něm 2 textové soubory a do každého napište několik řádků.</li>
<li>Přídejte provedené změny do indexu a následně změny commitněte.</li>
<li>Nyní zeditujte jeden soubor a opět jej commitněte.</li>
<li>Zeditujte druhý soubor a změny commitněte.</li>
<li>Vytvořte si účet na <a href="https://github.com">GitHubu</a>, a založte si tam nový repozitář.</li>
<li>Přidejte vzdálený repozitář jako &quot;origin&quot; do lokálního repozitáře a pushněte změny na origin.</li>
<li>Ve vebovém prostředí ověřte obsah repozitáře.</li>
<li>Na jiním místě v počítači, nebo na jiném počítači si naklonujte právě pushnutý repozitář.</li>
<li>V novém klonu proveďte změnu a commitněte jí pushnete na origin.</li>
<li>V původní složce pullněte nové commity z originu.</li>
<li>Příkazem git log si prohlédněte historii.</li>
</ul>
<h3 id="konflikt"><a class="header" href="#konflikt">Konflikt</a></h3>
<p>Příklad, co se stane, když dva vývojáří změní tentýž kód.</p>
<ul>
<li>Po vzoru předchozího cvičení si vytvořte na počítači, případně na dvou počítačích dvě kopie repozitáře, který bude mít společný origin na webu.</li>
<li>V prvním klonu upravte konkrétní řádek souboru, commitněte a pushněte.</li>
<li>V druhém klonu upravte tentýž řádek, commitněne a pushněte (push zahlásí chybu).</li>
<li>Nyní jsme si vyrobili konflikt. Ve stejném bodě v historii větve repozitáře proběhly dvě změny,které se navzájem vylučují (tzv. conflict).</li>
<li>Konflikt opravíme tak, že v druhém klonu, který nedokázal pushnout provedeme pull z originu.</li>
<li>Nyní nahlédněme do souboru, který obsahuje konflikt. Konflikt je označen speciální syntaxí &lt;&lt;&lt;&lt;&lt;&lt;&lt; lokalni_zmena ======= zmena_z_originu &gt;&gt;&gt;&gt;&gt;&gt;&gt;. Vyberte verzi, která je žádoucí a speciální syntaxi odstraňte. Tím je konflikt vyřešen.</li>
<li>Zavolejte příkaz git commit bez dalších parametrů a provede se commit s automatickým popiskem, že se jedná o řešení konflitku.</li>
<li>Pushněte nový commit na origin a poté pullněte jej v původním repozitáři.</li>
<li>Příkazem git log si prohlédněte historii.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="doporučené-materiály"><a class="header" href="#doporučené-materiály">Doporučené materiály</a></h2>
<p><a href="https://atlassian.com">Tutoriál Atlassianu</a></p>
<p><a href="https://git.com">Oficiální dokumentace Gitu</a></p>
<p><a href="https://ohshithit.com/cs">Užitečný rádce při potížích s Gitem (cs)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="build-system-cmake"><a class="header" href="#build-system-cmake">Build system CMake</a></h2>
<p>CMake je soubor nástrojů, které zjednodušují kompilaci projektů a knihoven takovým
způsobem, aby byly nezávislé na operačním systému a kompilátoru. Funguje tak,
že pomocí jednotného konfiguračního souboru CMakeLists.txt vygeneruje Makefile
pro UNIX-like systémy a pro Windows generuje MSVC pracovní prostory. Velkou
výhodou CMake je správa závislostí - aplikace si mohou definovat na jakých knihovnách
jsou závislé, přičemž CMake kontroluje, jestli jsou tyto knihovny dostupné a navíc v
požadované verzi. Další velkou výhodou je možnost vytvářet jak spustitelné soubory
tak knihovny pomocí jedné jednoduché konfigurace umístěné v CMakeLists.txt.</p>
<p>Ukázkový soubor CMakeLists.txt pro aplikaci:</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.7)
project(MyCoolRobot)

set(CMAKE_CXX_STANDARD 17) 

add_executable(MyCoolRobot main.cpp)
</code></pre>
<p>Ukázkový soubor CMakeLists.txt pro knihovnu:</p>
<pre><code class="language-cmake">cmake_minimum_required (VERSION 3.7)
project (MyCoolLibrary VERSION 0.1 LANGUAGES CXX )

include(GNUInstallDirs)
set (CMAKE_CXX_STANDARD 17)
file (GLOB SOURCES src/*.cpp )

file (GLOB HEADERS include/*.h)

add_library(libmycoollibrary ${SOURCES})

target_include_directories(libmycoollibrary PUBLIC
    $&lt;BUILD_INTERFACE : ${CMAKE_CURRENT_SOURCE_DIR}/include&gt; 
    $&lt;INSTALL_INTERFACE : include&gt;
    PRIVATE src)

install (TARGETS libmycoollibrary EXPORT MyCoolLibraryConfig
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})

install(DIRECTORY include/DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})

install(EXPORT RoboUtilsConfig DESTINATION share/MyCoolLibrary/cmake)

export(TARGETS libroboutils FILE MyCoolLibraryConfig.cmake)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kompilace-cmake-projektu-y-p59kayov0ho-58dku"><a class="header" href="#kompilace-cmake-projektu-y-p59kayov0ho-58dku">Kompilace cmake projektu y p59kayov0ho 58dku</a></h2>
<p>V případě, že máme nějaký projekt, který používá CMake a chceme jej spustit,
provedeme to pomocí příkazů:</p>
<pre><code class="language-shell">cd MyCoolRobot
cmake . 
make
./MyCoolRobot
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remote-development-v-prostredi-clion"><a class="header" href="#remote-development-v-prostredi-clion">Remote development v prostredi CLion</a></h1>
<p>Clion je integrované vývojové prostředí vyvíjené firmou JetBrains. Jedná se o zajímavou alternativu ke konvenčním prostředím jako je například Eclipse nebo NetBeans.
Oproti těmto uvedeným prostředím Clion vyčnívá zejména kvůli své rychlosti, přehlednosti a modernosti.
Díky napojení na ekosystém firmy JetBrains je možné do studia doinstalovat spoustu rozšiřujících pluginů přinášejících podporu pro nové jazyky, vývojářské nástroje atp.
Velkou výhodou může být i integrovaná práce s Gitem.</p>
<p>V tomto manuálu bude rozebráno použití prostředí Clion v předmětu BPC-PRP tedy jako nástroje pro vývoj firmware mobilního robotu založeného na platformě KAMBot.
Nejprve bude stručně rozebrán build system CMake.
Poté se manuál již bude věnovat CLionu a to zejména jeho instalaci, vytvoření jednoduchého projektu typu Hello World a jeho zprovoznení.
Dále je popsána stěžejní kapitola tohoto manuálu, a to vzdálený vývoj umožňující vzdálené programování Raspberry Pi pomocí standardního počítače. Na konci je popsán jednoduchý projekt blikání LEDkou a kapitola zabývající se odstraňováním nejčastějších problémů se vzdáleným vývojem.</p>
<p>Příklady v tomto manuálu byly zpracovány ve verzi Clion 2018.3, je tedy možné, že se v budoucnosti některé postupy budou měnit.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="instalace-clion"><a class="header" href="#instalace-clion">Instalace CLion</a></h2>
<h3 id="pro-debianubuntu"><a class="header" href="#pro-debianubuntu">Pro Debian/Ubuntu</a></h3>
<p><code>sudo snap install clion</code></p>
<h3 id="pro-windows"><a class="header" href="#pro-windows">Pro Windows</a></h3>
<p>Stáhněte instalační balík ze stránky <a href="https://www.jetbrains.com/clion/">https://www.jetbrains.com/clion/</a> po kliknutí na &quot;GET FREE 30 DAY TRIAL&quot;.</p>
<p>Spousťte stažený EXE soubor</p>
<h3 id="registrace-studentským-účtem"><a class="header" href="#registrace-studentským-účtem">Registrace studentským účtem</a></h3>
<p>Studenti mají nárok na bezplatné využívání plné verze po dobu studia, což se též týká všech produktů firmy JetBrains.</p>
<p>Získání plné verze je možné pomocí postupu na stránce <a href="https://www.jetbrains.com/student/">https://www.jetbrains.com/student/</a>.</p>
<p>Studenti VUT musí pro registraci použít emailovou adresu <code>id@vut.cz</code> </p>
<p>Registraci nalezneme pod Help/Register</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="otevření-cmake-projektu"><a class="header" href="#otevření-cmake-projektu">Otevření cmake projektu</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="založení-nového-projektu"><a class="header" href="#založení-nového-projektu">Založení nového projektu</a></h2>
<p>Nejprve vytvoříme jednoduchý HelloWorld projekt, ve kterém se seznámíme s procesem vytvoření projektu, prostředím a vývojem na lokálním počítači.
Po spuštění CLion nás přivítá úvodní obrazovka se seznamem naposledy otevřených projektů, kde klikneme na tlačítko &quot;New Project&quot;.</p>
<p><img src="clion/../images/clion/clion1.png" alt="uvodni obrazovka" /></p>
<p>Po kliknutí se nám otevře okno s konfigurací nového projektu, kde nastavíme cestu, kde chceme mít projekt vytvořený a standard jazyka C++, v našempřípadě C++17.</p>
<p><img src="clion/../images/clion/clion2.png" alt="vytvareni projektu" /></p>
<p>Po kliknutí na &quot;Create&quot; nás přivítá samotné vývojové prostředí tak jak je zobrazeno na obrazku.</p>
<p><img src="clion/../images/clion/clion3.png" alt="IDE" /></p>
<p>Pojďme se nyní podívat, co se na obrazovce nachází.</p>
<p><img src="clion/../images/clion/clion4.png" alt="IDE popis" /></p>
<ol>
<li>podokno s aktuálně editovaným zdrojovým kódem</li>
<li>aktuálně otevřené soubory</li>
<li>soubory v projektu</li>
<li>zleva: kompilace projektu, výběr targetu, kompilace a spuštění, kompilace aspuštění v debug módu</li>
</ol>
<p>Verze CMake dodávaná v Raspbianu je bohužel relativně stará, zatím co CLion předpokládá použití relativně novou verzi, pro vyřešení tohoto problému je nutné změnit v souboru CMakeLists.txt verzi CMake z 3.12 na 3.7 tak jak je zobrazeno ve výpisu:</p>
<p>NOTE: Dnes jiz pravdepodobne neplati a Raspbian obsahuje znatelne novejsi verzi CMake.</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION  3.7)
project(HelloWorld)
set(CMAKE_CXX_STANDARD  14)
add_executable(HelloWorld  main.cpp)
</code></pre>
<p>Nyní klikneme na tlačítko pro kompilaci a spuštění, kdy se nám nejprve ve spodní části obrazovky zobrazí okno s průběhem kompilace a následně s konzolí spuštěného programu:</p>
<p><img src="clion/../images/clion/clion5.png" alt="Run" /></p>
<p>Při debugování se breakpointy přidávají kliknutím vedle čísla řádku.
Po přidání breakpointu je nutné program spustit v debug módu v horní části okna.
Po kompilacise ve spodní části zobrazí okno debuggeru.
Navigace v debuggovaném kódu probíhá pomocí šipek v debuggovacím okně.</p>
<p><img src="clion/../images/clion/clion6.png" alt="Debug" /></p>
<p>Pro přidání nové třídy do projektu klikneme v podokně se soubory projektu na náš projekt pravým tlačítkem, najedeme na &quot;New&quot; a tam zvolíme &quot;C/C++ Class&quot;, jak je zobrazeno na obrázku.
Při přidávání a odebírání souborů je nutné, aby všechny <code>.cpp</code> soubory byly uvedeny v CMakeLists.txt.</p>
<p><img src="clion/../images/clion/clion7.png" alt="new class" /></p>
<p>CLion obsahuje spoustu funkcí a možností, jejichž popsání je zcela nad rámec tohoto návodu, doporučuji tedy si s ním pohrát a vyzkoušet, co všechno se v něm dá dělat a jak efektivně.
Dobré je rovněž si všímat toho, když je řádek označený žlutě, většinou se jedná o CLion doporučující nějaké zlepšení kódu.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kompilace-programu"><a class="header" href="#kompilace-programu">Kompilace programu</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="spuštění-programu"><a class="header" href="#spuštění-programu">Spuštění programu</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ladění-programu"><a class="header" href="#ladění-programu">Ladění programu</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vzdálený-vývoj"><a class="header" href="#vzdálený-vývoj">Vzdálený vývoj</a></h2>
<p>Vzdálený vývoj (remote development) znamená, že výpočetně náročné vývojové prostředí běží na běžném počítači, zatímco kompilace a spouštění programu probíhána cílovém počítači.
Tímto způsobem lze například velmi pohodlně programovat embedded hardware případně servery.
Velká výhoda je, že například jde z Windows nebo MacOS programovat aplikace pro Linux, což nemusí vždy být možné kvůli chybějícím knihovnám napřiklad i2c-dev.
Funkcionalita vzdáleného vývoje byla doprostředí CLion přidána ve verzi 2018.3.</p>
<p>Pro nakonfigurování vzdáleného vývoje je nutné nejprve přejít do nastaveníprostředí CLion (Preferences).
Zde ve stromu vybereme &quot;Build, Execution, Deployment&quot; a položku &quot;Toolchains&quot; viz obrazek.
Dále klikneme na tlačítko &quot;+&quot;.</p>
<p><img src="clion/../images/clion/clion8.png" alt="toolchain" /></p>
<p>Následně vyplníme jméno toolchainu a volbu &quot;System&quot; přepneme na &quot;RemoteHost&quot; tak, jak je to zobrazeno na obrazku.
Následně klepneme na ikonu složky upoložky &quot;Credentials&quot; a nastavíme je podle konfigurace našeho robotu.
Pokud konfigurace Raspberry Pi nebyla měněna, lze použít hodnoty uvedené v tabulce a zobrazené na obrázku.
Na Raspberry Pi musí být povoleno SSH.</p>
<p><img src="clion/../images/clion/clion9.png" alt="toolchain" />
<img src="clion/../images/clion/clion10.png" alt="toolchain" /></p>
<div class="table-wrapper"><table><thead><tr><th>parametr</th><th>hodnota</th></tr></thead><tbody>
<tr><td>Host</td><td>raspberrypi.local</td></tr>
<tr><td>Port</td><td>22</td></tr>
<tr><td>User name</td><td>pi</td></tr>
<tr><td>Password</td><td>raspberry</td></tr>
</tbody></table>
</div>
<p>Po kliknutí na OK, se CLion pokusí připojit k danému Raspberry Pi a zkontroluje,zda jsou všechny potřebné programy k dispozici.
Připojování je vidět na obrazku a úspěšné připojení je vidět na dalsim obrazku.</p>
<p><img src="clion/../images/clion/clion11.png" alt="toolchain" />
<img src="clion/../images/clion/clion12.png" alt="toolchain" /></p>
<p>Dalším důležitým krokem je konfigurace CMake, ta se provádí rovněž v okně Preferences tak jak je zobrazeno na obrazku.</p>
<p><img src="clion/../images/clion/clion13.png" alt="toolchain" />
Po kliknutí na &quot;+&quot; nakonfigurujeme CMake tak aby používal náš nový toolchain,tak jak je to zobrazeno na obrázku a klikneme na OK.</p>
<p><img src="clion/../images/clion/clion14.png" alt="toolchain" /></p>
<p>Po kliknutí na OK proběhne upload souborů na Raspberry Pi, po uploadu je nutné přepnout konfiguraci CMake na naši nově vytvořenou jak je zobrazenona obrazku.</p>
<p><img src="clion/../images/clion/clion15.png" alt="toolchain" />
<img src="clion/../images/clion/clion16.png" alt="toolchain" /></p>
<p>Poté následuje reload konfigurace jak je zobrazeno na obrazku.</p>
<p><img src="clion/../images/clion/clion17.png" alt="toolchain" /></p>
<p>Po kliknutí na tlačítko kompilace a spuštění se náš firmware zkompiluje naRaspberry Pi a spustí se, tak jak je vidět na obrazku, kdy úspěch poznáme podle toho, že se spustitelný soubor spouští z adresáře tmp.</p>
<p><img src="clion/../images/clion/clion18.png" alt="toolchain" /></p>
<p>Vzdálený vývoj je nyní nakonfigurován</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p>V této kapitole bude rozebráno řešení problémů vznikajících při použití vzdáleného vývoje.</p>
<h3 id="cmake-312-is-required-you-are-running-version-372"><a class="header" href="#cmake-312-is-required-you-are-running-version-372">CMake 3.12 is required. You are running version 3.7.2</a></h3>
<p>Problém je ve vašem CMakeLists.txt, změňte parametr &quot;cmake_minimum_required&quot;.</p>
<h3 id="v-raspberry-pi-chybí-požadované-soubory"><a class="header" href="#v-raspberry-pi-chybí-požadované-soubory">V Raspberry Pi chybí požadované soubory</a></h3>
<p>Po kliknuti na slozku projektu v levem panelu, kliknete na &quot;Deployment&quot;, &quot;Upload to&quot; a vyberte Raspberry Pi.</p>
<h3 id="ultimátní-řešení-problémů"><a class="header" href="#ultimátní-řešení-problémů">Ultimátní řešení problémů</a></h3>
<p>Zkontrolujte, jestli v CMakeLists.txt jsou uvedeny všechny soubory, které se mají kompilovat.
Zkuste v podokně CMake provést reload, jak je zobrazeno na obrazku.
Pokud to nepomůže, přes SSH se připojte k Raspberry Pi, v /tmp smažte momentálně používanou složku pro vzdálený vývoj, restartujte CLion.</p>
<p><img src="clion/../images/clion/clion19.png" alt="toolchain" /></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="vlastnosti-jakzyka-c17--c20"><a class="header" href="#vlastnosti-jakzyka-c17--c20">Vlastnosti jakzyka C++17 / C++20</a></h1>
<p>O těchto vlastnostech jazyka jste se pravděpodobně neučili a bude dobré když je začleníte do svých znalostí</p>
<h2 id="vynucená-inicializace"><a class="header" href="#vynucená-inicializace">Vynucená inicializace</a></h2>
<pre><code class="language-c++">  struct Trida {
     int A;
     int B;
     double C;
  };
  
  // ...
  Trida instance{1, 2, 3.14159265};  // Vynucena inicializace
</code></pre>
<p>Vynucuje inicializaci položek A,B a C v daném pořadí podle deklarace uvnitř objektu. Všechny další nastaví na 0.</p>
<h2 id="vynucené-rozbalení"><a class="header" href="#vynucené-rozbalení">Vynucené rozbalení</a></h2>
<pre><code class="language-c++">  struct Trida {
     int A;
     int B;
     double C;
  };
  
  // ...
  Trida instance{1, 2, 3.14159265};  // Vynucena inicializace
  
  auto [a, b, c] = instance;            // vynucene rozbaleni
</code></pre>
<h2 id="jmenný-alias"><a class="header" href="#jmenný-alias">Jmenný alias</a></h2>
<pre><code class="language-c++">  using NovyNazev = StaryNazev 
</code></pre>
<p>Vytvoří zástupné jméno pro komplikovanější zápis. Používá se zejména pro zvýšení čitelnsoti.</p>
<p>Kdekoliv je použit <code>NovyNazev</code>, je to jako byl na daném místě použit datový typ <code>StaryNazev</code> (oba typy jsou zaměnitelné)</p>
<p>Priklad:</p>
<pre><code class="language-c++">  using Msg = std::vector&lt;std::string&gt;;
  using Mediator = std::map&lt;std::string, std::function&lt;void(const Msg &amp;)&gt;&gt;
  
  Mediator mediator;   // odpovica std::map&lt;std::string, std::function&lt;void(const std::vector&lt;std::string&gt;&amp;)&gt;&gt;
</code></pre>
<h2 id="definice-callbacku"><a class="header" href="#definice-callbacku">Definice callbacku</a></h2>
<pre><code class="language-c++">  std::function&lt;deklarace funkce&gt; Callback;  
</code></pre>
<p>Kdykoliv potřebujete zavolat funkci s neznámým cílem funkce (koho máte volat definuje někdo jiný, nadřazený) 
použijete callback jako ukazatel na funkci. Tato funkce ale narozdíl od C-čkového ukazatele na funkci může 
být i součástí objektu. Ukazatel na funkce z jazyka C prosím nepoužívejte! </p>
<p>Příklad pouziti:</p>
<pre><code class="language-c++">  void funkce(std::string par) 
  {
    // ...
  }
  
  // ...
  std::function&lt;void(std::string)&gt; Callback;    // Deklarace callbacku
  Callback = &amp;funkce;                           // Přiřazení koho má volat
  
  // ...
  
  if (Callback)                                 // Test zdali odkaz vede na nejaky obsah
    Callback(&quot;Ahoj světe&quot;);                     // Zavolani obsahu

  // ... 
</code></pre>
<h2 id="lambda"><a class="header" href="#lambda">Lambda</a></h2>
<pre><code class="language-c++">  [zachyt](argumenty) -&gt; navratovy typ { kod funkce }  
</code></pre>
<p>Je to deklarace těla funkce bez názvu. </p>
<p>Do zachyt patří všechny proměnné, které funkce potřebuje ke svému běhu, nebo <code>&amp;</code> pokud chceme zachytit všechny automatické 
proměnné referencí, nebo <code>=</code> pokud kopií. Pokud je v zachyt znak <code>&amp;</code> nebo <code>=</code> a deklarace se nachází uvntř kontextu objektu, 
tak se implcitně zachytí i tento objekt.</p>
<p>Návratový typ se šipkou nemusí být specifikován, odvodí se pak z kontextu (z datovéhé typu za return)</p>
<p>Argumenty jsou standardní argumenty funkce jako při deklaraci. Pokud je deklarace na vhodném místě ze kterého překladač pozná 
kontext, můžeme používat auto místo datových typů.</p>
<p>Příklad:</p>
<pre><code class="language-c++">  int a = 42;
  auto f1 = [a]() { cout &lt;&lt; a &lt;&lt; endl; };                   // a zachyceno hodnotou
  auto f2 = [&amp;a]() { cout &lt;&lt; ++a &lt;&lt; endl; };                // a zachyceno referenci, muzu jej menit
  auto f3 = [=]() { cout &lt;&lt; a &lt;&lt; endl; };                   // a zachyceno hodnotou
  auto f4 = [&amp;]() { cout &lt;&lt; --a &lt;&lt; endl; };                 // a zachyceno referenci, muzu jej menit
  auto f5 = [&amp;]() { return this-&gt;NejakaFunkce(); };         // Navratova hodnota dedukovana jako navrat z NejakeFunkce (muze modifikovat objekt protoze zachyt referenci)  
  auto f6 = [=]() { this-&gt;NejakaFunkce(); };                // Pozor NejakaFunkce pracuje nad KOPII objektu - modifikuje kopii, ne puvodni objekt
  
  f1();                                                     // lambdu volam stejne jako funkci
</code></pre>
<p>Lambdy je dobre pouzivat az od C++17 protoze v C++14 a nizsim maji neintuitivni chovani ve specifickych pripadech 
a kompilator vyhazuje chyby ktere nejsou na prvni pohled zrejme</p>
<h2 id="procházení-všech-prvků-kontejneru"><a class="header" href="#procházení-všech-prvků-kontejneru">Procházení všech prvků kontejneru</a></h2>
<pre><code class="language-c++">  for (auto i: &lt;kontejner&gt;) {
    // operace s prvkem i
  }
</code></pre>
<h2 id="validátor-platnosti-s-deklarací"><a class="header" href="#validátor-platnosti-s-deklarací">Validátor platnosti s deklarací</a></h2>
<p>Pomucka pro citelnost a optimalizaci kodu - omezení platnosti proměnné pouze na úsek, kdy je platná. Pokud není platná, kompilátor ji může zahodit.</p>
<pre><code class="language-c++">  if (auto obj = DejObjekt()) {
    // zde muzu pracovat s obj pokud neni null nebo operator bool() objektu ktery vratila funkce DejObjekt vraci true
  }
  // zde obj neexistuje
</code></pre>
<pre><code class="language-c++">  if (auto obj = DejObjekt(); Podminka) {
    // zde muzu pracovat s obj pokud je podminka splnena (vraci true)
  }
  // zde obj neexistuje
</code></pre>
<p>Analogicky u <code>while</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="stl-structures"><a class="header" href="#stl-structures">STL Structures</a></h3>
<p>Součástí jazyka C++ je tzv. Standard Template Library (STL). Ta obsahuje širokou paletu různých datových struktur a naimplementovaných fukncí.
My se dnes zaměříme na část která implementuje datové konteinery.</p>
<p>Knihovna obsahuje implementace pro pole, zásobník, vektor, frontu, list, množinu, mapu (hash_tabulku/dictionary), atd. <a href="https://en.cppreference.com/w/cpp/container">Dokumentace zde</a>.</p>
<p>My se dnes zamšříme na tři struktury, a totiž std::array, std::vector a std::queue.</p>
<p>Struktury se mezi sebou liší a každá je vhodná pro jiný účel. std::array je struktura v paměti, která má známou svou velikost již během kompilace.
Pokusme se nyní takové pole vytvořit, naplnit jej hodnotami a vypočítat průměr.</p>
<pre><code class="language-cpp">    #include &lt;array&gt;

    auto my_array = std::array&lt;int, 5&gt;{0, 1, 2, 3, 4};
    int sum = 0;
    for (const auto&amp; val : my_array) {
        sum += val; 
        // sum += my_array.at(i); // equivalent approach
    }
    auto avg = sum / my_array.size();
</code></pre>
<p>Vektor se od pole liší tím, že má proměnnou velikost. Vždy když se naplní, tak se automaticky naalokuje navíc jednonásobek jeho současné velikosti.</p>
<p>Vyzkoušíme si naplnit vektor několika hodnotami a najít medián těchto hodnot.</p>
<pre><code class="language-cpp">    #include &lt;vector&gt;
    #include &lt;algorithm&gt;
    
    auto my_vector = std::vector&lt;float&gt;{};
    my_vector.push_back(5.4);
    my_vector.push_back(-3.7);
    my_vector.push_back(10.9);
    my_vector.push_back(1.3);
    my_vector.push_back(-6.5);
    my_vector.push_back(-7.8);
    my_vector.push_back(6.4);

    std::sort(my_vector.begin(), my_vector.end());
    auto med = my_vector.at(my_vector.size()/2);
    my_vector.clear();
</code></pre>
<p>Strukturu fronty využijeme jako buffer v ilustračním scénáří zpracování příchozích dat z UDP.
Uvažujme multivláknový program. Jedno vlákno přijmá data po UDP a plní frontu. Druhé vlákno pracuje asynchronně a vždy,
když přijde na řadu, zpracuje všechny doposud přijaté zprávy v pořadí tak, jak příšly.</p>
<pre><code class="language-cpp">    #include &lt;queue&gt;
        
    // queue shared between threads; Tip: mutex ?!
    auto my_queue = std::queue&lt;std::string&gt;{};
    
    // receive thread filling queue with messages
    my_queue.push(&quot;Message1&quot;);
    my_queue.push(&quot;Message2&quot;);
    my_queue.push(&quot;Message3&quot;);

    // message processing thread
    void parse_message(const std::string&amp; s) {
        std::cout &lt;&lt; &quot;Parsing: &quot; &lt;&lt; s &lt;&lt; std::endl;
    }

    while (!my_queue.empty()) {
        parse_message(my_queue.front());
        my_queue.pop();
    }
</code></pre>
<h3 id="reference"><a class="header" href="#reference">Reference</a></h3>
<p>Reference, někdy také nazývané &quot;alias&quot;, je datový typ, který směřuje (je aliasem) na již existujicí objekt v paměti.
Při kompilaci je reference obvykle nahrazena ukazatelem, ale z pohledu programátora se jedná o výrazně bezpečnější formu
práce s daty a, či objekty, protože nedovoluje některé nebezpečné operace.</p>
<p>Reference se liší od ukazatele ve dvou základních vlastnostech:</p>
<ul>
<li>Nemůže být NULL; reference je vždy nainicializovaná</li>
<li>Reference se nemůže přesměrovat na jiný objekt/data.</li>
</ul>
<p>Pozor, nezaměňovat datový typ reference &quot;<T>&amp;&quot; s operátorem reference &quot;&amp;variable&quot; !</p>
<pre><code class="language-cpp">    int a = 5;
    int&amp; b = a;
    const int&amp; c = a;
    b = 10;
    c = 15 // invalid (const ref)
    std::cout &lt;&lt; a &lt;&lt; std::endl; // a == 10
</code></pre>
<p>Reference je často používaná pro předání argumentů fukce bez nutnosti kopírování, či pro sdílení jedněch dat mezi více místy v programu.</p>
<pre><code class="language-cpp">    class VeryLargeObject {
    public:
        VeryLargeObject() {}
        const std::array&lt;double, 10000&gt;&amp; data() const {return data_;}
    private:
        std::array&lt;double, 10000&gt; data_;
    };
    
    void porocess_large_data(const VeryLargeObject&amp; d) {
        auto&amp; data = d.data(); // const reference
        auto data = d.data(); // mutable copy
        // ...
    }
    
    auto vlo = VeryLargeObject{};
    porocess_large_data(vlo);
</code></pre>
<p>Reference je často pužívaná pro vrácení hodnot z funkce skrze argument funkce.
Nejedná se však o best-practice metodu. Pokud je to jen trochu možné, měla by metoda vracet hodnotu skrze návratovou
hodnotu. Pokud je potřeba vrátit více hodnot, použijte strukturu jako návratový typ.</p>
<pre><code class="language-cpp">    void ops(float a, float b, float&amp; sum, float&amp; sub, float&amp; mul, float&amp; div) {
        sum = a + b;
        sub = a - b;
        mul = a * b;
        div = a / b;
    }

    float sum, sub, mul, div;
    ops(5, 10, sum, sub, mul, div);
    std::cout &lt;&lt; sum &lt;&lt; &quot; &quot; &lt;&lt; sub &lt;&lt; &quot; &quot; &lt;&lt; mul &lt;&lt; &quot; &quot; &lt;&lt; div &lt;&lt; std::endl;
</code></pre>
<h3 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h3>
<p>Smart pointery jsou náhradou C-čkových ukazatelů. V základu máme 3 typy těchto smart ukazatelů:</p>
<ul>
<li>std::unique_ptr&lt;T&gt;</li>
<li>std::shared_ptr&lt;T&gt;</li>
<li>std::weak_ptr&lt;T&gt;</li>
</ul>
<p>kde T je datový typ na který bude ukazatel ukazovat.</p>
<p>Vyhodou smart pointerů je, že nemusíme jako programátoři bezprostředně řešit alokaci a zejména uvolnění paměti.
Jsou li splněny podmínky, smartpointer během svého zániku zavolá také destruktor objektu, na který ukazoval a uvolní naalokovanou paměť.</p>
<p>Výsledkem je, že programátoru už nemusí používat klíčová slova <code>new</code> a <code>delete</code>.</p>
<p>Každý ze smart pointerů se však mírně liší.</p>
<h4 id="stdunique_ptrt"><a class="header" href="#stdunique_ptrt">std::unique_ptr&lt;T&gt;</a></h4>
<p>std::unique_ptr<T> je nejtriviálnější implementací smart pointeru. Smart pointer je vlastníkem objektu na který ukazuje a
neumožní toto vlastnictví (ownership) předat jinému ukazateli. Když unique_ptr zanikne, zavolá destruktor nad vlasněným objektem a dealokuje paměť.</p>
<pre><code class="language-cpp">    #include &lt;memory&gt;

    auto unique_int = std::make_unique&lt;int&gt;(5);
    std::cout &lt;&lt; *unique_int &lt;&lt; std::endl;

    float x = 10;
    auto unique_float = std::make_unique&lt;float&gt;(x);
    std::cout &lt;&lt; *unique_float &lt;&lt; std::endl;

    std::unique_ptr&lt;float&gt; y = unique_float; // error
</code></pre>
<h4 id="stdshared_ptrt"><a class="header" href="#stdshared_ptrt">std::shared_ptr&lt;T&gt;</a></h4>
<p>std::shared_ptr<T> je příkladem tzv. Automatic Reference Counter (ACR). Idea je, že při vzniku objektu se vytvoří také čítač, který čítá kolik shared_pointerů na tento objekt ukazuje.
Když vytvářím nové kopie shared pointeru, čítač roste, když tyto smart pointery zanikají, hodnota čítače klesá.</p>
<p>Když čítač dosáhne nuly, to znamená, že na objekt už nic neukazuje, je automaticky zavolán destruktor a je uvolněná paměť.</p>
<p>Pozor, nezaměňovat s Garbage Collectorem (GC), ten funguje výrazně jinak.</p>
<p>Pozor na cyklické vazby. Pokud dva objekty na sebe navzájem ukazují shared pointerem, ani jeden z objektů nikdy nezanikne. Proto zde máme weak pointery.</p>
<pre><code class="language-cpp">    #include &lt;memory&gt;
    
    auto shared_int = std::make_shared&lt;int&gt;(10);
    std::cout &lt;&lt; *shared_int &lt;&lt; std::endl;
    
    std::shared_ptr&lt;int&gt; x = shared_int;
</code></pre>
<h4 id="stdweak_ptrt"><a class="header" href="#stdweak_ptrt">std::weak_ptr&lt;T&gt;</a></h4>
<p>Obdoba shared_ptr, ale neinkrementuje čitač, který počítá, kolik je platných ukazatelů na daný objekt. To znamená, že pokud na objekt ukazuje 5 weak_ptr a žáden shared_ptr, objekt zanikne.</p>
<h3 id="oop"><a class="header" href="#oop">OOP</a></h3>
<p>Při tvorbě Vaších programů se snažte dodržovat OOP paradigma. Přemýšlejte o programu, jako o sadě black-boxů, kdy tyto schránky
jsou každá zaměřená na velmi specifický problém. Každou Vaší třídu by měla vystihovat jedna věta. Stejně tak každá funkce
by měla dělat právě jednu věc a nic víc.</p>
<p>Zmíněné blackboxy jsou mezi sebou propojeny a navzájem si předávají data.</p>
<p>Vyhněte se tvorbě &quot;supertříd&quot;, tedy tříd, které řeší &quot;všechno&quot;. Mějte své třídy úzce specializované.</p>
<p>Běžně by se měla třída vměstnant do 100 řádku. Pokud je třída nad 300 řádků, silně zvažte její rozdělení na více tříd.</p>
<p>Oddělte data od algoritmů. Vytvořte si oddělené třídy, které v sobě mají uložená data a oddelené třídy, které implementují algoritmy pro zpracování dat.</p>
<h4 id="příklad"><a class="header" href="#příklad">Příklad</a></h4>
<p>Naimplementujte příklad pomocí OOP C++. Při implementaci využijte reference a smart pointery.</p>
<p>Mějme univerzitu. Každá univerzita má 5 ročníků, v každém ročníku je libovolný počet studentů.
Když studenti nastupují na univerzitu, jsou automaticky zařazeni do 1. ročníku. Vždy, když proběhne rok,
tak univerzita prozkouší všechny studenty v ročnících a s pravděpodobností 0.9 posune studenta do vyžšího ročníku. Pokud student projde pátý ročníku,
univerzita si jej zaznamená jako absolventa.
Na konci každého roku vytiskněte stav univerzity a všech studentů na ní.</p>
<p>Tip: Třídy a jejich členské proměnné:</p>
<pre><code>Trida Student:
promenne:
    jmeno, 
    prijmeni
metody:
</code></pre>
<pre><code>Trida Rocnik:
proměnné:
    seznam_vsech_studentu
metody:
    pridat_studenta_do_rocniku(student)
    evaluovat_ročník() -&gt; seznam_uspesnych_studentu
</code></pre>
<pre><code>Třída Univezita:
proměnné:
    seznam_rocniku
    seznam absolventu
metody:
    vykonat_akademicky_rok()
    vytisknout_stav_univerzity();
</code></pre>
<p>Implementace:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;array&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;random&gt;

class Student {
public:
    Student(const std::string&amp; first_name, const std::string&amp; surname)
        : first_name_{first_name}
        , surname_{surname} {}
    std::string first_name() const {return first_name_;};
    std::string surname() const {return surname_;};
private:
        const std::string first_name_;
        const std::string surname_;
    };
    
    
class Grade {
        static constexpr float change_of_student_passes_grade = 0.8f;
public:
    void add_student(std::shared_ptr&lt;Student&gt; stud) {students_.push_back(stud);}
    std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; evaluate_year() {
        std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; successful_students{};
        std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; failed_students{};
        for (auto&amp; stud : students_) {
            auto random_num = get_random_number(0.0f, 1.0f);
            if (random_num &gt; change_of_student_passes_grade) {
                failed_students.push_back(stud);
            }
            else {
                successful_students.push_back(stud);
            }
        }
        students_ = failed_students;
        return successful_students;
    }
    std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; students() const {return students_;}
    float get_random_number(float min, float max) {
        static std::random_device rd;
        static std::mt19937 gen(rd());
        static std::uniform_real_distribution&lt;float&gt; distr(min, max);
        return distr(gen);
    }
private:
    std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; students_;
};
    
    
class University {
    static constexpr size_t no_of_grades = 5;
public:
    void add_student(std::shared_ptr&lt;Student&gt; stud) {grades_.at(0).add_student(stud);}
    void evaluate_year() {
        for (int i = no_of_grades-1 ; i &gt;= 0 ; i--) {
            auto successfull_studs = grades_.at(i).evaluate_year();
            if (i == no_of_grades-1) { // last grade
                for (auto&amp; stud : successfull_studs) {graduated_.push_back(stud);}
            } else {
                for (auto&amp; stud : successfull_studs) {grades_.at(i+1).add_student(stud);}
            }
        }
    }
    void print_state() {
        for(size_t i = 0 ; i &lt; no_of_grades ; i++) {
            std::cout &lt;&lt; &quot;    Grade:&quot; &lt;&lt; i+1 &lt;&lt; std::endl;
            auto studs = grades_.at(i).students();
            for (const auto&amp; stud : studs) {
                std::cout &lt;&lt; &quot;       &quot; &lt;&lt; stud-&gt;first_name() &lt;&lt; &quot; &quot; &lt;&lt; stud-&gt;surname() &lt;&lt; std::endl;
            }
        }
        std::cout &lt;&lt; &quot;    Graduated:&quot; &lt;&lt; std::endl;
        for (const auto&amp; stud : graduated_) {
            std::cout &lt;&lt; &quot;       &quot; &lt;&lt; stud-&gt;first_name() &lt;&lt; &quot; &quot; &lt;&lt; stud-&gt;surname() &lt;&lt; std::endl;
        }
    }
private:
    std::array&lt;Grade, no_of_grades&gt; grades_;
    std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; graduated_;
};
    
int main() {
    University Oxenfurt;
    Oxenfurt.add_student(std::make_shared&lt;Student&gt;(&quot;Triss&quot;, &quot;Merigold&quot;));
    Oxenfurt.add_student(std::make_shared&lt;Student&gt;(&quot;Geralt&quot;, &quot;of Rivia&quot;));
    Oxenfurt.add_student(std::make_shared&lt;Student&gt;(&quot;Zoltan&quot;, &quot;Chivay&quot;));
    Oxenfurt.add_student(std::make_shared&lt;Student&gt;(&quot;Yennefer&quot;, &quot;of Vengerberg&quot;));
    Oxenfurt.add_student(std::make_shared&lt;Student&gt;(&quot;Cirilla&quot;, &quot;of Cintra&quot;));
    for (size_t i = 0 ; i &lt; 6 ; i++) {
        std::cout &lt;&lt; &quot; ---------- &quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;Year &quot; &lt;&lt; i+1 &lt;&lt; std::endl;
        Oxenfurt.evaluate_year();
        Oxenfurt.print_state();
    }
    return 0;
}
</code></pre>
<h3 id="const"><a class="header" href="#const">Const</a></h3>
<p>Rychlý přehled užití const v kódu</p>
<pre><code class="language-cpp">
    // Helpre Object
    class Object {
    public:
        void do_non_const_work() {counter++;} // non-const member method
        void do_const_work() const {std::cout &lt;&lt; counter &lt;&lt; std::endl;} // const method, can not modify member variables
    private:
        int counter = 0;
    };


     // Variables
     
    int a = 1; // mutable variable
    const int b = 2; // non-mutable (const) variable
    
    
    // References
    
    int&amp; c = a; // mutable reference to a
    const int&amp; d = a; // const reference to a
    
    
    // Pointers
    
    int* e = &amp;a;    // pointer to a
    const int* f = &amp;a;  // pointer to constant a (value of a can not be changed)
    int const* g = &amp;a;  // the same
    *f = 5; // error
    f = e;  // ok
    
    int *const h = &amp;a;  // non-mutable (const) pointer to mutable variable
    h = e;  // error
    *h = 5; // ok
    
    const int * const i = &amp;a; // const pointer to const variable
    *i = 5; // error
    i = e;  // error
    
    
    // Data Structures
    
    std::vector&lt;Object&gt; v1 = {Object{}, Object{}, Object{}};    // Vector of 3 objects
    const std::vector&lt;Object&gt; v2 = {Object{}, Object{}, Object{}};   // constant vector (can not add or remove values from it); returns const refs to object
    v2.push_back(Object{}); // error
    v2.clear(); // error
    v2.at(0).do_non_const_work(); // error
    v2.at(0).do_const_work(); // ok
    
    
    // Smart Pointers
    
    std::shared_ptr&lt;int&gt; sp1 = std::make_shared&lt;int&gt;(5); // normal shared pointer
    std::shared_ptr&lt;const int&gt; sp2 = sp1; // shared pointer to const value
    *sp2 = 5; // error
    sp2 = sp1; // ok
    const std::shared_ptr&lt;int&gt; sp3 = sp1;   // constant pointer to mutable value
    *sp3 = 5; // ok
    sp3 = sp2; // error
    const std::shared_ptr&lt;const int&gt; sp4 = sp1;
    *sp4 = 5; // error
    sp4 = sp2; // error
    
    
    // Const vs Constexpr vs Define
    
    const int x = 5; // this variable can be initialized in runtime (read user input)
    #define Y = 5 // const defined for preprocessor (non type safe)
    constexpr int y = 5; // this variable MUST be initialized in compile-time (similar to #define Y 5, but type-safe)
    
    
    // &quot;Rustification&quot;
    
    #define let const auto
    #define mut auto
    
    let a = 5;  // cosnt variable
    mut b = 3;  // mutable variable
    let&amp; c = a; // const reference
    mut&amp; d = b; // mutable reference
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standardní-kontejnery-v-c"><a class="header" href="#standardní-kontejnery-v-c">Standardní kontejnery v C++</a></h1>
<h2 id="stdstring"><a class="header" href="#stdstring">std::string</a></h2>
<p>Je to kontejner, pro obyčejný text. Obsahuje základní funkce pro práci s textem.</p>
<p>Může sice obsahovat UTF-8, ale nepočítá jeden znak UTF-8 jako primitivu, ale jako sekvenci několika bajtů.</p>
<h2 id="stdvectortyp"><a class="header" href="#stdvectortyp">std::vector&lt;typ&gt;</a></h2>
<p>Je to dynamické pole, které obsahuje prvky specifikovaného datového typu.</p>
<p>Jedotlivé prvky jsou indexovány od nuly</p>
<pre><code class="language-c++">  std::vector&lt;int&gt; vektor{
    1,3,5,7,11,13,17,
  };
  
  vektor[5] = 4;                              // zápis do položky
  cout &lt;&lt; vektor[0] * vektor[2] &lt;&lt; endl;      // čtení z položky
  
  if (auto p = vektor.find(13); p != vektor.end()) {  // hledání prvku
    cout &lt;&lt; *p &lt;&lt; endl;                       // prvek se nachází ve vektoru
  }
</code></pre>
<h2 id="stdunordered_mapklíčtyp"><a class="header" href="#stdunordered_mapklíčtyp">std::unordered_map&lt;klíč,typ&gt;</a></h2>
<p>Je to adresovatelný kontejner, kde každá hodnota má specifikovaný klíč, pod kterým ji lze najít.
Kontejner zajišťuje oproti std::map co nejrychlejší adresaci za pomocí hashe.</p>
<pre><code class="language-c++">  std::unordered_map&lt;std::string, double&gt; mapa{
    { &quot;PI&quot;, 3.14159},
    { &quot;E&quot;, 2.71828},
  };
  
  mapa.emplace_back
  mapa[&quot;FN&quot;] = 598722.4879;                         // definice Baštincova čísla  (zápis do položky)
  cout &lt;&lt; mapa[&quot;E&quot;] * mapa[&quot;E&quot;] &lt;&lt; endl;            // čtení z položky
  
  if (auto p = mapa.find(&quot;ZY&quot;); p != mapa.end()) {  // hledání prvku
    cout &lt;&lt; p-&gt;second &lt;&lt; endl;                      // ZY se nachází v mapě
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standardní-algoritmy-v-c"><a class="header" href="#standardní-algoritmy-v-c">Standardní algoritmy v C++</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="návrhové-vzory-design-patterns"><a class="header" href="#návrhové-vzory-design-patterns">Návrhové vzory (design patterns)</a></h1>
<h2 id="builder"><a class="header" href="#builder">Builder</a></h2>
<h2 id="observer"><a class="header" href="#observer">Observer</a></h2>
<h2 id="mediator"><a class="header" href="#mediator">Mediator</a></h2>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="robotic-operating-system"><a class="header" href="#robotic-operating-system">Robotic Operating System</a></h1>
<p>Název &quot;Robot Operating System&quot; poněkud klame svým zněním. Nejedná se o samostaný operační sýstém, nýbrž spíše o middle-ware, tedy softwarový nástroj (knihovnu), který pomáha propojit dílčí programy do komplexnejšího celku. V praxi si to můžem představit tak, že máme jednoduchou aplikaci pro robota jezdícího po čáre, kterou realizujeme pomoci 3 navzájem spolupracujících programů (příklad funguje jako ilustrační; takového robota samozřejmě můžeme naprogramovat pomocí jednoho programu; ilustrujeme tím ale komplexnější problém). První program vyčítá data ze snímače a provádí jednoduchou filtraci dat. Druhý program je mozkem celého řešení a rozhoduje o pohybu robota. Třetí program pak přijímá řídicí pokyny a na jejich základě ovládá motory.</p>
<p><img src="ros/../images/robot_scheme.png" alt="Rviz" /></p>
<p>Obr: Schéma fungování pomyslého line-tracking robota na platformě Rapserry Pi s pouřitím ROSu.</p>
<p>V případě absence ROSu bychom museli vymyslet způsob jak tyto tři programy spolu budou komunikovat. Mohli bychom sdílet paměť, pipovat, posílat si IP zprávy, používat DBus, etc. Všechny tyto techniky fungují, ale vyžadují určitý programátorský um. My se těmito nízkouúrovňovými problémy nechceme zabývat a proto použijeme ROS.</p>
<p>V praxi si pak můžeme říct, že ROS komunikuje mezi procesy právě pomocí posílání UDP paketů. To umožňuje také komunikovat procesům, které běží na různých počítačích. Tomu říkáme distribuovaný systém.</p>
<p>Celý ROS je postaven na 4 stavebních kamenech.</p>
<ul>
<li>ROS Core</li>
<li>ROS Node</li>
<li>ROS Topic</li>
<li>ROS Message</li>
</ul>
<p>ROS Core - Zjednodušeně řečeno se jedná o IP server, který zajištujě propojení programů (Nodů), které si chtějí vyměnovat data (Message) . Core nativně otevře port 11311 na localhostu a čeká na příchozí komunikaci.</p>
<p>ROS Node - Nodem je myšlený každý program do kterého přídáme klinetskou knihovnu ROSu. Naučíme tedy program používat funkce ROSu.</p>
<p>ROS Topic - Doména, ve které se posílá specifický okruh ROS Messagů.</p>
<p>ROS Message - Jedna instance odeslané zprávy. V rámci ROSu je možné posílat jenom zprávy, které jsou striktně zadefinovány a mají svůj jasně daný formát. Často obsahují také časovou značku, kdy byly odeslány.</p>
<p>Dále si zadefinujme dva typy postavení ROS Nodů při komunikaci.</p>
<p>Subscriber - ROS Node, který přijímá všechny zprávy v rámci daného ROS Topicku.</p>
<p>Publisher - ROS Node, který vytváří a odesíla zprávy v rámci daného ROS Topicku.</p>
<p>Náš robot-sledující-čáru příklad si pak můžem ilustrovat takto:</p>
<p><img src="ros/../images/ros_com_scheme.png" alt="Rviz" /></p>
<p>Nejprve zapneme ROS Core, tedy server, který začte poslouchat příchozí komunikaci. Dále si napíšeme zmíněne 3 programy. Jeden pro čtení dat ze snímače, druhý pro rozhodování, jak se pohybovat a třetí pro ovládání motorů. První program (Node) se přihlásí k serveru, jako publisher pro topick &quot;SensorData&quot;. Druhý se přihlásí serveru, jako subscriber v tomtéž topicku. Server si tyto dva nody poznamená a publisherovi odešle informaci, že je v sídi na dané adrese a portu připravený subscriber, který si vyžádal data z topicku, který oba nody sdílí. Když pak první program přečte data ze snímače, vyfiltruje je a vytvoří z nich message, kterou pošle na dříve obdrženou adresu a port, aby data obdržel subscriber. Obdobným způsobem se vymění data i mezi druhým a třetím programem, pouze pod hlavičkou jiného topicku.</p>
<p>Nyní máme vytvořené všechny tři programy. Ty spolu komunikují, ale robot přesto nefunguje podle přestav. Tušíme, že chyba je v tom, jak druhý program převádí data ze snímače na pohyb kol. Proto si napíšeme 4. program, který bude poslouchat veškerou komunikaci a bude ji logovat do souboru. Náš nový program tedy bude subscriberem pro oba dříve zavedené topicky &quot;SensorData&quot; a &quot;MotorControl&quot;. V okamžiku kdy tento program zapneme, tak se ohlásí serveru a od tohoto okamžiku všechny zprávy odeslané v topicích &quot;SensorData&quot; a &quot;MotorControl&quot; budo poslány také našemu logovcímu programu. Ten zprávy přijíme a jejich obsach včetně časové značky vytiskne do souboru. Když se pak do souboru podíváme, zjistíme, že plánovací program vatváří akční zásah vždy s opačným znaménkem, proto přídáme &quot;-&quot; do výpočtu akčního zásahu a vše začne fungovat.</p>
<h2 id="instalace-ros"><a class="header" href="#instalace-ros">Instalace ROS</a></h2>
<p>Instalaci ROSu na nově nainstalovaný Linux proveďte pomocí návodu popsaného v kiapitole <a href="ros/ros.html">Robotic Operating System</a>.</p>
<h2 id="instalace-rosu"><a class="header" href="#instalace-rosu">Instalace ROSu</a></h2>
<p>Tento návod je pouze českým přepisem oficiální dokumentace (Instalace pro Ubuntu)[http://wiki.ros.org/noetic/Installation/Ubuntu]. Prim8rn2 prosím používejte oficiální verzi. Tento návod je pouze doprovodný.</p>
<p>Instalace je doporučená na distribuci Ubuntu 20.04 LTS (long term stable). Instalovat budeme verzi ROSu z roku 2020, Noetic.</p>
<p>Přidáme do Linuxu repozitáře (servery) ze kterých je možné stáhnout ROS.</p>
<pre><code>sudo sh -c 'echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list'
</code></pre>
<p>Přidáme do systému klíč pro zabezpečenou komunikace s repozitářem.</p>
<pre><code>sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654
</code></pre>
<p>Necháme baličkovací systém načíst nově přidaná data.</p>
<pre><code>sudo apt update
</code></pre>
<p>Samotný ROS nainstalujeme příkazem. Trvá cca 10 min.</p>
<pre><code>sudo apt install ros-noetic-desktop-full
</code></pre>
<p>A na závěr si do souboru ~/.bashrc přídáme záznam o náčítání ROSu do proměnného prostředí, kdykoliv zapneme terminál.</p>
<pre><code>echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc
source ~/.bashrc
</code></pre>
<h2 id="tvorba-vlastního-nodu"><a class="header" href="#tvorba-vlastního-nodu">Tvorba vlastního nodu</a></h2>
<p>Vytvoříme si jednoduchou aplikaci, kte jeden node bude odesílat zprávu s pořadovým číslem a časovou značkou a druhý node zprávu přijíme, vypíše a zjisti, s jakým zpožděním zpráva došla.</p>
<p>Nejprve si vytvoříme tzv workspace pro náš projekt. Workspacem se myslí speciálně uspořádaná složka.</p>
<pre><code>cd ~/
mkdir ros_ws
cd ros_ws
mkdir src
cd src
</code></pre>
<h3 id="c-node"><a class="header" href="#c-node">C++ Node</a></h3>
<p>Dále si pomocí catkinu (balíčkovací nástroj pro ROS) necháme vztgenerovat nový balíček (package).</p>
<pre><code>catkin_create_pkg cpp_publisher std_msgs roscpp
</code></pre>
<p>Příkaz nám říká, že budeme volat program catkin_create_pkg a chceme po něm, aby nám vytvořil balíček cpp_publisher a připojil k němu knihovny std_msgs, která obsahuje základní sadu ROS zpráv a taktéž knihovnu roscpp, což je základní knihovana pro implementaci ROS Nodu v C++.</p>
<p>Nyní se náš balíček skládá z několika následujícíh souborů</p>
<pre><code>~/ros_ws/src/cpp_publisher/
    include/
    src/
    CMakeLists.txt
    package.xml
</code></pre>
<p>Do adresářů include a src budeme ukládat naše zdrojové kódy a soubory CMakeLists.txt a package.xml slouží ke kompilaci balíčku.</p>
<p>CMakeLists.txt a package.xml obsahují velké množství předpřipravených direktiv, které slouží složitějším příkladům. Pro naše potřeby si můžeme tyto dva soubory smazat.</p>
<pre><code>cd ~/ros_ws/src/cpp_publisher/
rm CMakeLists.txt
rm package.xml
</code></pre>
<p>Pomocí programu nano, nebo vim si oba soubory znovu vytvoříme tak a přidáme následující obsah.</p>
<pre><code>nano CMakeLists.txt
</code></pre>
<pre><code>cmake_minimum_required(VERSION 2.8.3)
project(cpp_publisher)

## Find catkin and any catkin packages
find_package(catkin REQUIRED COMPONENTS roscpp std_msgs)


## Declare a catkin package
catkin_package()

## Build talker and listener
include_directories(include ${catkin_INCLUDE_DIRS})

add_executable(cpp_publisher src/main.cpp)
target_link_libraries(cpp_publisher ${catkin_LIBRARIES})
</code></pre>
<p>a</p>
<pre><code>nano package.xml
</code></pre>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;package format=&quot;2&quot;&gt;
  &lt;name&gt;cpp_publisher&lt;/name&gt;
  &lt;version&gt;0.0.0&lt;/version&gt;
  &lt;description&gt;The cpp_publisher package&lt;/description&gt;

  &lt;maintainer email=&quot;my@email.todo&quot;&gt;adash&lt;/maintainer&gt;

  &lt;license&gt;TODO&lt;/license&gt;

  &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;
  &lt;build_depend&gt;roscpp&lt;/build_depend&gt;
  &lt;build_depend&gt;std_msgs&lt;/build_depend&gt;
  &lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;
  &lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;
  &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;
  &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;

  &lt;export&gt;

  &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<p>Nyní si můžeme vytvořit soubor main.cpp ve složce src a do něj napíšeme vlastní program</p>
<pre><code>nano src/main.cpp
</code></pre>
<pre><code>#include &lt;sstream&gt;

#include &quot;ros/ros.h&quot;
#include &quot;std_msgs/Header.h&quot;

int main(int argc, char **argv) {
    ros::init(argc, argv, &quot;cpp_publisher&quot;);
    ros::NodeHandle n;

    ros::Publisher publisher = n.advertise&lt;std_msgs::Header&gt;(&quot;/my_topic&quot;, 1);
    ros::Rate loop_rate(10);

    int count = 0;
    while (ros::ok()) {

        std_msgs::Header msg;
        msg.stamp = ros::Time::now();
        msg.seq = count++;
        msg.frame_id = &quot;origin&quot;;

        publisher.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}
</code></pre>
<p>Nyní se vrátíme do kořene našeho workspacu a zavoláme příkaz pro build celého workspacu.</p>
<pre><code>cd ~/ros_ws
catkin_make
</code></pre>
<p>Pokud se nevypíše žádná chyba, máme hotový publisher, který je uložený v  ~/ros_ws/devel/lib/cpp_publisher.</p>
<p>Aby si Linux načetl nově zkompilované programy z našeho ros_ws přidámi si tento workspace do systémového prostředí (environmentu).</p>
<pre><code>source ~/ros_ws/devel/setup.bash
</code></pre>
<p>Abychom tuto akci již nemuseli opakovat přidáme si tento řádek také do ~/.bashrc</p>
<pre><code>echo &quot;source ~/ros_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc
</code></pre>
<p>Nyní si otevřeme další 2 terminály tak, abychom celkem měli 3 okna terminálu. V jednom aktivujeme roscore</p>
<pre><code>roscore
</code></pre>
<p>Ve druhém námi vytvořený publisher.</p>
<pre><code>rosrun cpp_publisher cpp_publisher
</code></pre>
<p>A ve třetím si poslechneme zprávy na topicku /my_topic</p>
<pre><code>rostopic echo /my_topic
</code></pre>
<p>Pokud vidíte v terminále výpis zpráv, vše pracuje, jak má.</p>
<h3 id="python-node"><a class="header" href="#python-node">Python Node</a></h3>
<p>Vytvoříme si další balíček pomocí</p>
<pre><code>cd ~/ros_ws/src/
catkin_create_pkg python_subscriber std_msgs rospy
</code></pre>
<p>a upravíme si strukturu balíčku tak, aby vypadala následovně.</p>
<pre><code>~/ros_ws/src/python_subscriber/
    bin/
        python_subscriber.py
    include/
    src/
    setup.py
    CMakeLists.txt
    package.xml
</code></pre>
<p>Složka bin bude soužit k uložení hlavního skriptu python_subscriber.py, include a src pro další zdrojové kódy, které ale dneska nevyužijeme a CMakeLists.txt a package.xml obdobně jako pro C++ příklad. setup.py slouží k instalaci pythoniho balíčku do workspacu.</p>
<p>Zmíněné soubory si pak upravíme následovně.</p>
<pre><code>cmake_minimum_required(VERSION 2.8.3)
project(python_subscriber)

find_package(catkin REQUIRED COMPONENTS
  rospy
  std_msgs
)

catkin_package()

catkin_python_setup()
</code></pre>
<p>dále</p>
<pre><code>nano package.xml
</code></pre>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;package format=&quot;2&quot;&gt;
  &lt;name&gt;python_subscriber&lt;/name&gt;
  &lt;version&gt;0.0.0&lt;/version&gt;
  &lt;description&gt;The python_subscriber package&lt;/description&gt;

  &lt;maintainer email=&quot;my@email.todo&quot;&gt;adash&lt;/maintainer&gt;

  &lt;license&gt;TODO&lt;/license&gt;

  &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;
  &lt;build_depend&gt;rospy&lt;/build_depend&gt;
  &lt;build_depend&gt;std_msgs&lt;/build_depend&gt;
  &lt;build_export_depend&gt;rospy&lt;/build_export_depend&gt;
  &lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;
  &lt;exec_depend&gt;rospy&lt;/exec_depend&gt;
  &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;

  &lt;export&gt;

  &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<p>pak</p>
<pre><code>nano setup.py
</code></pre>
<pre><code>## ! DO NOT MANUALLY INVOKE THIS setup.py, USE CATKIN INSTEAD

from distutils.core import setup
from catkin_pkg.python_setup import generate_distutils_setup

# fetch values from package.xml
setup_args = generate_distutils_setup(
    packages=['python_subscriber'],
    package_dir={'': 'src'},
)

setup(**setup_args)
</code></pre>
<p>a finálně</p>
<pre><code>nano python_subscriber.py
</code></pre>
<pre><code>#!/usr/bin/env python
import rospy
from std_msgs.msg import Header

def callback(message):

    now = rospy.Time.now()
    delta_t = (now.secs - message.stamp.secs)*1000000000 + (now.nsecs - message.stamp.nsecs)

    print('seq: ' + str(message.seq))
    print('frame id: ' + message.frame_id)
    print('send time: ' + str(message.stamp.secs) + '.' + str(message.stamp.nsecs).zfill(9) + 's')
    print('receive time: ' + str(now.secs) + '.' + str(now.nsecs).zfill(9) + 's')
    print('delay [ns]: ' + str(delta_t))
    print(30*'*')

def listener():

    rospy.init_node('listener', anonymous=True)

    rospy.Subscriber(&quot;/my_topic&quot;, Header, callback)

    # spin() simply keeps python from exiting until this node is stopped
    rospy.spin()

if __name__ == '__main__':
    listener()
</code></pre>
<p>a přídáme souboru python_subscriber.py flag pro spouštění, aby bylo možné zapnout skript.</p>
<pre><code>chmod +x ~/ros_ws/src/python_subscriber/bin/python_subscriber.py
</code></pre>
<p>Nyní se můžeme vrátit do kořene workspacu a vše ykompilovat.</p>
<pre><code>cd ~/ros_ws/
catkin_make
</code></pre>
<p>Zaktualizujeme si proměné prostředí.</p>
<pre><code>source ~/ros_ws/devel/setup.bash
</code></pre>
<p>Pokud máme aktivní roscore i cpp_publisher, pak zampene node pomocí</p>
<pre><code>rosrun python_subscriber python_subscriber
</code></pre>
<p>a vidíme výpis přijímaných zpráv.</p>
<p>Pomocí programu rqt_graph si můžeme prohlédnout aktuální stav propojení nodů.</p>
<pre><code>rosrun rqt_graph rqt_graph
</code></pre>
<p><img src="ros/../images/rqt_graph.png" alt="rqt_graph" /></p>
<p>Obr: vizualizace komunikace mezi nody pomocí rqt_graph</p>
<h2 id="rviz"><a class="header" href="#rviz">Rviz</a></h2>
<p>Rviz je vizualizační nástroj, který je dodáván jako součást ROSu. Jedná se o aplikaci, která dokáže poslouchat širokou paletu předdefinovaných ROS zpráv a vizualizovat je v 3D grafickém prostředí.</p>
<p>Obvzkle Rviz používáme pro vizualizaci pointcloudů (mrařna bodů z LIDARu), obrázků z kamery, vykreslování geometrických primitiv v prostoru, vizualizace occupancy grid map, atd.</p>
<p>Pokud nám již běži roscore, rviz aktivujeme pomocí</p>
<pre><code>rosrun rviz rviz
</code></pre>
<p>Vizualizaci konkrétního topicku pak aktivujeme pomocí</p>
<p>Add -&gt; By topic -&gt; [náš topick]</p>
<p>V sekci</p>
<p>Add -&gt; By display type</p>
<p>vidíme všechny podporované typy zpráv (viz online dokumentace ROSu).</p>
<p><img src="ros/../images/rviz.png" alt="rqt_graph" />
Obr: příklad vizualizace pointcloudu a kamery v Rvizu</p>
<p>Nyní si skusme vytvořit vlastní Node, který bude vykreslovat geometrické primitivum do RVizu. Vyjděme z příkladu cpp_ros_publishera a vytvořné následujicí program.</p>
<pre><code>cd ~/ros_ws/src
catkin_create_pkg cpp_rviz_publisher std_msgs visualization_msgs roscpp
</code></pre>
<p>CMakeLists.txt</p>
<pre><code>cmake_minimum_required(VERSION 2.8.3)
project(cpp_rviz_publisher)

## Find catkin and any catkin packages
find_package(catkin REQUIRED COMPONENTS roscpp std_msgs visualization_msgs)


## Declare a catkin package
catkin_package()

## Build talker and listener
include_directories(include ${catkin_INCLUDE_DIRS})

add_executable(cpp_rviz_publisher src/main.cpp)
target_link_libraries(cpp_rviz_publisher ${catkin_LIBRARIES})
</code></pre>
<p>package.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;package format=&quot;2&quot;&gt;
  &lt;name&gt;cpp_rviz_publisher&lt;/name&gt;
  &lt;version&gt;0.0.0&lt;/version&gt;
  &lt;description&gt;The cpp_rviz_publisher package&lt;/description&gt;

  &lt;maintainer email=&quot;my@email.todo&quot;&gt;adash&lt;/maintainer&gt;

  &lt;license&gt;TODO&lt;/license&gt;

  &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;
  &lt;build_depend&gt;roscpp&lt;/build_depend&gt;
  &lt;build_depend&gt;std_msgs&lt;/build_depend&gt;
  &lt;build_depend&gt;visualization_msgs&lt;/build_depend&gt;
  &lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;
  &lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;
  &lt;build_export_depend&gt;visualization_msgs&lt;/build_export_depend&gt;
  &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;
  &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;
  &lt;exec_depend&gt;visualization_msgs&lt;/exec_depend&gt;

  &lt;export&gt;

  &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<p>src/main.cpp</p>
<pre><code>#include &lt;sstream&gt;
#include &lt;ros/ros.h&gt;
#include &lt;visualization_msgs/Marker.h&gt;

visualization_msgs::Marker createCuteCube(float pose) {

    visualization_msgs::Marker marker;
    marker.header.frame_id = &quot;map&quot;;
    marker.header.stamp = ros::Time();
    marker.ns = &quot;cube&quot;;

    marker.id = 0;
    marker.type = visualization_msgs::Marker::CUBE;
    marker.action = visualization_msgs::Marker::ADD;

    marker.pose.position.x = sin(pose);
    marker.pose.position.y = cos(pose);
    marker.pose.position.z = 0.1*sin(5*pose);

    marker.pose.orientation.x = 0.0;
    marker.pose.orientation.y = 0.0;
    marker.pose.orientation.z = 0.0;
    marker.pose.orientation.w = 1.0;

    marker.scale.x = 0.1;
    marker.scale.y = 0.1;
    marker.scale.z = 0.1;

    marker.color.a = 1.0;
    marker.color.r = 0.0;
    marker.color.g = 1.0;
    marker.color.b = 0.0;

    return marker;
}


int main(int argc, char **argv) {

    ros::init(argc, argv, &quot;cpp_rviz_publisher&quot;);
    ros::NodeHandle n;

    ros::Publisher vis_pub = n.advertise&lt;visualization_msgs::Marker&gt;( &quot;/cute_cube&quot;, 0 );
    ros::Rate loop_rate(100);

    float pose = 0;
    while (ros::ok()) {
        visualization_msgs::Marker cube = createCuteCube(pose);
        vis_pub.publish( cube );
        pose += 0.01;

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}
</code></pre>
<p>V Rvizu si pak otevřeme topic /cute_cube .</p>
<h2 id="distribuovaný-ros"><a class="header" href="#distribuovaný-ros">Distribuovaný ROS</a></h2>
<p>Tím, že calý backend ROS-ové komunikace je postaven na IP komunikaci (UDP protokolu), je možné snadno komunikaci mezi Nody přenést i na jiné počítače v dostupné síti. Po nainstalování je ROS nakonfigurován tak, že veškerá komunikace s Corem probíha na adrese http://localhost:11311, a Nody si bindují dostupné volné UDP porty a skrze něj komunikují mezi sebou. Pokud ale nastavíme na lokálním stroji proměnnou ROS_MASTER_URI na jinou IP adresu, bude každý nově nastartovaný Node hledat svůj ROS Core na adrese uvedené v ROS_MASTER_URI.</p>
<p>Spojme si 2 počitáče skrze IP síť a ověřme, že na seba navzájem vidí příkazem PING.</p>
<pre><code>ping xxx.yyy.zzz.qqq
</code></pre>
<p>Pokud oba počítače na sebe navzájem vidí, můžeme na počítači, kde chceme provozovat ROS Core nastavit proměnné, a aktivovat Core.</p>
<pre><code>export ROS_MASTER_URI=http://localhost:11311
export ROS_IP=&lt;ip_adresa_pocitace&gt;
roscore
</code></pre>
<p>Na 2. počítači, kde poběží nody musíme nastavit prostředí tak aby dokázalo najít ROS Core v síti.</p>
<pre><code>export ROS_MASTER_URI=http://&lt;ip_adresa_coru&gt;:&lt;port_coru&gt;
export ROS_IP=&lt;ip_adresa_pocitace&gt;
</code></pre>
<p>Ověřit nastavení proměnných můžeme příkazy</p>
<pre><code>echo $ROS_MASTER_URI
echo $ROS_IP
</code></pre>
<p>Nyní, pokud aktivujeme publisher a subscriber na libovolném počítači v takto nastavené ROS síti, budou nody spolu komunikovat.</p>
<p><img src="ros/../images/ros_distributed.png" alt="rqt_graph" />
Obr: příklad konfigurace ROSu na dvou počítačích.</p>
<h2 id="kam-dál"><a class="header" href="#kam-dál">Kam dál?</a></h2>
<p>Tento tutoriál je popisuje pouze malý zlomek všech možných funkcionalit této obšírné platformy.</p>
<p>Oficiální web [1] - http://www.ros.org/</p>
<p>Oficiální tutoriály [2] - http://wiki.ros.org/ROS/Tutorials</p>
<p>Naučit se používat ROS Services [6]</p>
<p>Seznamy několika předdefinovaných ROS Messagů - [4] [5]</p>
<p>Pro zdatné ROSáky je možnost se posunout na další kvalitativní level, a totiž ROS 2 [3]. Druhá verze robotického operačního systému je již koncipováná jako real-time middleware s podporou QoS a širokou paletou služeb, které ocení zejména vývojáři sofistikovaných robotických řešení, na která bude kladeny řádově vyžší kvalitativní nároky.</p>
<p>Pro reálnou práci se zdrojovými kódy je vhodné použít nějaké IDE. V případě Linuxu vřele doporučuji programy od  JetBrains, CLion pro vývoj C++ a Pycharm pro práci s pythonem. Oba programy jsou pro studenty VUT zdarma.</p>
<h2 id="reference-1"><a class="header" href="#reference-1">Reference</a></h2>
<p>[1] http://www.ros.org/</p>
<p>[2] http://wiki.ros.org/ROS/Tutorials</p>
<p>[3] https://github.com/ros2/ros2/wiki</p>
<p>[4] http://wiki.ros.org/std_msgs</p>
<p>[5] http://wiki.ros.org/sensor_msgs</p>
<p>[6] http://wiki.ros.org/Services</p>
<p>[7] https://www.computerhope.com/unix/uchmod.htm</p>
<p>[8] http://wiki.ros.org/ROS/Installation</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supersmyčka-a-regulace-v-ní"><a class="header" href="#supersmyčka-a-regulace-v-ní">Supersmyčka a regulace v ní</a></h1>
<pre><code class="language-c++">const int T = 30;
long long ms = millis() + T;
while(rum) {
    comm.send(sensor.BuildReads());
    comm.send(drive.BuildReads());
    
    while (ms &lt; millis())
      comm.loop();
      
    ms = millis() + T;
    
    sensor.ProcessLineSensors();
    drive.ComputeOdometry();
    
    controller.Control();                                                       
    
    drive.ComputeMotorRamps();        
    comm.send(sensor.BuildWrites());
    comm.send(drive.BuildWrites());
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mediator---protokolový-eventový-parser"><a class="header" href="#mediator---protokolový-eventový-parser">Mediator - Protokolový eventový parser</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="controller"><a class="header" href="#controller">Controller</a></h1>
<p>Někdy je třeba řídit robot v různých okamžicích různým způsobem (např. robot nejprve musí zkalibrovat senzor čáry, aby 
mohl vyrazit na soutěžní trať ), přičemž potřebujeme, aby důležité části chodu supersmyčky probíhaly ve správném čase</p>
<p>Ideální je implementace stavového automatu. Jde ji řešit hloupým a nepřehledným způsobem <strong>switch-case</strong> nebo <strong>funkcionálně</strong></p>
<h2 id="funkcionální-přístup"><a class="header" href="#funkcionální-přístup">Funkcionální přístup</a></h2>
<p>Nejprve musíme deklarovat <strong>ukazatel</strong> na prováděcí <strong>funkci stavu</strong>. </p>
<p>Pokud budou všechny stavy obsluhovány jedním objektem, je možné vytvořit ukazatel na metodu aktuálního objektu. </p>
<pre><code class="language-c++">using State = void(StateController::*)();                                       // ukazatel na stavovou funkci
State state;                                                                    // stav automatu
state = &amp;StateController::DoSearchLine;                                         // změna stavu
(this-&gt;*state)();                                                               // vyvolání stavové funkce
</code></pre>
<p>Pokud však bude obsluha ve více objektech, je nutné použít lambda funkcí a std::function</p>
<pre><code class="language-c++">using State = void();                                                           // ukazatel na stavovou funkci
std::function&lt;State&gt; state;                                                     // stav automatu
state = [=](){ regulator-&gt;DoSearchLine(); }                                     // změna stavu
(*state)();                                                                     // vyvolání stavové funkce
</code></pre>
<p>Doporučuji první způsob.</p>
<h3 id="Řešení-funkcionálním-přístupem-s-pomocí-metod-aktuálního-objektu"><a class="header" href="#Řešení-funkcionálním-přístupem-s-pomocí-metod-aktuálního-objektu">Řešení funkcionálním přístupem s pomocí metod aktuálního objektu</a></h3>
<p>Deklarace Controlleru</p>
<pre><code class="language-c++">class StateController {
  using State = void(StateController::*)();                                     // MAGIE: ukazatel na metodu controlleru
public:
  State state{&amp;StateController::DoSearchLine}                                   // Robot po startu zacne hledat caru, prvni stav
  
  void Control();                                                               // funkce která bude volána z main
  
  // jednotlive stavove &quot;funkce&quot;
  void DoSearchLine();
  void DoFollowLine();
  void DoTryFollowMissingLine();
  void DoDanceOnFloor();
  void DoBurnEverything();
  // ...
}
</code></pre>
<p>Příklad implementací jednotlivých stavů automatu:</p>
<pre><code class="language-c++">void StateController::Control()
{
  (this-&gt;*state)();                                                             // MAGIE: provede volání aktuálně vybrané funkce
}

// Robot hleda caru
void StateController::DoSearchLine() 
{
  if (!sensor.LineMissing)
    state = &amp;StateController::DoFollowLine;
}  

// robot reguluje pozici na care
void StateController::DoFollowLine()
{
    drive.Regulate(ForwardSpeed, sensor.ComputedDistanceFromLine);
    
    if (sensor.LineMissing)
      state = &amp;StateController::DoTryFollowMissingLine;
}

// robot se pokousi znovu nalezt prerusenou caru
void StateController::DoTryFollowMissingLine()
{
    if (!sensor.LineMissing)
       state = &amp;StateController::DoTryFollowMissingLine;
}
</code></pre>
<p>A samozřejmě supersmyčka v main:</p>
<pre><code class="language-c++">StateController controller{&amp;drive, &amp;sensor};                                    // konstrukce controlleru nad daty

while(rum) {
    comm.send(sensor.BuildReads());
    comm.send(drive.BuildReads());
    
    while (ms &lt; millis())
      comm.loop();
      
    ms = millis() + T;
    
    sensor.ProcessLineSensors();
    drive.ComputeOdometry();
    
    controller.Control();                                                       // provede jeden krok aktualniho stavu
    
    drive.ComputeMotorRamps();        
    comm.send(sensor.BuildWrites());
    comm.send(drive.BuildWrites());
  }
</code></pre>
<h2 id="přístup-switch-case"><a class="header" href="#přístup-switch-case">Přístup switch-case</a></h2>
<p>Deklarace Controlleru</p>
<pre><code class="language-c++">enum State {
    SearchLine,
    FollowLine,
    TryFollowMissingLine,
    DanceOnFloor,
    DoBurnEverything,
  };                                                                            // Deklarace stavu
  
class StateController {
public:
  State state{SearchLine};                                                      // Robot po startu zacne hledat caru, prvni stav
  
  void Control();                                                               // funkce která bude volána z main
}
</code></pre>
<p>Příklad implementací jednotlivých stavů automatu:</p>
<pre><code class="language-c++">void StateController::Control()
{
  switch (state) {
  default:
  case SearchLine:
    if (!sensor.LineMissing)
      state = FollowLine;
    break;  
    
  case FollowLine:
    drive.Regulate(ForwardSpeed, sensor.ComputedDistanceFromLine);
    
    if (sensor.LineMissing)
      state = TryFollowMissingLine;
    break;
      
  case TryFollowMissingLine:
    if (!sensor.LineMissing)
      state = FollowLine;
    break;
  }  
}
</code></pre>
<p><strong>Poznámka:</strong> V příkladech chybí deklarace lokálních proměnných objektu, příklady jsou uvedeny jen jako vzorové, pro pochopení funkce. Konkrétní implementaci si musíte vytvořit sami.</p>
<p>Chytrého nakopni, hloupého kopni, blbého zakopej 4 metry pod zem ...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="procházení-komunikačním-protokolem-isoosi"><a class="header" href="#procházení-komunikačním-protokolem-isoosi">Procházení komunikačním protokolem ISO/OSI</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="doporučená-organizace-projektu"><a class="header" href="#doporučená-organizace-projektu">Doporučená organizace projektu</a></h1>
<p>Rozdělení do tříd (abecedně):</p>
<ul>
<li><code>Comm</code> - Obsluha kompletní komunikace</li>
<li><code>Configuration</code> - Konfigurace načtená z yaml souboru</li>
<li><code>Controller</code> - Hlavní logika ovládání programu</li>
<li><code>Drive</code> - Obsluha a řízení podvozku</li>
<li><code>Nmea</code> - Implementace převodu NMEA zpráv</li>
<li><code>Sensor</code> - Obsluha měření a identifikace čáry</li>
<li><code>main.cpp</code> - Supersmyčka</li>
</ul>
<p>Doporučen způsob práce kdy za funkcionalitu jedné třídy zodpovídá jedna osoba 
(ideálně se jménem napsaným v komentáři na začátku souboru). Nikdo jiný 
než vybraná osoba nesmí daný soubor commitovat.</p>
<p>Main je kolizní, můžou do něj všichni, ideálně v malých jednořádkových commitech. 
Main pokud možno modifikovat jen když jste všichni spolu a definujete API 
(rozdáváte práci)</p>
<h2 id="maincpp"><a class="header" href="#maincpp">main.cpp</a></h2>
<p>Řeší:</p>
<ul>
<li>obsluha argumentů příkazové řádky</li>
<li>instanciace ostatních tříd</li>
<li>hlavní supersmyčka</li>
</ul>
<p>Závisí na:</p>
<ul>
<li><code>Comm</code> - instanciace a obsluha v supersmy4ce</li>
<li><code>Drive</code> - instanciace a obsluha</li>
<li><code>Sensor</code> - instanciace a obsluha</li>
<li><code>Configuration</code> - instanciace, načtení</li>
<li><code>Controller</code> - instanciace a volání v supersmyčce</li>
</ul>
<p>POZOR KOLIZNÍ SOUBOR (commitovat vždy zvlášť, modifikovat pouze velmi malé změny kvůli častým konfliktům)</p>
<h2 id="nmea"><a class="header" href="#nmea">Nmea</a></h2>
<p>Řeší:</p>
<ul>
<li>převod z frame na zprávu</li>
<li>převod ze zprávy na frame</li>
</ul>
<p>Závisí na:</p>
<ul>
<li>nic</li>
</ul>
<p>Realizace:</p>
<ul>
<li>Implementace 4. týden</li>
<li>Spolehlivost 6. týden</li>
</ul>
<h2 id="comm"><a class="header" href="#comm">Comm</a></h2>
<p>Řeší:</p>
<ul>
<li>obsluha příjmu a odesílání UDP zpráv</li>
<li>Mediátor zpráv do ostatních objektů</li>
</ul>
<p>Závisí na</p>
<ul>
<li><code>Nmea</code> - převod protokolu</li>
<li><code>Configuration</code> VOLITELNE - port</li>
</ul>
<p>Realizace:</p>
<ul>
<li>Implementace 6. týden</li>
<li>Spolehlivost 8. týden</li>
</ul>
<h2 id="drive"><a class="header" href="#drive">Drive</a></h2>
<p>Řeší:</p>
<ul>
<li>Obsluha komunikace s podvozkem</li>
<li>Výpočty nad podvozkem</li>
<li>Odometrie</li>
</ul>
<p>Závisí na</p>
<ul>
<li><code>Nmea</code> - deklarace zpráv</li>
<li><code>Configuration</code> VOLITELNE - poloměr kola, rozteč</li>
</ul>
<p>Realizace:</p>
<ul>
<li>Implementace 6. týden</li>
<li>Spolehlivost 8. týden</li>
</ul>
<h2 id="sensor"><a class="header" href="#sensor">Sensor</a></h2>
<p>Řeší:</p>
<ul>
<li>Obsluha komunikace se senzory</li>
<li>Parametrizace /detekce pozice čáry</li>
</ul>
<p>Závisí na</p>
<ul>
<li><code>Nmea</code> - deklarace zpráv</li>
<li><code>Configuration</code> VOLITELNE - pozice senzoru</li>
</ul>
<p>Realizace:</p>
<ul>
<li>Implementace 7. týden</li>
<li>Spolehlivost 8. týden</li>
</ul>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<ul>
<li>Načítání parametrů z yaml souboru</li>
<li>Volitelná třída, lze implementovat za pomocí konstant v kódu</li>
<li>výhodné použití <code>yaml-cpp</code> knihovny</li>
</ul>
<p>Závisí na</p>
<p>nic</p>
<p>Realizace:</p>
<ul>
<li>Implementace 8. týden</li>
<li>Spolehlivost 10. týden</li>
</ul>
<h2 id="controller-1"><a class="header" href="#controller-1">Controller</a></h2>
<p>Řeší:</p>
<ul>
<li>Logika jízdy robotu</li>
<li>Stavový automat pro:
<ul>
<li>inicializace / kalibrace senzorů</li>
<li>jízda po čáře (regulátor)</li>
<li>jízda po přerušené čáře</li>
<li>jízda po křižovatce</li>
</ul>
</li>
</ul>
<p>Závisí na</p>
<ul>
<li><code>Drive</code> - zápis rychlostí robotu</li>
<li><code>Sensor</code> - čtení čáry</li>
<li><code>Configuration</code> VOLITELNE - délka přerušení</li>
</ul>
<p>Realizace:</p>
<ul>
<li>Implementace 8. týden</li>
<li>Spolehlivost 10. týden</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oddělení-modulů---zrychlení-kompilace"><a class="header" href="#oddělení-modulů---zrychlení-kompilace">Oddělení modulů - Zrychlení kompilace</a></h1>
<p>Při návrhu objektového API se setkáváme s nutností oddělení jednotlivých modulů tak, aby <strong>navzájem spolupracovaly</strong> 
(jeden modul využívá druhý), ale současně <strong>změna v impleentaci</strong> jednoho modulu nevyvolala <strong>nutnost rekompilace</strong> 
modulu druhého. Typickým příkladem je vazba <strong>nadřazený-podřazený</strong>, ale lze takto vytvořit i <strong>cyklickou závislost</strong></p>
<p>Velmi špatným řešením v aplikacích bývá vytvoření <strong>globální proměnné</strong>.</p>
<p>Řešení lze docílit měkkou vazbou přes <strong>ukazatel na nedefinovaný objekt</strong> (tzv forward).</p>
<p><strong>Příklad:</strong> Máme objekt <code>Controller</code>, který ve svých metodách potřebuje používat funkce z objektů <code>Drive</code> a <code>Sensor</code>.
Objekty <code>Drive</code> a <code>Sensor</code> jsou singletony (existují v aplikaci v právě jedné instanci, vytvořené nejspíše jako
lokální proměnné ve funkci <code>main</code>.</p>
<h2 id="forward"><a class="header" href="#forward">Forward</a></h2>
<p>Aby mohly jednotlivé metody <code>Controller</code>u pracovat s <code>Drive</code>, musí mít <code>Controller</code> v sobě uložený odkaz na instanci
objektu <code>Drive</code>. Nejspíše takto:</p>
<pre><code class="language-c++">#include &quot;Drive.h&quot;

class Controller {
public:
  Drive *drv;
}
</code></pre>
<p>Pokud však s třídou <code>Drive</code> pracuje pouze implementace <code>Controlleru</code>, kompilátor potřebuje pouze vědět, že
<code>Drive</code> je třída (a nic víc!) a není tak potřeba vkládat celý soubor s definicí <code>API</code> třídy <code>Drive</code>. Lze toto
zjednodušit na:</p>
<pre><code class="language-c++">class Drive;    // pouze forward

class Controller {
public:
  Drive *drv;
}
</code></pre>
<p>a soubor s deklarací Drive vkládáme až do cpp souboru</p>
<pre><code class="language-c++">#include &quot;Controller.h&quot;
#include &quot;Drive.h&quot;

Controller:: ......
</code></pre>
<p>Toto lze použít při splnění podmínek:</p>
<ul>
<li>Všechny přístupy ke třídě <code>Drive</code> jsou přes ukazatel, nikoliv přímo 
<ul>
<li>instance objektu potřebuje znát velikost tedy plnou deklaraci !</li>
</ul>
</li>
<li>k obsahu <code>drv</code> se nepřistupuje v headeru ale v kódu cpp.
<ul>
<li>Jakékoliv inline funkce používající obsah drv potřebují znát plnou deklaraci !</li>
</ul>
</li>
</ul>
<h2 id="neměnný-ukazatel"><a class="header" href="#neměnný-ukazatel">Neměnný ukazatel</a></h2>
<p>Dále <code>drive</code> by měl být konstantní ukazatel na nekonstantní instanci třídy <code>Drive</code>. Ukazatel nechceme nikdy měnit, ale
vlastní objekt měnit můžeme. S tím kam umístíme <code>const</code> bývá začátečnický problém, pro shrnutí: </p>
<pre><code class="language-c++">Drive *drv;               // ukazatel na Drive. Lze změnit ukazatel i Data na které ukazuje.
const Drive *drv;         // ukazatel na konstantní Drive. Lze změnit ukazatel, Data na které ukazuje lze pouze číst.
Drive * const drv;        // konstantní ukazatel na Drive. Lze změnit data, na které ukazuje. Ukazatel lze pouze číst.
const Drive * const drv;  // konstantní ukazatel na konstantní Drive. Data i ukazatel lze pouze číst.
</code></pre>
<p>Dále nechceme, aby do ukazatele v inicializaci instance <code>Controller</code>u někdo vložil <code>nullptr</code> (nedává to v API smysl, 
bez instance <code>Drive</code> neumí <code>Controller</code> žít). Navíc nechceme použít <strong>pointerovou aritmetiku</strong> (z principu se jí 
vyhýbáme, kde to jde). Místo konstantního ukazatele <code>Drive * const ptr</code> použijeme referenci <code>Drive &amp; ptr</code>. 
Pozor reference je vždy konstantní, takže nám jedno <code>const</code> odpadá ! </p>
<pre><code class="language-c++">Drive &amp; drv;              // reference na Drive. Lze změnit Data na které ukazuje. Ukazatel ne.
</code></pre>
<h2 id="vzorové-řešení"><a class="header" href="#vzorové-řešení">Vzorové řešení</a></h2>
<p>Objekt <code>Controller</code> tedy deklarujeme v headeru takto: </p>
<pre><code class="language-c++">class Drive;    // pouze forward

class Controller {
public:
  Controller(Drive &amp; aDrive); 
  
  void Method();
  
private:
  Drive &amp; drv;
}
</code></pre>
<p>A implementujeme v cpp souboru takto:</p>
<pre><code class="language-c++">#include &quot;Controller.h&quot;
#include &quot;Drive.h&quot;          // metody controlleru už smí používat API Drive

Controller::Controller(Drive &amp; aDrive)
 : drv{aDrive}
{
} 

void Controller::Method()
{
  drv-&gt;CallMe();            // Můžeme používat API
}
</code></pre>
<h2 id="cyklická-závislost"><a class="header" href="#cyklická-závislost">Cyklická závislost</a></h2>
<p>Stejným způsobem lze definovat, že <code>Drive</code> může přistupovat k prvkům <code>Controlleru</code>. Standardním způsobem deklarace 
bysme vytvořili cyklickou závislost mezi headery a kód by (logicky) nešel zkompilovat:</p>
<p>Drive.h:</p>
<pre><code class="language-c++">#include &quot;Controller.h&quot;

class Drive {
 Controller &amp; ctrl;
}
</code></pre>
<p>Controller.h:</p>
<pre><code class="language-c++">#include &quot;Drive.h&quot;

class Controller {
 Drive &amp; drv;
}
</code></pre>
<p><strong>Řešení</strong> cyklické závislosti bylo již uvedeno:</p>
<pre><code class="language-c++">class Controller;

class Drive {
 Controller &amp; ctrl;
}
</code></pre>
<p>Controller.h:</p>
<pre><code class="language-c++">class Drive;

class Controller {
 Drive &amp; drv;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
