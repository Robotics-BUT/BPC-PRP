<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>BPC-PRP</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Uvod</a></li><li class="chapter-item expanded affix "><a href="prednasky.html">Přednášky</a></li><li class="chapter-item expanded affix "><a href="cviceni.html">Cvičení</a></li><li class="chapter-item expanded "><a href="chap_1_software/text/intro.html"><strong aria-hidden="true">1.</strong> Softwarové vybavení</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chap_1_software/text/linux.html"><strong aria-hidden="true">1.1.</strong> Linux a příkazová řádka</a></li><li class="chapter-item expanded "><a href="chap_1_software/text/git.html"><strong aria-hidden="true">1.2.</strong> Git - Verzovací systému</a></li><li class="chapter-item expanded "><a href="chap_1_software/text/clion.html"><strong aria-hidden="true">1.3.</strong> CLion IDE</a></li><li class="chapter-item expanded "><a href="chap_1_software/text/ros.html"><strong aria-hidden="true">1.4.</strong> Robotic Operating System</a></li><li class="chapter-item expanded "><a href="chap_1_software/text/vb.linux_installation.html"><strong aria-hidden="true">1.5.</strong> Příprava prostředí</a></li></ol></li><li class="chapter-item expanded "><a href="cviceni/cviceni_uvod.html"><strong aria-hidden="true">2.</strong> Cviceni</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cviceni/cviceni_02_linux.html"><strong aria-hidden="true">2.1.</strong> Instalace a seznámení se s prostředím</a></li><li class="chapter-item expanded "><a href="cviceni/cviceni_03_git.html"><strong aria-hidden="true">2.2.</strong> GIT, simulátor</a></li><li class="chapter-item expanded "><a href="cviceni/cviceni_04_udp.html"><strong aria-hidden="true">2.3.</strong> UDP komunikace</a></li><li class="chapter-item expanded "><a href="cviceni/cviceni_06_motory.html"><strong aria-hidden="true">2.4.</strong> Řízení motorů</a></li><li class="chapter-item expanded "><a href="cviceni/cviceni_07_snimac_cary.html"><strong aria-hidden="true">2.5.</strong> Snímání čáry</a></li><li class="chapter-item expanded "><a href="cviceni/cviceni_09_regulator.html"><strong aria-hidden="true">2.6.</strong> Návrh regulátoru</a></li><li class="chapter-item expanded "><a href="cviceni/cviceni_10_telemetrie_vizualizace.html"><strong aria-hidden="true">2.7.</strong> Telemetrie a vizualizace</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">BPC-PRP</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#prakticka-robotika-a-pocitacove-videni-bpc-prp-online-skripta" id="prakticka-robotika-a-pocitacove-videni-bpc-prp-online-skripta">Prakticka robotika a pocitacove videni (BPC-PRP) online skripta</a></h1>
<p>Tento text predstavuje online skripta a studijni materialy pro prednasky a cviceni predmetu BPC-PRP - povinneho premetu 3. rocniku bakalarskeho studiniho oboru Automatizacni a merici technika na Fakulte elektrotechniky a komunikacnich technologii Vysokeho Uceni Technickeho v Brne.</p>
<p>Skripta rovnez obsahuji texty tykajici se dalsich oblasti robotiky, ktere jiz ale nejsou vyzadovany samotnou naplni predmetu.</p>
<h2><a class="header" href="#autori" id="autori">Autori</a></h2>
<p>Bc. Matous Hybl</p>
<p>Ing. Adam Ligocki</p>
<p>Ing. Tomas Lazna</p>
<p>Ing. Petr Gabrlik</p>
<p>Ing. Tomas Jilek, Ph.D.</p>
<p>Ing. Frantisek Burian, Ph.D.</p>
<h2><a class="header" href="#seznam-přednášek" id="seznam-přednášek">Seznam přednášek</a></h2>
<h3><a class="header" href="#1-Úvodní-přednáška" id="1-Úvodní-přednáška">1. Úvodní přednáška</a></h3>
<pre><code>Přednášející: Ing Petr Gábrlík
Datum: 8.2.
</code></pre>
<h3><a class="header" href="#2-linux-shell-virtual-box-clion" id="2-linux-shell-virtual-box-clion">2. Linux, shell, virtual box, CLion</a></h3>
<pre><code>Základy principy OS Linux
Práce v příkazové řádce
Virtuální stroj
Možné způsoby vývoje aplikací na Linuxu
CLion vývojové prostředí (IDE)

Přednášející: Ing. Adam Ligocki
Datum: 15. 2. 2020
</code></pre>
<h3><a class="header" href="#3-git-integrace-gitu-v-ide" id="3-git-integrace-gitu-v-ide">3. GIT, integrace GITu v IDE</a></h3>
<pre><code>Úvod do verzovacího systému GIT
Ovládání GITu z příkazové řádky
Decentralizace dat v GIT repozitáři
Příklad práce více vývojářů na jednom repozitáři
Integrace GITu v IDE CLIon a další GUI

Přednášející: Ing. Adam Ligocki
Datum: 22. 2. 2020
</code></pre>
<h3><a class="header" href="#4-tcp-udpip-komunikace" id="4-tcp-udpip-komunikace">4. TCP-UDP/IP komunikace</a></h3>
<pre><code>Základy práce v GIT repozitáři
ISO/OSI a TCP/IP model
Síťové standardy IEEE 802.3, 802.11
Síťové protokoly - IPv4, UDP, TCP
Konfigurace sítě v Linuxu
Nástroje dostupné z příkazové řádky
Analýza síťové komunikace
Popis rozhraní socket API
Síťová komunikace z C/C++ aplikace

Přednášející: Ing. Tomáš Jílek, Ph.D.
Datum: 1. 3. 2020
</code></pre>
<h3><a class="header" href="#5-výkonová-elektronika-pohony" id="5-výkonová-elektronika-pohony">5. Výkonová elektronika, pohony</a></h3>
<pre><code>DC motor, BLDC motor, Krokový motor, synchronní motor.
Charakteristiky a odlišnosti konstrukcí motorů
Mikrostepping u krokového motoru

Přednášející: Ing. Lukáš Kopečný, Ph.D.
Datum: 8. 3. 2020
</code></pre>
<h3><a class="header" href="#6-snímání-vodicí-čáry" id="6-snímání-vodicí-čáry">6. Snímání vodicí čáry</a></h3>
<pre><code>Koncepce a blokové schéma implementace celého projektu
Optické snímání čáry pomocí optočlenů CNY70
A/D převod
A/D převodník AD7997
Zpracování měřených dat

Přednášející: Ing. Tomáš Jílek, Ph.D.
Datum: 15. 3. 2020
</code></pre>
<h3><a class="header" href="#7-kinematika-a-regulace-pohybu-podvozku-robotu" id="7-kinematika-a-regulace-pohybu-podvozku-robotu">7. Kinematika a regulace pohybu podvozku robotu</a></h3>
<pre><code>Přímá a inverzní kinematická úloha pro diferenciálně řízený podvozek
Regulace pohybu podvozku

Přednášející: Ing. Tomáš Jílek, Ph.D.
Datum: 22. 3. 2020
</code></pre>
<h3><a class="header" href="#8-popis-závěrečné-soutěže-příklady-možných-způsobů-řešení" id="8-popis-závěrečné-soutěže-příklady-možných-způsobů-řešení">8. Popis závěrečné soutěže, příklady možných způsobů řešení</a></h3>
<pre><code>Pravidla soutěže
Návrh možných způsobů řešení soutěže
ÚČAST POVINNÁ

Přednášející: Ing. Petr Gábrlík
Datum: 29. 3. 2020
</code></pre>
<h3><a class="header" href="#9-velikonoční-pondělí" id="9-velikonoční-pondělí">9. Velikonoční pondělí</a></h3>
<pre><code>Přednášející: - 
Datum: 19. 4. 2020
</code></pre>
<h3><a class="header" href="#10-robotic-operating-system-ros-rviz-vizualizace-v-robotice" id="10-robotic-operating-system-ros-rviz-vizualizace-v-robotice">10. Robotic Operating System ROS, Rviz, vizualizace v robotice</a></h3>
<pre><code>Úvod do platformy ROS
Principy fungování
Využití rozhraní ROS
Vizualizace (RViz)

Přednášející: Ing. Adam Ligocki
Datum: 12. 4. 2020
</code></pre>
<h3><a class="header" href="#11-embedded-systémy-v-robotice" id="11-embedded-systémy-v-robotice">11. Embedded systémy v robotice</a></h3>
<pre><code>TODO:

Přednášející: Bc. Matouš Hýbl
Datum: 19. 4. 2020
</code></pre>
<h3><a class="header" href="#12-samostatná-práce-na-projektu" id="12-samostatná-práce-na-projektu">12. Samostatná práce na projektu</a></h3>
<pre><code>Přednášející: -
Datum: 26.4.
</code></pre>
<h2><a class="header" href="#seznam-cvičení" id="seznam-cvičení">Seznam cvičení</a></h2>
<h3><a class="header" href="#1-osnova-projektu-bezpečnost-v-rámci-přednášky-cvičení-se-nekoná" id="1-osnova-projektu-bezpečnost-v-rámci-přednášky-cvičení-se-nekoná">1. Osnova projektu, bezpečnost (v rámci přednášky, cvičení se nekoná)</a></h3>
<p>Vyučující: Tomáš Jílek</p>
<h3><a class="header" href="#2-instalace-virtual-boxu-linuxu-clionu" id="2-instalace-virtual-boxu-linuxu-clionu">2. Instalace Virtual Boxu, Linuxu, CLionu</a></h3>
<p>Vyučující: Adam Ligocki</p>
<h3><a class="header" href="#3-práce-s-gitem-zprovoznění-simulátoru" id="3-práce-s-gitem-zprovoznění-simulátoru">3. Práce s GITem, zprovoznění simulátoru</a></h3>
<p>Vyučující: Adam Ligocki</p>
<h3><a class="header" href="#4-udp-komunikace-se-simulátorem-nemea-protokol" id="4-udp-komunikace-se-simulátorem-nemea-protokol">4. UDP komunikace se simulátorem, NEMEA protokol</a></h3>
<p>Vyučující: Tomáš Lázna</p>
<h3><a class="header" href="#5-konzultační-týden-samostatná-práce" id="5-konzultační-týden-samostatná-práce">5. Konzultační týden (samostatná práce)</a></h3>
<p>Vyučující: osobní konzultace s příslušným vyučujícím po předchozí domluvě</p>
<h3><a class="header" href="#6-ovládání-motorů-simulovaného-robota" id="6-ovládání-motorů-simulovaného-robota">6. Ovládání motorů simulovaného robota</a></h3>
<p>Odpovědnost: Matouš Hýbl</p>
<h3><a class="header" href="#7-snímání-čáry-v-simulátoru" id="7-snímání-čáry-v-simulátoru">7. Snímání čáry v simulátoru</a></h3>
<p>Vyučující: Tomáš Jílek</p>
<h3><a class="header" href="#8-konzultační-týden-samostatná-práce" id="8-konzultační-týden-samostatná-práce">8. Konzultační týden (samostatná práce)</a></h3>
<p>Vyučující: osobní konzultace s příslušným vyučujícím po předchozí domluvě</p>
<h3><a class="header" href="#9-návrh-regulátoru-pro-sledování-čáry" id="9-návrh-regulátoru-pro-sledování-čáry">9. Návrh regulátoru pro sledování čáry</a></h3>
<p>Vyučující: Tomáš Jílek</p>
<h3><a class="header" href="#10-telemetrie-a-vizualizace" id="10-telemetrie-a-vizualizace">10. Telemetrie a vizualizace</a></h3>
<p>Vyučující: Adam Ligocki</p>
<h3><a class="header" href="#11-samostatná-práce-na-projektu-samostatná-práce" id="11-samostatná-práce-na-projektu-samostatná-práce">11. Samostatná práce na projektu (samostatná práce)</a></h3>
<p>Vyučující: osobní konzultace s příslušným vyučujícím po předchozí domluvě</p>
<h3><a class="header" href="#12-samostatná-práce-na-projektu-samostatná-práce" id="12-samostatná-práce-na-projektu-samostatná-práce">12. Samostatná práce na projektu (samostatná práce)</a></h3>
<p>Vyučující: osobní konzultace s příslušným vyučujícím po předchozí domluvě</p>
<p>Kapitola &quot;Softwarové vybavení&quot; má za úkol seznámit Vás se základy práce s operačním systémem Linux, ovládání verzovacího systému Git, použití vývojového prostředí CLion, dále dát Vám povědomí o ROS (Robotic Operating System) a jako poslední, ale nejdůležitěnjí, provést Vás přípravou prostředí, ve kterém budete řešit projekt v rámci předmětu BPC-PRP.</p>
<h3><a class="header" href="#podkapitoly" id="podkapitoly">Podkapitoly:</a></h3>
<ul>
<li><a href="chap_1_software/text/linux.html">Orientace v Linuxu</a></li>
<li><a href="chap_1_software/text/git.html">Úvod do Gitu</a></li>
<li><a href="chap_1_software/text/clion.html">CLion IDE</a></li>
<li><a href="chap_1_software/text/ros.html">Robotic Operating System</a></li>
<li><a href="chap_1_software/text/vb.linux_installation.html">Příprava prostředí</a></li>
</ul>
<h1><a class="header" href="#linux-a-příkazová-řádka-terminál" id="linux-a-příkazová-řádka-terminál">Linux a příkazová řádka (terminál)</a></h1>
<p>Tuto kapitolu berte jako rozcestník pro práci v operačním systému Linux.</p>
<p>Není potřeba znát všechny příkazy, včetně jejich parametrů z paměti, avšak měli by jste mít o nich povědomí a případně na internetu, či v Linux manuále být schopni dohledat jejich přesný způsob použití.</p>
<h2><a class="header" href="#přehled-příkazů-v-terminále" id="přehled-příkazů-v-terminále">Přehled příkazů v terminále</a></h2>
<h3><a class="header" href="#příkaz" id="příkaz">příkaz</a></h3>
<p>vysvětlení funkce</p>
<pre><code>příklad použití      ...      vysvětlení
</code></pre>
<h3><a class="header" href="#ls---list" id="ls---list">ls - (list)</a></h3>
<p>Vypiš všechny soubory a složky (složka je taky typ souboru) v aktuálním bodě file systému.</p>
<pre><code>ls
ls -la      ...      vypíše všechny soubory, včetně sktytých a přidá k výpisu detailní informace
</code></pre>
<h3><a class="header" href="#cd---change-directory" id="cd---change-directory">cd - (change directory)</a></h3>
<p>Změna složky.</p>
<pre><code>cd my_directory      ...      přesun do adresáře s názvem my_directory
cd ~                 ...      návrat do domovské složky (v linuxu nazýváme &quot;home&quot;)
cd ..                ...      návrat o adresář výš (dvojtečka)
cd /                 ...      návrat do kořene file systému (v linuxu nazýváme &quot;root&quot;)
cd ../my_folder      ...      vrať se o adresář výš a pak se přesuň do adresáře &quot;my_folder&quot;
cd .                 ...      přesuň se do &quot;současného adresáře&quot;. V podstatě nic neudělá. Příklad ilustruje existenci symbolu pro aktuální adresář (tečka).
</code></pre>
<h3><a class="header" href="#pwd---print-working-directory" id="pwd---print-working-directory">pwd - print working directory</a></h3>
<p>Vypíše aktuální pozici ve file systému.</p>
<pre><code>pwd
</code></pre>
<h3><a class="header" href="#mkdir---make-directory" id="mkdir---make-directory">mkdir - (make directory)</a></h3>
<p>Vytvoření nového adresáře.</p>
<pre><code>mkdir my_folder      ...      vytvoří nový adresář s názvem &quot;my_folder&quot;
</code></pre>
<h3><a class="header" href="#cp---copy" id="cp---copy">cp - (copy)</a></h3>
<p>Kopíruje soubor.</p>
<pre><code>cp zdrojovy_soubor cilovy_soubor                    ...      vytvoří novou kopii zdrojovy_soubor nazvanou cilovy_soubor
cp ../secter.txt secret_folder/supersecret.txt      ...      vem soubor secret.txt, který se nachází o složku výš a zkopíruj ji do složky secret_folder. Kopie původního souboru se bude jmenovat &quot;supersecret.txt&quot;     
</code></pre>
<h3><a class="header" href="#mv---move" id="mv---move">mv - (move)</a></h3>
<p>Příkaz původně pro přesun souboru, hlavně se však využívá pro přejmenováni soborů.</p>
<pre><code>mv old_name.txt new_name.html      ...      přejmenuje soubor &quot;old%name.txt&quot; na &quot;new_name.html&quot;
</code></pre>
<h3><a class="header" href="#rm---remove" id="rm---remove">rm - (remove)</a></h3>
<p>Smaže soubor/složku.</p>
<pre><code>rm old_file.txt      ...      vymaže soubor &quot;old_file.txt&quot;
rm -r my_folder      ...      smaže složku. Při mazání složky vždy musíme použít modifikátor rekurze (-r). Ten říká, že se má rekurzivně smazat také obsah složky.
</code></pre>
<h3><a class="header" href="#chmod---change-mode" id="chmod---change-mode">chmod - (change mode)</a></h3>
<p>Změní přístupová práva k souboru.</p>
<pre><code>chmod 777 /dev/ttyUSB0      ...      umožní všem uživatelům PC přístup na USB port s pořadovým číslem 0. Pro detail fungováni přístupových práv ve file systému viz [7].
</code></pre>
<h3><a class="header" href="#sudo" id="sudo">sudo</a></h3>
<p>Meta příkaz. Operace provedená v rámci tohoto příkazu bude provedena v režimu oprávnění administrátora operačního systému. Obvykle používáme, když zasahujeme do systémových souborů.</p>
<pre><code>sudo mkdir /etc/config      ...      vytvoří složku &quot;config&quot; v systémovém adresáři &quot;/etc&quot;.
sudo rm -r /                ...      příkaz rekurzivně smaže celý adresář &quot;root&quot; (v podstatě smaže celý disk včetně OS)
</code></pre>
<h3><a class="header" href="#cat---concatenate-files-to-standard-output" id="cat---concatenate-files-to-standard-output">cat - (Concatenate FILE(s) to standard output)</a></h3>
<p>Program vypíše do termínálu obsah souboru.</p>
<pre><code>cat ~/my_config_file.txt      ...      vytiskne v terminále obsah zvoleného souboru
</code></pre>
<h3><a class="header" href="#man---manual-referenční-manuál-operačního-systému" id="man---manual-referenční-manuál-operačního-systému">man - (manual) referenční manuál operačního systému</a></h3>
<p>Rychlá pomoc když zapomenu, jak pracovat s daným programem</p>
<pre><code>man ls      ...      vytiskne v terminále manuál k programu ls
</code></pre>
<h3><a class="header" href="#distribuce-linuxu" id="distribuce-linuxu">Distribuce Linuxu</a></h3>
<p>Hovoříme-li o Linuxu, máme na mysli jádro operačního systému, které je zpravováno autoritou (tvůrce linuxu Linus Torvards) a ta zajišťuje integritu veškerého kódu, který je do jádra OS zaintegrován.</p>
<p>Nad jádrem operačního systému je však nádstavka balíčkovacích systémů, grafického rozhraní, a dalšího podpůrného software. Distribucí se v Linuxu rozumí balíček těchto podpůrných software, který je dodáván a garantován konkrétní právnickou osobou (komerční subjekt, organizace, atd.).</p>
<p>Často používané distribude:</p>
<p>Debian - nejrošířenější distribuce Linuxu.</p>
<p>Ubuntu - derivát Debianu. Nejrozšířenějí distribuce na domácích stanicích.</p>
<p>Mint - derivát Ubuntu. GUI se blíží Windows.</p>
<p>RaspberryOS (dříve Raspbian) - derivát Debianu pro Raspberry Pi</p>
<p>Arch Linux - Distribuce orienovaná na profi uživatele - velká volnost při konfiguraci systému</p>
<p>Fedora - Alternativa k Debianu.</p>
<p>ElementaryOS - Minimalistická a rychlá distribuce. Vhodná pro slabé počítače.</p>
<p>... mnoho dalších</p>
<h2><a class="header" href="#orientace-v-systému" id="orientace-v-systému">Orientace v systému</a></h2>
<p>Souborová struktura Linuxu se odvozuje od tzv. kořene (root), který značíme jako / (vzdáleny ekvivalent C:/ na Windows).</p>
<p>V kořenovém adresáři pak nalezneme složky jako:</p>
<ul>
<li>bin/ - obsahuje binárky (spustitelné soubory operačního systému).</li>
<li>home/ - adresář, který obsahuje domovské složky uživatelů.</li>
<li>dev/ - obsahuje soubory které mapují fyzické interfacy počítače (interní a externí disky, sériovou linku, usb, síťové rozhraní, atd.).</li>
<li>tmp/ - temporary složka. Zde si programy odkládají svá dočasná data.</li>
<li>media/ - místo kde se mountují (připojují) externí disky.</li>
<li>etc/ - složka obsahuje klíčové systémové soubory.</li>
</ul>
<p>Po příhlášení se obvykle nacházíte v domovském adresáři, tj na místě /home/&lt;jmeno_uzivatele&gt;/</p>
<h2><a class="header" href="#základní-programy" id="základní-programy">Základní programy</a></h2>
<h3><a class="header" href="#apt" id="apt">apt</a></h3>
<p>Jedná se o Balíčkovací systém Debianu. Na Linuxu nejčastěji instalumeme programy tak, že si jej stáhneme z veřejného repozitáře, tedy obvykle ověřeného a bezpečného serveru.</p>
<p>Při instalaci musíme vždy disponovat administrátorskými právy.</p>
<p>Příklad instalace Gitu:</p>
<pre><code>sudo apt update
sudo apt install git
</code></pre>
<p>Říkáme: &quot;s administrátorskými právy zavolej program apt a aktualizuj si záznamy o repozitářích&quot;, a &quot;s administrátorskými právy zavolej program apt a ten neinstaluje git&quot;.</p>
<h3><a class="header" href="#nano" id="nano">nano</a></h3>
<p>Editace textu podobná poznámkovému bloku</p>
<p>Ctrl + X - ukončení programu. Program se zeptá, zda má uložit změny</p>
<h3><a class="header" href="#vim" id="vim">vim</a></h3>
<p>Profi editace textu. Ovládání programu je však poněkud složitější a vyžaduje pochopení několika principů. Práce s vim je však mnohonásobně rychlejší než s nano. Před použitím doporučuji projít libovolny &quot;vim noob tutoriál&quot; na youtube.</p>
<p>Kdyby se Vám přeci jen povedlo vim zapnout, vězte že jej vypnete kobinací kláves Shift + Z + Z (držíme shift a dvakrát zmáčkneme klávesu 'Z').</p>
<h3><a class="header" href="#mc" id="mc">mc</a></h3>
<p>Midnight Commander - grafické prostředí pro pohyb v souborovém systému. Připomíná MS Dos.</p>
<p>Vypíná se klávesou F10.</p>
<h3><a class="header" href="#curl" id="curl">curl</a></h3>
<p>Nástroj přikazového řádku pro přenos dat mnoha protokoly. Curl je často používán pro http komunikaci, instalaci programu, či stahování souborů.</p>
<h3><a class="header" href="#wget" id="wget">wget</a></h3>
<p>Program pro stahování souborů ze sítě.</p>
<p>Příklad stažení posledního releasu wordpresu:</p>
<pre><code>wget https://wordpress.org/latest.zip
</code></pre>
<h3><a class="header" href="#slovo-na-závěre" id="slovo-na-závěre">Slovo na závěre</a></h3>
<p>Pokud jste v Linuxu nováčky, hlavně se nebote experimentovat. Ideálně si nainstalulte systém do Virtual Boxu a udělejte si zálohu virtuálního disku. Když se Vás podaří systém rozhasit, stačí si natánout backup a jedete dál.</p>
<h1><a class="header" href="#git---verzovací-systému" id="git---verzovací-systému">Git - Verzovací systému</a></h1>
<p>Git je distribuovaný systém pro verzováni a management zálohování zdrojových kódů. Obecně ale Git funguje dobře pro verzování libovolného textu. Primární motivací k výuce Gitu v rámci tohoto předmětu je fakt, že Git je dnes nejrozšířenějí verzovací systém v konerční svéře a zároveň je na webu dostupná obrovská paleta Git-based online verzovacích služeb.</p>
<h2><a class="header" href="#základní-terminologie" id="základní-terminologie">Základní terminologie</a></h2>
<p>Vymezme si několik základních pojmů, abychom si rozuměli.</p>
<h3><a class="header" href="#repozitář-repo" id="repozitář-repo">repozitář (repo)</a></h3>
<p>Sada verzovaných souborů a záznamy o jejich historii. Pokud je repozitář uložen na našem počítači, nazýváme jej lokální repozitář (local repo). Jeli uložen na jiném stroji, hovoříme o vzdáleném repozitáři (remote repo).</p>
<h3><a class="header" href="#klonování-cloning" id="klonování-cloning">klonování (cloning)</a></h3>
<p>Stažení repozitáře z remote repa. Klonujeme v okamžiku, kdy na lokálním počítači repozitář neexistuje.</p>
<h3><a class="header" href="#snapshot" id="snapshot">snapshot</a></h3>
<p>Stav repozitáře v konkrétním bodě v historii.</p>
<h3><a class="header" href="#diff" id="diff">diff</a></h3>
<p>Rozdíl mezi dvěmi snapshoty. Tedy rozdíl stavu verzovaných souborů.</p>
<h3><a class="header" href="#commit" id="commit">commit</a></h3>
<p>Záznam, který obsahuje referenci na předchozí, následujicí snapshot a diff mezi nimi. Zároveň každý commit má svůj unikátní dvaceti bytový hash, který jej jednoznačně identifikuje v rámci repozitáře.</p>
<h3><a class="header" href="#push" id="push">push</a></h3>
<p>Nahrání nových comitů na remote repo.</p>
<h3><a class="header" href="#fetch" id="fetch">fetch</a></h3>
<p>Stažení commitů z remote repo na lokál. Fetchujeme, pokud na lokále máme repozitář naklonovaný, ale nemáme stažené nejnovější commity.</p>
<h3><a class="header" href="#větev-branch" id="větev-branch">větev (branch)</a></h3>
<p>Řetězec na sebe navazujicích commitů. Ze základu má každý repozitáž jednu větev (&quot;master&quot;, někdy &quot;main&quot;). Probíha-li však vývoj několika funkcionalit vedle sebe, je možné tyto vývoje rozdělit do zvláštnich větví a připojit je spátky k hlavní větni, až je funkcionalita dokončená.</p>
<h2><a class="header" href="#princip-fungování" id="princip-fungování">Princip fungování</a></h2>
<p>Primární funkcí Gitu je verzování textových souborů. Jedním dechem je potřeba dodta, že Git NENÍ vhodny pro verzování binárních souborů. Vyvíjíme-li tedy program a verzujeme vývoj v Gitu, vždy verzujeme pouuze zdrojové kódy, nikdy ne zkompilované spustitelné soubory (binárky).</p>
<p>Zároveň Git umožňuje velmi efektivní spolupráci mnoha lidí na stejném projektu (repozitáři). Vývojáři mohou pracovat společně, případně každý na separátním branchi. Důležité pravidlo však je, že dva lidé nesmí přepsat stejný řádek kódu ve dvou různých commitech. To způsobi tzv. konflikt. Obecné doporučení je, aby dva lidé neměnili stejný soubor.</p>
<p>Ve srovnání s SVN je ale Git tzv. decentralizovaný systém. To znamená, že v systému repozitářů neexistuje žaden nadřazeny, důležitější repozitář, či něco ve smyslu centrálního serveru. Všechny repozitáře mají stejnou funkcionalitu a jsou schopny udržovat kompletní historii celého repozitáře a ponohodnotně komunikovat se všemi ostatními klony. Praxe je však taková, že obvykle existuje repozitář, který funguje jako centrální místo pro výměnu commitů mezi vývojáři. Takový repozitář se obvykle jmenuje &quot;origin&quot;. Důležité však je, že kterýkolik repozitář, si může z originu stáhnout kompletní historii a tak v případě selhání originu nedojde ke ztrátě dat, protože každý vývojář může mít jeho plnohodnotnou kopii na svém počítačí.</p>
<p>Obvykla práce s Gitem vypadá následovně:</p>
<ul>
<li>Na serveru vytvoříme repozitář projektu.</li>
<li>vývojáři si naklonujou repozitář na lokální počítače. Z jejich pohledu loklálních repozitářů je server tzv &quot;origin&quot;.</li>
<li>vývojáři na lokálních počítačích vytváří kód a commitujou.</li>
<li>na konci dne každý vývojáž pushne (nahraje) své denní commity na origin.</li>
<li>na druhý den ráno si každý fetchne (stáhne) commity kolegů z dne předchozího.</li>
</ul>
<h2><a class="header" href="#instalace-gitu-na-linuxu" id="instalace-gitu-na-linuxu">Instalace Gitu na Linuxu</a></h2>
<p>V případě, že pracujeme na distribuci Debian, Git nainstalujeme následovně:</p>
<pre><code>sudo apt install git
</code></pre>
<p>nebo</p>
<pre><code>sudo snap install git
</code></pre>
<h2><a class="header" href="#přehled-příkazů" id="přehled-příkazů">Přehled příkazů</a></h2>
<h3><a class="header" href="#git-init" id="git-init">git init</a></h3>
<p>Inicializace repozitře. Z obvyklé složky v souborovém systému vytvořím repozitář.</p>
<p>Repozitář se od obyčejné složky liší tím, že v sobě obsahuje skrytou složku s názvem .git a ta obsahuje historii repozitáře.</p>
<pre><code>git init     ...      inicializuje repozitář
</code></pre>
<h3><a class="header" href="#git-add" id="git-add">git add</a></h3>
<p>Příkaz přidává změny vytvořené od posledního commitu do tzv. indexu. Index je soubor změn, které budou součástí nejbližšího commitu. Díky mezistupni index je možné commitnout jen některé změny, které jsme od posledního commitu vytvořili.</p>
<pre><code>git add myfile.txt     ...      přidá do indexu změny provedené nad souborem myfile.txt
git add .              ...      přidá do indexu všechny aktuální změny
</code></pre>
<h3><a class="header" href="#git-commit" id="git-commit">git commit</a></h3>
<p>Vytvoř nový commit, který je odvozený od posledního commitu v současné větví, a zahrni do commitu změny (diffy), které jsou v indexu.</p>
<pre><code>git commit -m &quot;komentář k danému commitu&quot;     ...      vytvoří nový commit v rámci větve, ve které se nacházíme
</code></pre>
<h3><a class="header" href="#git-checkout" id="git-checkout">git checkout</a></h3>
<p>Příkaz slouží k přecházení mezi snapshoty.</p>
<pre><code>git checkout .          ...     vrať větev do stavu posledního commitu (zahoď všechny do té doby vytvořené změny)
git checkout abcdef     ...     přepni mě do stavu, který vznikl po commitu s hexadecimálním označením abcdef
git checkout master     ...     přepni mě do stavu posledního dostupného commitu na větvi master
</code></pre>
<h3><a class="header" href="#git-clone" id="git-clone">git clone</a></h3>
<p>Příkaz vytvoří klon vzdáleného repozitáře na lokále. Klonujeme-li, není potřeba inicializovat repozitář pomocí git init. Metadata repozitáře se stáhnou automaticky s obsahem.</p>
<pre><code>git clone https://adresa_vzdaleneho_repozitare.git     ...      vytvoří klon daného repozitáře na lokálním stroji
</code></pre>
<h3><a class="header" href="#git-remote" id="git-remote">git remote</a></h3>
<p>Příkaz vytvoří klon vzdáleného repozitáře na lokále. Klonujeme-li, není potřeba inicializovat repozitář pomocí git init. Metadata repozitáře se stáhnou automaticky s obsahem.</p>
<pre><code>git remote -v                                            ...      vypíše konfiguraci vzdálených repozitářů
git remote add origin https://adresa_repozitare.git      ...      přidá do lokálního repozitáře alias vzdáleného repozitáře s danou adresou
git remote remove origin                                 ...      smaže alias origin na vzdálený repozitář  
</code></pre>
<h3><a class="header" href="#git-push" id="git-push">git push</a></h3>
<p>Odešle nové commity vytvořené na lokále na vzdálený repozitář.</p>
<pre><code>git push origin master     ...     odešle na mastera nové commity vytvořené v rámci větvě (branche) master
</code></pre>
<h3><a class="header" href="#git-fetch" id="git-fetch">git fetch</a></h3>
<p>Stáhne z remotu commity do lokálního repozitáře. Stažené komity se ale nestanou součástí větve. Změny zůstanou pouze zapsány v paměti.</p>
<pre><code>git fetch origin           ...     stáhne nové commity ve všech větvích z originu na lokál
git fetch origin master    ...     stáhne nové commity pouze pro větev master z originu na lokál
</code></pre>
<h3><a class="header" href="#git-merge" id="git-merge">git merge</a></h3>
<p>Na aktuální větví vytvoří nový commit tak, že spojí naagregované diffy dvou různých větví. Tím pádem se v součacné větvi objeví všechny změny, které byly vytvořeny v jiné větví. Větve se tak spojí.</p>
<pre><code>git merge cool_branch        ...      na současné větví vytvoří nový commit, který obsahuje všechny změny větve cool_branch
</code></pre>
<h3><a class="header" href="#git-pull" id="git-pull">git pull</a></h3>
<p>Kombinace příkazů git fetch a git merge. Obvykle se používá při stažení změn ze serveru. Příkaz nejprve stáhne commity z vzdáleného repozítáře (provede fetch) a následně je připojí do současné větve (provede merge).</p>
<pre><code>git pull origin master        ...      stáhne z originu nové commity na větvi master a přidá je do lokální větve master
</code></pre>
<h3><a class="header" href="#git-diff" id="git-diff">git diff</a></h3>
<p>Vytiskne rozdíl stavu repozitáře mezi dvěma commity.</p>
<pre><code>git diff abcdef 012345        ...      vytiskne rozdíl mezi commity, které jsou identifikovány hexadecimálními hashy abcdef a 012345
</code></pre>
<h3><a class="header" href="#git-status" id="git-status">git status</a></h3>
<p>Zobrazí současný stav změn provedených od posledního commitu, včetně zobrazení změn, které jsou již přidány do indexu.</p>
<pre><code>git status        ...      vytiskne současný stav změn
</code></pre>
<h3><a class="header" href="#git-log" id="git-log">git log</a></h3>
<p>Vytiskne chronologicky výpis commitů spolu s jejich metadaty (časem vytvoření commitu, popiskem, identifikačním hashem, atd.)</p>
<pre><code>git log        ...      vytiskne historii současné větve
</code></pre>
<h3><a class="header" href="#git-stash" id="git-stash">git stash</a></h3>
<p>Slouží pro ukládání a načítání změn do zásobníku. Vhodné například, když si všimnete, že píšete kód na jiné větvi, než byl záměr. Pomocí git stash uložíte změny do zásobníku, přepnete se na jinou větev a změny si ze zásobníku vytáhnete.</p>
<pre><code>git stash        ...      Uloží změny provedené od posledního commitu do zásobníku a vrátí větev do stavu, v jakém byla po posledním commitu (jako by jste zdrojový kód nikdy nenapsali).
git stash pop      ...      Vytáhne změny uložené ze zásobníku a aplikuje je na současný stav (jako by jste kód právě ručně napsali).
</code></pre>
<h2><a class="header" href="#cvičení" id="cvičení">Cvičení</a></h2>
<p>Několik scénářů se kterými se můžete během vývoje software potkat. Vyzkoušejte si je opakovaně, aby jste si vryli do paměti způsob práce s Gitem. Zároveň doporučuji si příklady nejprvé projít v příkazové řádce, aby jste chápali zůpsob, jakým Git funguje na nejnižší vrstvě a následně si cvičení absolvovali i v grafickém rozhraní Vašecho vývojového prostředí.</p>
<h3><a class="header" href="#základní-obsluha" id="základní-obsluha">Základní obsluha</a></h3>
<ul>
<li>Vytvořte si repozitář.</li>
<li>Vytvořte v něm 2 textové soubory a do každého napište několik řádků.</li>
<li>Přídejte provedené změny do indexu a následně změny commitněte.</li>
<li>Nyní zeditujte jeden soubor a opět jej commitněte.</li>
<li>Zeditujte druhý soubor a změny commitněte.</li>
<li>Vytvořte si účet na <a href="https://github.com">GitHubu</a>, a založte si tam nový repozitář.</li>
<li>Přidejte vzdálený repozitář jako &quot;origin&quot; do lokálního repozitáře a pushněte změny na origin.</li>
<li>Ve vebovém prostředí ověřte obsah repozitáře.</li>
<li>Na jiním místě v počítači, nebo na jiném počítači si naklonujte právě pushnutý repozitář.</li>
<li>V novém klonu proveďte změnu a commitněte jí pushnete na origin.</li>
<li>V původní složce pullněte nové commity z originu.</li>
<li>Příkazem git log si prohlédněte historii.</li>
</ul>
<h3><a class="header" href="#konflikt" id="konflikt">Konflikt</a></h3>
<p>Příklad, co se stane, když dva vývojáří změní tentýž kód.</p>
<ul>
<li>Po vzoru předchozího cvičení si vytvořte na počítači, případně na dvou počítačích dvě kopie repozitáře, který bude mít společný origin na webu.</li>
<li>V prvním klonu upravte konkrétní řádek souboru, commitněte a pushněte.</li>
<li>V druhém klonu upravte tentýž řádek, commitněne a pushněte (push zahlásí chybu).</li>
<li>Nyní jsme si vyrobili konflikt. Ve stejném bodě v historii větve repozitáře proběhly dvě změny,které se navzájem vylučují (tzv. conflict).</li>
<li>Konflikt opravíme tak, že v druhém klonu, který nedokázal pushnout provedeme pull z originu.</li>
<li>Nyní nahlédněme do souboru, který obsahuje konflikt. Konflikt je označen speciální syntaxí &lt;&lt;&lt;&lt;&lt;&lt;&lt; lokalni_zmena ======= zmena_z_originu &gt;&gt;&gt;&gt;&gt;&gt;&gt;. Vyberte verzi, která je žádoucí a speciální syntaxi odstraňte. Tím je konflikt vyřešen.</li>
<li>Zavolejte příkaz git commit bez dalších parametrů a provede se commit s automatickým popiskem, že se jedná o řešení konflitku.</li>
<li>Pushněte nový commit na origin a poté pullněte jej v původním repozitáři.</li>
<li>Příkazem git log si prohlédněte historii.</li>
</ul>
<h2><a class="header" href="#doporučené-materiály" id="doporučené-materiály">Doporučené materiály</a></h2>
<p><a href="https://atlassian.com">Tutoriál Atlassianu</a></p>
<p><a href="https://git.com">Oficiální dokumentace Gitu</a></p>
<p><a href="https://ohshithit.com/cs">Užitečný rádce při potížích s Gitem (cs)</a></p>
<h1><a class="header" href="#remote-development-v-prostredi-clion" id="remote-development-v-prostredi-clion">Remote development v prostredi CLion</a></h1>
<p>Clion je integrované vývojové prostředí vyvíjené firmou JetBrains. Jedná se o zajímavou alternativu ke konvenčním prostředím jako je například Eclipse nebo NetBeans.
Oproti těmto uvedeným prostředím Clion vyčnívá zejména kvůli své rychlosti, přehlednosti a modernosti. 
Díky napojení na ekosystém firmy JetBrains je možné do studia doinstalovat spoustu rozšiřujících pluginů přinášejících podporu pro nové jazyky, vývojářské nástroje atp. 
Velkou výhodou může být i integrovaná práce s Gitem.</p>
<p>V tomto manuálu bude rozebráno použití prostředí Clion v předmětu BPC-PRP tedy jako nástroje pro vývoj firmware mobilního robotu založeného na platformě KAMBot. 
Nejprve bude stručně rozebrán build system CMake.
Poté se manuál již bude věnovat CLionu a to zejména jeho instalaci, vytvoření jednoduchého projektu typu Hello World a jeho zprovoznení. 
Dále je popsána stěžejní kapitola tohoto manuálu, a to vzdálený vývoj umožňující vzdálené programování Raspberry Pi pomocí standardního počítače. Na konci je popsán jednoduchý projekt blikání LEDkou a kapitola zabývající se odstraňováním nejčastějších problémů se vzdáleným vývojem.</p>
<p>Příklady v tomto manuálu byly zpracovány ve verzi Clion 2018.3, je tedy možné, že se v budoucnosti některé postupy budou měnit.</p>
<h2><a class="header" href="#build-system-cmake" id="build-system-cmake">Build system CMake</a></h2>
<p>CMake je soubor nástrojů, které zjednodušují kompilaci projektů a knihoven takovým
způsobem, aby byly nezávislé na operačním systému a kompilátoru. Funguje tak,
že pomocí jednotného konfiguračního souboru CMakeLists.txt vygeneruje Makefile
pro UNIX-like systémy a pro Windows generuje MSVC pracovní prostory. Velkou
výhodou CMake je správa závislostí - aplikace si mohou definovat na jakých knihovnách
jsou závislé, přičemž CMake kontroluje, jestli jsou tyto knihovny dostupné a navíc v
požadované verzi. Další velkou výhodou je možnost vytvářet jak spustitelné soubory
tak knihovny pomocí jedné jednoduché konfigurace umístěné v CMakeLists.txt.</p>
<p>Ukázkový soubor CMakeLists.txt pro aplikaci:</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.7)
project(MyCoolRobot)

set(CMAKE_CXX_STANDARD 17) 

add_executable(MyCoolRobot main.cpp)
</code></pre>
<p>Ukázkový soubor CMakeLists.txt pro knihovnu:</p>
<pre><code class="language-cmake">cmake_minimum_required (VERSION 3.7)
project (MyCoolLibrary VERSION 0.1 LANGUAGES CXX )

include(GNUInstallDirs)
set (CMAKE_CXX_STANDARD 17)
file (GLOB SOURCES src/*.cpp )

file (GLOB HEADERS include/*.h)

add_library(libmycoollibrary ${SOURCES})

target_include_directories(libmycoollibrary PUBLIC
    $&lt;BUILD_INTERFACE : ${CMAKE_CURRENT_SOURCE_DIR}/include&gt; 
    $&lt;INSTALL_INTERFACE : include&gt;
    PRIVATE src)

install (TARGETS libmycoollibrary EXPORT MyCoolLibraryConfig
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})

install(DIRECTORY include/DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})

install(EXPORT RoboUtilsConfig DESTINATION share/MyCoolLibrary/cmake)

export(TARGETS libroboutils FILE MyCoolLibraryConfig.cmake)
</code></pre>
<p>V případě, že máme nějaký projekt, který používá CMake a chceme jej spustit,
provedeme to pomocí příkazů:</p>
<pre><code class="language-shell">cd MyCoolRobot
cmake . 
make
./MyCoolRobot
</code></pre>
<h2><a class="header" href="#instalace-clion" id="instalace-clion">Instalace CLion</a></h2>
<p>Instalace CLion probíhá pomocí stažení instalačního balíčku ze stránky <a href="https://www.jetbrains.com/clion/">https://www.jetbrains.com/clion/</a> po kliknutí na &quot;GET FREE 30 DAY TRIAL&quot;.
Studenti mají nárok na bezplatné využívání plné verze po dobu studia, což se ostatně týká všech produktů firmy JetBrains. 
Získání plné verze je možné pomocí postupu na stránce <a href="https://www.jetbrains.com/student/">https://www.jetbrains.com/student/</a>.
Po stažení instalačního balíčku provedeme instalaci standardním způsobem podle zvyklostí jednotlivých operačních systémů.</p>
<h2><a class="header" href="#hello-world-projekt" id="hello-world-projekt">Hello World Projekt</a></h2>
<p>Nejprve vytvoříme jednoduchý HelloWorld projekt, ve kterém se seznámíme s procesem vytvoření projektu, prostředím a vývojem na lokálním počítači. 
Po spuštění CLion nás přivítá úvodní obrazovka se seznamem naposledy otevřených projektů, kde klikneme na tlačítko &quot;New Project&quot;.</p>
<p><img src="chap_1_software/text/../images/clion/clion1.png" alt="uvodni obrazovka" /></p>
<p>Po kliknutí se nám otevře okno s konfigurací nového projektu, kde nastavíme cestu, kde chceme mít projekt vytvořený a standard jazyka C++, v našempřípadě C++17.</p>
<p><img src="chap_1_software/text/../images/clion/clion2.png" alt="vytvareni projektu" /></p>
<p>Po kliknutí na &quot;Create&quot; nás přivítá samotné vývojové prostředí tak jak je zobrazeno na obrazku.</p>
<p><img src="chap_1_software/text/../images/clion/clion3.png" alt="IDE" /></p>
<p>Pojďme se nyní podívat, co se na obrazovce nachází.</p>
<p><img src="chap_1_software/text/../images/clion/clion4.png" alt="IDE popis" /></p>
<ol>
<li>podokno s aktuálně editovaným zdrojovým kódem</li>
<li>aktuálně otevřené soubory</li>
<li>soubory v projektu</li>
<li>zleva: kompilace projektu, výběr targetu, kompilace a spuštění, kompilace aspuštění v debug módu</li>
</ol>
<p>Verze CMake dodávaná v Raspbianu je bohužel relativně stará, zatím co CLion předpokládá použití relativně novou verzi, pro vyřešení tohoto problému je nutné změnit v souboru CMakeLists.txt verzi CMake z 3.12 na 3.7 tak jak je zobrazeno ve výpisu:</p>
<p>NOTE: Dnes jiz pravdepodobne neplati a Raspbian obsahuje znatelne novejsi verzi CMake.</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION  3.7)
project(HelloWorld)
set(CMAKE_CXX_STANDARD  14)
add_executable(HelloWorld  main.cpp)
</code></pre>
<p>Nyní klikneme na tlačítko pro kompilaci a spuštění, kdy se nám nejprve ve spodní části obrazovky zobrazí okno s průběhem kompilace a následně s konzolí spuštěného programu:</p>
<p><img src="chap_1_software/text/../images/clion/clion5.png" alt="Run" /></p>
<p>Při debugování se breakpointy přidávají kliknutím vedle čísla řádku. 
Po přidání breakpointu je nutné program spustit v debug módu v horní části okna. 
Po kompilacise ve spodní části zobrazí okno debuggeru. 
Navigace v debuggovaném kódu probíhá pomocí šipek v debuggovacím okně.</p>
<p><img src="chap_1_software/text/../images/clion/clion6.png" alt="Debug" /></p>
<p>Pro přidání nové třídy do projektu klikneme v podokně se soubory projektu na náš projekt pravým tlačítkem, najedeme na &quot;New&quot; a tam zvolíme &quot;C/C++ Class&quot;, jak je zobrazeno na obrázku. 
Při přidávání a odebírání souborů je nutné, aby všechny <code>.cpp</code> soubory byly uvedeny v CMakeLists.txt.</p>
<p><img src="chap_1_software/text/../images/clion/clion7.png" alt="new class" /></p>
<p>CLion obsahuje spoustu funkcí a možností, jejichž popsání je zcela nad rámec tohoto návodu, doporučuji tedy si s ním pohrát a vyzkoušet, co všechno se v něm dá dělat a jak efektivně. 
Dobré je rovněž si všímat toho, když je řádek označený žlutě, většinou se jedná o CLion doporučující nějaké zlepšení kódu.</p>
<h2><a class="header" href="#vzdálený-vývoj" id="vzdálený-vývoj">Vzdálený vývoj</a></h2>
<p>Vzdálený vývoj (remote development) znamená, že výpočetně náročné vývojové prostředí běží na běžném počítači, zatímco kompilace a spouštění programu probíhána cílovém počítači. 
Tímto způsobem lze například velmi pohodlně programovat embedded hardware případně servery. 
Velká výhoda je, že například jde z Windows nebo MacOS programovat aplikace pro Linux, což nemusí vždy být možné kvůli chybějícím knihovnám napřiklad i2c-dev. 
Funkcionalita vzdáleného vývoje byla doprostředí CLion přidána ve verzi 2018.3.</p>
<p>Pro nakonfigurování vzdáleného vývoje je nutné nejprve přejít do nastaveníprostředí CLion (Preferences). 
Zde ve stromu vybereme &quot;Build, Execution, Deployment&quot; a položku &quot;Toolchains&quot; viz obrazek. 
Dále klikneme na tlačítko &quot;+&quot;.</p>
<p><img src="chap_1_software/text/../images/clion/clion8.png" alt="toolchain" /></p>
<p>Následně vyplníme jméno toolchainu a volbu &quot;System&quot; přepneme na &quot;RemoteHost&quot; tak, jak je to zobrazeno na obrazku. 
Následně klepneme na ikonu složky upoložky &quot;Credentials&quot; a nastavíme je podle konfigurace našeho robotu. 
Pokud konfigurace Raspberry Pi nebyla měněna, lze použít hodnoty uvedené v tabulce a zobrazené na obrázku.
Na Raspberry Pi musí být povoleno SSH.</p>
<p><img src="chap_1_software/text/../images/clion/clion9.png" alt="toolchain" />
<img src="chap_1_software/text/../images/clion/clion10.png" alt="toolchain" /></p>
<table><thead><tr><th>parametr</th><th>hodnota</th></tr></thead><tbody>
<tr><td>Host</td><td>raspberrypi.local</td></tr>
<tr><td>Port</td><td>22</td></tr>
<tr><td>User name</td><td>pi</td></tr>
<tr><td>Password</td><td>raspberry</td></tr>
</tbody></table>
<p>Po kliknutí na OK, se CLion pokusí připojit k danému Raspberry Pi a zkontroluje,zda jsou všechny potřebné programy k dispozici. 
Připojování je vidět na obrazku a úspěšné připojení je vidět na dalsim obrazku.</p>
<p><img src="chap_1_software/text/../images/clion/clion11.png" alt="toolchain" />
<img src="chap_1_software/text/../images/clion/clion12.png" alt="toolchain" /></p>
<p>Dalším důležitým krokem je konfigurace CMake, ta se provádí rovněž v okně Preferences tak jak je zobrazeno na obrazku.</p>
<p><img src="chap_1_software/text/../images/clion/clion13.png" alt="toolchain" />
Po kliknutí na &quot;+&quot; nakonfigurujeme CMake tak aby používal náš nový toolchain,tak jak je to zobrazeno na obrázku a klikneme na OK.</p>
<p><img src="chap_1_software/text/../images/clion/clion14.png" alt="toolchain" /></p>
<p>Po kliknutí na OK proběhne upload souborů na Raspberry Pi, po uploadu je nutné přepnout konfiguraci CMake na naši nově vytvořenou jak je zobrazenona obrazku.</p>
<p><img src="chap_1_software/text/../images/clion/clion15.png" alt="toolchain" />
<img src="chap_1_software/text/../images/clion/clion16.png" alt="toolchain" /></p>
<p>Poté následuje reload konfigurace jak je zobrazeno na obrazku.</p>
<p><img src="chap_1_software/text/../images/clion/clion17.png" alt="toolchain" /></p>
<p>Po kliknutí na tlačítko kompilace a spuštění se náš firmware zkompiluje naRaspberry Pi a spustí se, tak jak je vidět na obrazku, kdy úspěch poznáme podle toho, že se spustitelný soubor spouští z adresáře tmp.</p>
<p><img src="chap_1_software/text/../images/clion/clion18.png" alt="toolchain" /></p>
<p>Vzdálený vývoj je nyní nakonfigurován a měl by fungovat téměř bez problémů, častým problémům je věnována kapitola Troubleshooting.</p>
<h2><a class="header" href="#troubleshooting" id="troubleshooting">Troubleshooting</a></h2>
<p>V této kapitole bude rozebráno řešení problémů vznikajících při použití vzdáleného vývoje.</p>
<h3><a class="header" href="#cmake-312-is-required-you-are-running-version-372" id="cmake-312-is-required-you-are-running-version-372">CMake 3.12 is required. You are running version 3.7.2</a></h3>
<p>Problém je ve vašem CMakeLists.txt, změňte parametr &quot;cmake_minimum_required&quot;.</p>
<h3><a class="header" href="#v-raspberry-pi-chybí-požadované-soubory" id="v-raspberry-pi-chybí-požadované-soubory">V Raspberry Pi chybí požadované soubory</a></h3>
<p>Po kliknuti na slozku projektu v levem panelu, kliknete na &quot;Deployment&quot;, &quot;Upload to&quot; a vyberte Raspberry Pi.</p>
<h3><a class="header" href="#ultimátní-řešení-problémů" id="ultimátní-řešení-problémů">Ultimátní řešení problémů</a></h3>
<p>Zkontrolujte, jestli v CMakeLists.txt jsou uvedeny všechny soubory, které se mají kompilovat. 
Zkuste v podokně CMake provést reload, jak je zobrazeno na obrazku. 
Pokud to nepomůže, přes SSH se připojte k Raspberry Pi, v /tmp smažte momentálně používanou složku pro vzdálený vývoj, restartujte CLion.</p>
<p><img src="chap_1_software/text/../images/clion/clion19.png" alt="toolchain" /></p>
<h1><a class="header" href="#robotic-operating-system" id="robotic-operating-system">Robotic Operating System</a></h1>
<p>Název &quot;Robot Operating System&quot; poněkud klame svým zněním. Nejedná se o samostaný operační sýstém, nýbrž spíše o middle-ware, tedy softwarový nástroj (knihovnu), který pomáha propojit dílčí programy do komplexnejšího celku. V praxi si to můžem představit tak, že máme jednoduchou aplikaci pro robota jezdícího po čáre, kterou realizujeme pomoci 3 navzájem spolupracujících programů (příklad funguje jako ilustrační; takového robota samozřejmě můžeme naprogramovat pomocí jednoho programu; ilustrujeme tím ale komplexnější problém). První program vyčítá data ze snímače a provádí jednoduchou filtraci dat. Druhý program je mozkem celého řešení a rozhoduje o pohybu robota. Třetí program pak přijímá řídicí pokyny a na jejich základě ovládá motory.</p>
<p><img src="chap_1_software/text/../images/robot_scheme.png" alt="Rviz" /></p>
<p>Obr: Schéma fungování pomyslého line-tracking robota na platformě Rapserry Pi s pouřitím ROSu.</p>
<p>V případě absence ROSu bychom museli vymyslet způsob jak tyto tři programy spolu budou komunikovat. Mohli bychom sdílet paměť, pipovat, posílat si IP zprávy, používat DBus, etc. Všechny tyto techniky fungují, ale vyžadují určitý programátorský um. My se těmito nízkouúrovňovými problémy nechceme zabývat a proto použijeme ROS.</p>
<p>V praxi si pak můžeme říct, že ROS komunikuje mezi procesy právě pomocí posílání UDP paketů. To umožňuje také komunikovat procesům, které běží na různých počítačích. Tomu říkáme distribuovaný systém.</p>
<p>Celý ROS je postaven na 4 stavebních kamenech.</p>
<ul>
<li>ROS Core</li>
<li>ROS Node</li>
<li>ROS Topic</li>
<li>ROS Message</li>
</ul>
<p>ROS Core - Zjednodušeně řečeno se jedná o IP server, který zajištujě propojení programů (Nodů), které si chtějí vyměnovat data (Message) . Core nativně otevře port 11311 na localhostu a čeká na příchozí komunikaci.</p>
<p>ROS Node - Nodem je myšlený každý program do kterého přídáme klinetskou knihovnu ROSu. Naučíme tedy program používat funkce ROSu.</p>
<p>ROS Topic - Doména, ve které se posílá specifický okruh ROS Messagů.</p>
<p>ROS Message - Jedna instance odeslané zprávy. V rámci ROSu je možné posílat jenom zprávy, které jsou striktně zadefinovány a mají svůj jasně daný formát. Často obsahují také časovou značku, kdy byly odeslány.</p>
<p>Dále si zadefinujme dva typy postavení ROS Nodů při komunikaci.</p>
<p>Subscriber - ROS Node, který přijímá všechny zprávy v rámci daného ROS Topicku.</p>
<p>Publisher - ROS Node, který vytváří a odesíla zprávy v rámci daného ROS Topicku.</p>
<p>Náš robot-sledující-čáru příklad si pak můžem ilustrovat takto:</p>
<p><img src="chap_1_software/text/../images/ros_com_scheme.png" alt="Rviz" /></p>
<p>Nejprve zapneme ROS Core, tedy server, který začte poslouchat příchozí komunikaci. Dále si napíšeme zmíněne 3 programy. Jeden pro čtení dat ze snímače, druhý pro rozhodování, jak se pohybovat a třetí pro ovládání motorů. První program (Node) se přihlásí k serveru, jako publisher pro topick &quot;SensorData&quot;. Druhý se přihlásí serveru, jako subscriber v tomtéž topicku. Server si tyto dva nody poznamená a publisherovi odešle informaci, že je v sídi na dané adrese a portu připravený subscriber, který si vyžádal data z topicku, který oba nody sdílí. Když pak první program přečte data ze snímače, vyfiltruje je a vytvoří z nich message, kterou pošle na dříve obdrženou adresu a port, aby data obdržel subscriber. Obdobným způsobem se vymění data i mezi druhým a třetím programem, pouze pod hlavičkou jiného topicku.</p>
<p>Nyní máme vytvořené všechny tři programy. Ty spolu komunikují, ale robot přesto nefunguje podle přestav. Tušíme, že chyba je v tom, jak druhý program převádí data ze snímače na pohyb kol. Proto si napíšeme 4. program, který bude poslouchat veškerou komunikaci a bude ji logovat do souboru. Náš nový program tedy bude subscriberem pro oba dříve zavedené topicky &quot;SensorData&quot; a &quot;MotorControl&quot;. V okamžiku kdy tento program zapneme, tak se ohlásí serveru a od tohoto okamžiku všechny zprávy odeslané v topicích &quot;SensorData&quot; a &quot;MotorControl&quot; budo poslány také našemu logovcímu programu. Ten zprávy přijíme a jejich obsach včetně časové značky vytiskne do souboru. Když se pak do souboru podíváme, zjistíme, že plánovací program vatváří akční zásah vždy s opačným znaménkem, proto přídáme &quot;-&quot; do výpočtu akčního zásahu a vše začne fungovat.</p>
<h2><a class="header" href="#instalace-rosu" id="instalace-rosu">Instalace ROSu</a></h2>
<p>Tento návod je pouze českým přepisem oficiální dokumentace (Instalace pro Ubuntu)[http://wiki.ros.org/noetic/Installation/Ubuntu]. Prim8rn2 prosím používejte oficiální verzi. Tento návod je pouze doprovodný.</p>
<p>Instalace je doporučená na distribuci Ubuntu 20.04 LTS (long term stable). Instalovat budeme verzi ROSu z roku 2020, Noetic.</p>
<p>Přidáme do Linuxu repozitáře (servery) ze kterých je možné stáhnout ROS.</p>
<pre><code>sudo sh -c 'echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list'
</code></pre>
<p>Přidáme do systému klíč pro zabezpečenou komunikace s repozitářem.</p>
<pre><code>sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654
</code></pre>
<p>Necháme baličkovací systém načíst nově přidaná data.</p>
<pre><code>sudo apt update
</code></pre>
<p>Samotný ROS nainstalujeme příkazem. Trvá cca 10 min.</p>
<pre><code>sudo apt install ros-noetic-desktop-full
</code></pre>
<p>A na závěr si do souboru ~/.bashrc přídáme záznam o náčítání ROSu do proměnného prostředí, kdykoliv zapneme terminál.</p>
<pre><code>echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc
source ~/.bashrc
</code></pre>
<h2><a class="header" href="#tvorba-vlastního-nodu" id="tvorba-vlastního-nodu">Tvorba vlastního nodu</a></h2>
<p>Vytvoříme si jednoduchou aplikaci, kte jeden node bude odesílat zprávu s pořadovým číslem a časovou značkou a druhý node zprávu přijíme, vypíše a zjisti, s jakým zpožděním zpráva došla.</p>
<p>Nejprve si vytvoříme tzv workspace pro náš projekt. Workspacem se myslí speciálně uspořádaná složka.</p>
<pre><code>cd ~/
mkdir ros_ws
cd ros_ws
mkdir src
cd src
</code></pre>
<h3><a class="header" href="#c-node" id="c-node">C++ Node</a></h3>
<p>Dále si pomocí catkinu (balíčkovací nástroj pro ROS) necháme vztgenerovat nový balíček (package).</p>
<pre><code>catkin_create_pkg cpp_publisher std_msgs roscpp
</code></pre>
<p>Příkaz nám říká, že budeme volat program catkin_create_pkg a chceme po něm, aby nám vytvořil balíček cpp_publisher a připojil k němu knihovny std_msgs, která obsahuje základní sadu ROS zpráv a taktéž knihovnu roscpp, což je základní knihovana pro implementaci ROS Nodu v C++.</p>
<p>Nyní se náš balíček skládá z několika následujícíh souborů</p>
<pre><code>~/ros_ws/src/cpp_publisher/
    include/
    src/
    CMakeLists.txt
    package.xml
</code></pre>
<p>Do adresářů include a src budeme ukládat naše zdrojové kódy a soubory CMakeLists.txt a package.xml slouží ke kompilaci balíčku.</p>
<p>CMakeLists.txt a package.xml obsahují velké množství předpřipravených direktiv, které slouží složitějším příkladům. Pro naše potřeby si můžeme tyto dva soubory smazat.</p>
<pre><code>cd ~/ros_ws/src/cpp_publisher/
rm CMakeLists.txt
rm package.xml
</code></pre>
<p>Pomocí programu nano, nebo vim si oba soubory znovu vytvoříme tak a přidáme následující obsah.</p>
<pre><code>nano CMakeLists.txt
</code></pre>
<pre><code>cmake_minimum_required(VERSION 2.8.3)
project(cpp_publisher)

## Find catkin and any catkin packages
find_package(catkin REQUIRED COMPONENTS roscpp std_msgs)


## Declare a catkin package
catkin_package()

## Build talker and listener
include_directories(include ${catkin_INCLUDE_DIRS})

add_executable(cpp_publisher src/main.cpp)
target_link_libraries(cpp_publisher ${catkin_LIBRARIES})
</code></pre>
<p>a</p>
<pre><code>nano package.xml
</code></pre>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;package format=&quot;2&quot;&gt;
  &lt;name&gt;cpp_publisher&lt;/name&gt;
  &lt;version&gt;0.0.0&lt;/version&gt;
  &lt;description&gt;The cpp_publisher package&lt;/description&gt;

  &lt;maintainer email=&quot;my@email.todo&quot;&gt;adash&lt;/maintainer&gt;

  &lt;license&gt;TODO&lt;/license&gt;

  &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;
  &lt;build_depend&gt;roscpp&lt;/build_depend&gt;
  &lt;build_depend&gt;std_msgs&lt;/build_depend&gt;
  &lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;
  &lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;
  &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;
  &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;

  &lt;export&gt;

  &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<p>Nyní si můžeme vytvořit soubor main.cpp ve složce src a do něj napíšeme vlastní program</p>
<pre><code>nano src/main.cpp
</code></pre>
<pre><code>#include &lt;sstream&gt;

#include &quot;ros/ros.h&quot;
#include &quot;std_msgs/Header.h&quot;

int main(int argc, char **argv) {
    ros::init(argc, argv, &quot;cpp_publisher&quot;);
    ros::NodeHandle n;

    ros::Publisher publisher = n.advertise&lt;std_msgs::Header&gt;(&quot;/my_topic&quot;, 1);
    ros::Rate loop_rate(10);

    int count = 0;
    while (ros::ok()) {

        std_msgs::Header msg;
        msg.stamp = ros::Time::now();
        msg.seq = count++;
        msg.frame_id = &quot;origin&quot;;

        publisher.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}
</code></pre>
<p>Nyní se vrátíme do kořene našeho workspacu a zavoláme příkaz pro build celého workspacu.</p>
<pre><code>cd ~/ros_ws
catkin_make
</code></pre>
<p>Pokud se nevypíše žádná chyba, máme hotový publisher, který je uložený v  ~/ros_ws/devel/lib/cpp_publisher.</p>
<p>Aby si Linux načetl nově zkompilované programy z našeho ros_ws přidámi si tento workspace do systémového prostředí (environmentu).</p>
<pre><code>source ~/ros_ws/devel/setup.bash
</code></pre>
<p>Abychom tuto akci již nemuseli opakovat přidáme si tento řádek také do ~/.bashrc</p>
<pre><code>echo &quot;source ~/ros_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc
</code></pre>
<p>Nyní si otevřeme další 2 terminály tak, abychom celkem měli 3 okna terminálu. V jednom aktivujeme roscore</p>
<pre><code>roscore
</code></pre>
<p>Ve druhém námi vytvořený publisher.</p>
<pre><code>rosrun cpp_publisher cpp_publisher
</code></pre>
<p>A ve třetím si poslechneme zprávy na topicku /my_topic</p>
<pre><code>rostopic echo /my_topic
</code></pre>
<p>Pokud vidíte v terminále výpis zpráv, vše pracuje, jak má.</p>
<h3><a class="header" href="#python-node" id="python-node">Python Node</a></h3>
<p>Vytvoříme si další balíček pomocí</p>
<pre><code>cd ~/ros_ws/src/
catkin_create_pkg python_subscriber std_msgs rospy
</code></pre>
<p>a upravíme si strukturu balíčku tak, aby vypadala následovně.</p>
<pre><code>~/ros_ws/src/python_subscriber/
    bin/
        python_subscriber.py
    include/
    src/
    setup.py
    CMakeLists.txt
    package.xml
</code></pre>
<p>Složka bin bude soužit k uložení hlavního skriptu python_subscriber.py, include a src pro další zdrojové kódy, které ale dneska nevyužijeme a CMakeLists.txt a package.xml obdobně jako pro C++ příklad. setup.py slouží k instalaci pythoniho balíčku do workspacu.</p>
<p>Zmíněné soubory si pak upravíme následovně.</p>
<pre><code>cmake_minimum_required(VERSION 2.8.3)
project(python_subscriber)

find_package(catkin REQUIRED COMPONENTS
  rospy
  std_msgs
)

catkin_package()

catkin_python_setup()
</code></pre>
<p>dále</p>
<pre><code>nano package.xml
</code></pre>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;package format=&quot;2&quot;&gt;
  &lt;name&gt;python_subscriber&lt;/name&gt;
  &lt;version&gt;0.0.0&lt;/version&gt;
  &lt;description&gt;The python_subscriber package&lt;/description&gt;

  &lt;maintainer email=&quot;my@email.todo&quot;&gt;adash&lt;/maintainer&gt;

  &lt;license&gt;TODO&lt;/license&gt;

  &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;
  &lt;build_depend&gt;rospy&lt;/build_depend&gt;
  &lt;build_depend&gt;std_msgs&lt;/build_depend&gt;
  &lt;build_export_depend&gt;rospy&lt;/build_export_depend&gt;
  &lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;
  &lt;exec_depend&gt;rospy&lt;/exec_depend&gt;
  &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;

  &lt;export&gt;

  &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<p>pak</p>
<pre><code>nano setup.py
</code></pre>
<pre><code>## ! DO NOT MANUALLY INVOKE THIS setup.py, USE CATKIN INSTEAD

from distutils.core import setup
from catkin_pkg.python_setup import generate_distutils_setup

# fetch values from package.xml
setup_args = generate_distutils_setup(
    packages=['python_subscriber'],
    package_dir={'': 'src'},
)

setup(**setup_args)
</code></pre>
<p>a finálně</p>
<pre><code>nano python_subscriber.py
</code></pre>
<pre><code>#!/usr/bin/env python
import rospy
from std_msgs.msg import Header

def callback(message):

    now = rospy.Time.now()
    delta_t = (now.secs - message.stamp.secs)*1000000000 + (now.nsecs - message.stamp.nsecs)

    print('seq: ' + str(message.seq))
    print('frame id: ' + message.frame_id)
    print('send time: ' + str(message.stamp.secs) + '.' + str(message.stamp.nsecs).zfill(9) + 's')
    print('receive time: ' + str(now.secs) + '.' + str(now.nsecs).zfill(9) + 's')
    print('delay [ns]: ' + str(delta_t))
    print(30*'*')

def listener():

    rospy.init_node('listener', anonymous=True)

    rospy.Subscriber(&quot;/my_topic&quot;, Header, callback)

    # spin() simply keeps python from exiting until this node is stopped
    rospy.spin()

if __name__ == '__main__':
    listener()
</code></pre>
<p>a přídáme souboru python_subscriber.py flag pro spouštění, aby bylo možné zapnout skript.</p>
<pre><code>chmod +x ~/ros_ws/src/python_subscriber/bin/python_subscriber.py
</code></pre>
<p>Nyní se můžeme vrátit do kořene workspacu a vše ykompilovat.</p>
<pre><code>cd ~/ros_ws/
catkin_make
</code></pre>
<p>Zaktualizujeme si proměné prostředí.</p>
<pre><code>source ~/ros_ws/devel/setup.bash
</code></pre>
<p>Pokud máme aktivní roscore i cpp_publisher, pak zampene node pomocí</p>
<pre><code>rosrun python_subscriber python_subscriber
</code></pre>
<p>a vidíme výpis přijímaných zpráv.</p>
<p>Pomocí programu rqt_graph si můžeme prohlédnout aktuální stav propojení nodů.</p>
<pre><code>rosrun rqt_graph rqt_graph
</code></pre>
<p><img src="chap_1_software/text/../images/rqt_graph.png" alt="rqt_graph" /></p>
<p>Obr: vizualizace komunikace mezi nody pomocí rqt_graph</p>
<h2><a class="header" href="#rviz" id="rviz">Rviz</a></h2>
<p>Rviz je vizualizační nástroj, který je dodáván jako součást ROSu. Jedná se o aplikaci, která dokáže poslouchat širokou paletu předdefinovaných ROS zpráv a vizualizovat je v 3D grafickém prostředí.</p>
<p>Obvzkle Rviz používáme pro vizualizaci pointcloudů (mrařna bodů z LIDARu), obrázků z kamery, vykreslování geometrických primitiv v prostoru, vizualizace occupancy grid map, atd.</p>
<p>Pokud nám již běži roscore, rviz aktivujeme pomocí</p>
<pre><code>rosrun rviz rviz
</code></pre>
<p>Vizualizaci konkrétního topicku pak aktivujeme pomocí</p>
<p>Add -&gt; By topic -&gt; [náš topick]</p>
<p>V sekci</p>
<p>Add -&gt; By display type</p>
<p>vidíme všechny podporované typy zpráv (viz online dokumentace ROSu).</p>
<p><img src="chap_1_software/text/../images/rviz.png" alt="rqt_graph" />
Obr: příklad vizualizace pointcloudu a kamery v Rvizu</p>
<p>Nyní si skusme vytvořit vlastní Node, který bude vykreslovat geometrické primitivum do RVizu. Vyjděme z příkladu cpp_ros_publishera a vytvořné následujicí program.</p>
<pre><code>cd ~/ros_ws/src
catkin_create_pkg cpp_rviz_publisher std_msgs visualization_msgs roscpp
</code></pre>
<p>CMakeLists.txt</p>
<pre><code>cmake_minimum_required(VERSION 2.8.3)
project(cpp_rviz_publisher)

## Find catkin and any catkin packages
find_package(catkin REQUIRED COMPONENTS roscpp std_msgs visualization_msgs)


## Declare a catkin package
catkin_package()

## Build talker and listener
include_directories(include ${catkin_INCLUDE_DIRS})

add_executable(cpp_rviz_publisher src/main.cpp)
target_link_libraries(cpp_rviz_publisher ${catkin_LIBRARIES})
</code></pre>
<p>package.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;package format=&quot;2&quot;&gt;
  &lt;name&gt;cpp_rviz_publisher&lt;/name&gt;
  &lt;version&gt;0.0.0&lt;/version&gt;
  &lt;description&gt;The cpp_rviz_publisher package&lt;/description&gt;

  &lt;maintainer email=&quot;my@email.todo&quot;&gt;adash&lt;/maintainer&gt;

  &lt;license&gt;TODO&lt;/license&gt;

  &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;
  &lt;build_depend&gt;roscpp&lt;/build_depend&gt;
  &lt;build_depend&gt;std_msgs&lt;/build_depend&gt;
  &lt;build_depend&gt;visualization_msgs&lt;/build_depend&gt;
  &lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;
  &lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;
  &lt;build_export_depend&gt;visualization_msgs&lt;/build_export_depend&gt;
  &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;
  &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;
  &lt;exec_depend&gt;visualization_msgs&lt;/exec_depend&gt;

  &lt;export&gt;

  &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<p>src/main.cpp</p>
<pre><code>#include &lt;sstream&gt;
#include &lt;ros/ros.h&gt;
#include &lt;visualization_msgs/Marker.h&gt;

visualization_msgs::Marker createCuteCube(float pose) {

    visualization_msgs::Marker marker;
    marker.header.frame_id = &quot;map&quot;;
    marker.header.stamp = ros::Time();
    marker.ns = &quot;cube&quot;;

    marker.id = 0;
    marker.type = visualization_msgs::Marker::CUBE;
    marker.action = visualization_msgs::Marker::ADD;

    marker.pose.position.x = sin(pose);
    marker.pose.position.y = cos(pose);
    marker.pose.position.z = 0.1*sin(5*pose);

    marker.pose.orientation.x = 0.0;
    marker.pose.orientation.y = 0.0;
    marker.pose.orientation.z = 0.0;
    marker.pose.orientation.w = 1.0;

    marker.scale.x = 0.1;
    marker.scale.y = 0.1;
    marker.scale.z = 0.1;

    marker.color.a = 1.0;
    marker.color.r = 0.0;
    marker.color.g = 1.0;
    marker.color.b = 0.0;

    return marker;
}


int main(int argc, char **argv) {

    ros::init(argc, argv, &quot;cpp_rviz_publisher&quot;);
    ros::NodeHandle n;

    ros::Publisher vis_pub = n.advertise&lt;visualization_msgs::Marker&gt;( &quot;/cute_cube&quot;, 0 );
    ros::Rate loop_rate(100);

    float pose = 0;
    while (ros::ok()) {
        visualization_msgs::Marker cube = createCuteCube(pose);
        vis_pub.publish( cube );
        pose += 0.01;

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}
</code></pre>
<p>V Rvizu si pak otevřeme topic /cute_cube .</p>
<h2><a class="header" href="#distribuovaný-ros" id="distribuovaný-ros">Distribuovaný ROS</a></h2>
<p>Tím, že calý backend ROS-ové komunikace je postaven na IP komunikaci (UDP protokolu), je možné snadno komunikaci mezi Nody přenést i na jiné počítače v dostupné síti. Po nainstalování je ROS nakonfigurován tak, že veškerá komunikace s Corem probíha na adrese http://localhost:11311, a Nody si bindují dostupné volné UDP porty a skrze něj komunikují mezi sebou. Pokud ale nastavíme na lokálním stroji proměnnou ROS_MASTER_URI na jinou IP adresu, bude každý nově nastartovaný Node hledat svůj ROS Core na adrese uvedené v ROS_MASTER_URI.</p>
<p>Spojme si 2 počitáče skrze IP síť a ověřme, že na seba navzájem vidí příkazem PING.</p>
<pre><code>ping xxx.yyy.zzz.qqq
</code></pre>
<p>Pokud oba počítače na sebe navzájem vidí, můžeme na počítači, kde chceme provozovat ROS Core nastavit proměnné, a aktivovat Core.</p>
<pre><code>export ROS_MASTER_URI=http://localhost:11311
export ROS_IP=&lt;ip_adresa_pocitace&gt;
roscore
</code></pre>
<p>Na 2. počítači, kde poběží nody musíme nastavit prostředí tak aby dokázalo najít ROS Core v síti.</p>
<pre><code>export ROS_MASTER_URI=http://&lt;ip_adresa_coru&gt;:&lt;port_coru&gt;
export ROS_IP=&lt;ip_adresa_pocitace&gt;
</code></pre>
<p>Ověřit nastavení proměnných můžeme příkazy</p>
<pre><code>echo $ROS_MASTER_URI
echo $ROS_IP
</code></pre>
<p>Nyní, pokud aktivujeme publisher a subscriber na libovolném počítači v takto nastavené ROS síti, budou nody spolu komunikovat.</p>
<p><img src="chap_1_software/text/../images/ros_distributed.png" alt="rqt_graph" />
Obr: příklad konfigurace ROSu na dvou počítačích.</p>
<h2><a class="header" href="#kam-dál" id="kam-dál">Kam dál?</a></h2>
<p>Tento tutoriál je popisuje pouze malý zlomek všech možných funkcionalit této obšírné platformy.</p>
<p>Oficiální web [1] - http://www.ros.org/</p>
<p>Oficiální tutoriály [2] - http://wiki.ros.org/ROS/Tutorials</p>
<p>Naučit se používat ROS Services [6]</p>
<p>Seznamy několika předdefinovaných ROS Messagů - [4] [5]</p>
<p>Pro zdatné ROSáky je možnost se posunout na další kvalitativní level, a totiž ROS 2 [3]. Druhá verze robotického operačního systému je již koncipováná jako real-time middleware s podporou QoS a širokou paletou služeb, které ocení zejména vývojáři sofistikovaných robotických řešení, na která bude kladeny řádově vyžší kvalitativní nároky.</p>
<p>Pro reálnou práci se zdrojovými kódy je vhodné použít nějaké IDE. V případě Linuxu vřele doporučuji programy od  JetBrains, CLion pro vývoj C++ a Pycharm pro práci s pythonem. Oba programy jsou pro studenty VUT zdarma.</p>
<h2><a class="header" href="#reference" id="reference">Reference</a></h2>
<p>[1] http://www.ros.org/</p>
<p>[2] http://wiki.ros.org/ROS/Tutorials</p>
<p>[3] https://github.com/ros2/ros2/wiki</p>
<p>[4] http://wiki.ros.org/std_msgs</p>
<p>[5] http://wiki.ros.org/sensor_msgs</p>
<p>[6] http://wiki.ros.org/Services</p>
<p>[7] https://www.computerhope.com/unix/uchmod.htm</p>
<p>[8] http://wiki.ros.org/ROS/Installation</p>
<h1><a class="header" href="#příprava-prostředí" id="příprava-prostředí">Příprava prostředí</a></h1>
<p>V této kapitole stručně probereme, jak si připravit počítač tak, aby bylo možné začít vyvíjet kód pro BPC-PRP projekt.</p>
<p>V ideálním případě si nainstalujte Linux přímo na Váš počítač, případně je možné jej nainstalovat do virtuálního stroje.</p>
<h2><a class="header" href="#instalace-virtualboxu" id="instalace-virtualboxu">Instalace VirtualBoxu</a></h2>
<p>VirtualBox si nainstalujte podle návodu na příslušném operačním systému.</p>
<p>Postup pro <a href="https://www.virtualbox.org/wiki/Downloads">Windows a Mac</a>.</p>
<p>Pro Linux instalace záleží na distribuci a používaném baličkovacím systému. Na Debianu použijte příkaz &quot;sudo apt install virtualbox&quot;. Poté bude možné VB aktivovat z terminálu voláním &quot;virtualbox&quot;, nebo skrze ikonku v seznamu nainstalovaných programů.</p>
<p><img src="chap_1_software/text/../images/vb.png" alt="VB" /></p>
<h2><a class="header" href="#instalace-linuxu" id="instalace-linuxu">Instalace Linuxu</a></h2>
<p>Stáhněte si obraz instalačního disku <a href="https://ubuntu.com/download/desktop">Ubuntu 20.04</a>.</p>
<p>Pomocí tlačítka &quot;New&quot; vytvořte nový virtuální stroj. Pojmenujte si jej, zvolte typ operačního systému, nastavte velikost operační paměti (vhodné 4GB a více), vytvořte nový virtuální disk, vyberte typ virtuálního disku (VDI), zvolte dynamickou alokaci disku a na poslední obrazovce vyberte umístění virtuálního disku na svém počítači a zvolte maximální možnou velikost virtuálního disku (10 - 20GB).</p>
<p>Nyní v hlavní obrazovce Virtual Boxu zvolte nově vytvořený virtuální stroj a přejděte do nastavení.</p>
<p>V záložce &quot;System&quot; můžete měnit velikost dedikované operační paměti, měnit počet jader procesorů, která budou pro virtuální stroj dostupná a také můžete zapínat/vypínat HW akceleraci pro virtuální stroj.</p>
<p>Dále v záložce &quot;Display&quot; světšete množství dedikované video paměti na maximum (128MB).</p>
<p>V záložce &quot;Storage&quot; klikněte na položku s obrázkem CD a následně úplně v pravo klikněte pravým na ikonku CD s malou šipečkou. Tím otevřete okno pro nastavení cesty k instalačnímu obrazu Ubuntu, které jsme dříve stáhli na počítač. Zavřete nastavení tlačítkem OK.</p>
<p><img src="chap_1_software/text/../images/vb_storage.png" alt="VB" /></p>
<p>Nyní v hlavním okně Virtual Boxu aktivujte virtuální stroj tlačítkem start.</p>
<p>Pokud je vše nastaveno korektně, stroj nabootuje z instalačního obrazu.</p>
<p><img src="chap_1_software/text/../images/ubuntu_install_1.png" alt="VB" /></p>
<p>Zvolte jazyk operačního systému (doporučeno angličtinu), zvolte rozložení klávesnice (doporučeno English US), a nechte pokračovat &quot;Normal Installation&quot;.</p>
<p>Dále se Vás proces dotáže, zda chcete &quot;Smazat disk a nainstalovat Ubuntu&quot;. Pokud nemáte konkrétní přání, jak si nastavit rozložení na disku, souhlaste s touto volbou. Systém Vám vypíše způsob, jakým rozdělí disk. Souhlaste.</p>
<p>Nyní zvolte časové pásmo a dále si vytvořte účet s heslem.</p>
<p>A dále už jen počkejte, až se systém doinstaluje a provede se reset virtuálního stoje.</p>
<p>Po opětovném nabootování v horní liště okna virtuálního stroje zvolte záložku &quot;Devices&quot; a &quot;Insert Guest Additions CD Image&quot;. Za okamžik vyskočí okno, které se dotáže zda má aktivovat autorun vloženého CD. Souhlaste. Systém si vyžádá heslo a poté se doinstalují ovladače pro virtualizovaný hardware.</p>
<p>Po dalším sestartu máte připarevený virtuální stroj s nainstalovaným Linuxem Ubuntu 20.04.</p>
<p><img src="chap_1_software/text/../images/ubuntu_rdy.png" alt="VB" /></p>
<p>Jako alternativu si stáhněte obraz virtuálního stroje s nainstalovaným Ubuntu <a href="https://drive.google.com/file/d/1kTZDLVTljSmCJOvL0AAAgZzEql6RpVrq/view?usp=sharing">zde</a>.</p>
<h2><a class="header" href="#instalace-ros" id="instalace-ros">Instalace ROS</a></h2>
<p>Instalaci ROSu na nově nainstalovaný Linux proveďte pomocí návodu popsaného v kiapitole <a href="chap_1_software/text/ros.html">Robotic Operating System</a>.</p>
<h2><a class="header" href="#clion" id="clion">CLion</a></h2>
<p>CLion si do nově nainstalovaného systému stáhněte z oficiálních stránek (viz <a href="chap_1_software/text/clion.html">CLion</a>)</p>
<h1><a class="header" href="#cviceni" id="cviceni">Cviceni</a></h1>
<h1><a class="header" href="#instalace-a-seznámení-se-s-prostředím" id="instalace-a-seznámení-se-s-prostředím">Instalace a seznámení se s prostředím</a></h1>
<p>Cvičící: Ing. Adam Ligocki</p>
<h2><a class="header" href="#instalace-linux-cca-45min" id="instalace-linux-cca-45min">Instalace Linux (cca 45min)</a></h2>
<p>Nainstalujte si operační systém Linux Ubuntu 20.04 na fyzický stroj (preferovaná varianta), případně jako alternativu si vytvořte virtální stroj pomocí VirtualBoxu a operační systém si nainstalujte zde.</p>
<p>Návod naleznete zde <a href="cviceni/../chap_1_software/text/vb.linux_installation.html">Příprava prostředí</a></p>
<p>✅ Senzamte se se GUI systému.</p>
<p>✅ Otevřete si příkazový řádek, vyzkoušejtesi pohyb v souborovém systému</p>
<p>✅ Vytovřte, smažte soubor/složku</p>
<p>✅ Pomocí balíčkovacího manažeru si nainstalujte git, midnight commander (mc). Pro odvážné také textový editor vim</p>
<details>
    <summary>Nainstaloval jsem si vim a omylem jej zapnul. Co teď?</summary>
<p>Vim vypnete touto sekvencí: stiskněte ESC, pak jej pusťte, přidržte LSHITF a dakrát klávesu 'Z'.</p>
<p>Pro zájemce, tutorilál práce s vim: <a href="https://www.openvim.com/">zde</a></p>
</details>
<h2><a class="header" href="#instalace-ros-cca-45min" id="instalace-ros-cca-45min">Instalace ROS (cca 45min)</a></h2>
<p>Projděte si návod na <a href="cviceni/../chap_1_software/text/ros.html">Robotic Operating System</a>. Zde si nastudujte přibližný princip fungování systému ROS aby jste později chápali jeho základní mechanizmy. </p>
<p>Podle návodu si nainstalujte ROS na svůj čerstně nainstalovaný operační systém.</p>
<p>Detailní přednáška na práci s ROSem bude v druhé polovině semestru.</p>
<p>✅ Zavolejte z terminálu příkaz roscore. Měl by se objevit výpis o startu programu. Neměly by být přítomny žádné chybové hlášky</p>
<p>✅ Voláním přžíkazu rviz ověřte, že Vám nastartuje vizualizařní program RVIZ (paralelně musí běžet roscore).</p>
<h2><a class="header" href="#instalace-clion-cca-30-min" id="instalace-clion-cca-30-min">Instalace CLion (cca 30 min)</a></h2>
<p>Z <a href="https://www.jetbrains.com/clion/">oficiálního webu</a> si stáhněte IDE CLion a seznamte se s ním (viz <a href="cviceni/../chap_1_software/text/clion.html">CLion IDE</a>). Registrací pomocí školního emailu získáte licenci na užití softwaru zdarma.</p>
<p>✅ Pouze prací v konzole si vytvořte jednoduchý hello world program a zkompilujte jej pomocí volání g++ kompilátoru. Otestujte funkčnost programu.</p>
<p>✅ Tentýž hello world program realizujte ve vývojovém prostředí CLion. Zkompilujte jej a ověřte jeho funkčnost.</p>
<p>✅ Diskutujte výhody práce s IDE oproti kompilaci v příkazovém řádku.</p>
<h3><a class="header" href="#záložní-plán" id="záložní-plán">Záložní plán</a></h3>
<p>Předinstalovaný obraz Ubuntu 20.04 s ROSem pro VB</p>
<p>https://drive.google.com/file/d/1_wCduSS30O7lHB2oYQVEErgrPAWc1ALR/view?usp=sharing</p>
<h1><a class="header" href="#git-simulátor" id="git-simulátor">GIT, simulátor</a></h1>
<p>Cvičící: Ing. Adam Ligocki</p>
<h2><a class="header" href="#git-cca-1-hod" id="git-cca-1-hod">GIT (cca 1 hod)</a></h2>
<p>Zaregistrujte se na studentském <a href="https://student.robotika.ceitec.vutbr.cz/">GitLab serveru</a></p>
<p>Tento server bude po zbytek kurzu BPC-PRP Vás tzv. &quot;origin&quot;, tedy vzdálené repozitář.</p>
<p>Vyučující mají náhled do všech Vaších repozitářů, včetně jejich historii a mohou přůběžně sledovat Vaší práci, případně kdo, kdy a jak intenzivně &quot;commitoval&quot;.</p>
<p>Na serveru si vytvořte repozitář, ve kterém budete udržovat kód po zbytek kurzu.</p>
<p>V rámci týmu si vyzkoušejte následujicí cvičení.</p>
<p>✅ Jeden člen vytvoří repozitář na serveru.</p>
<p>✅ Všichni členové si naklonují repozitár k sobě na PC.</p>
<p>✅ Jeden člen týmu vytvoří na lokále hello world program a &quot;commitne&quot; jej, a &quot;pushne&quot; jej na origin.</p>
<p>✅ Zbytek týmu si &quot;pullne&quot; změny k sobě na lokál.</p>
<p>✅ Dva členové týmu si skusí vyrobit konflikt tak, že zároveň změní stejný řádek v kódu a pokusí se jej pushnout na server. Druhému v pořádí, který se pokusí o push, git zahlásí chybu.</p>
<p>✅ Nešťastný člen týmu, který má nahlášený konflikt, se pokusí o jeho &quot;fix&quot; a opravenou verzi pushne na origin.</p>
<p>✅ Všichni členové týmu si pullnou aktuální verzi repozitáře. A každý člen týmu si vyrobí vlastní .h soubor a v něm funkci, která vytiskne jeho jméno. Všichni pushnou změny na server.</p>
<p>✅ Jeden člen týmu si pullne nově vytvořené .h soubory a upraví hello world program tak aby využíval všechen nově vytvořený kód. Změny pushne na origin.</p>
<p>✅ Všichni si pullnou aktuální stav repozitáře.</p>
<h2><a class="header" href="#simulátor-cca-30-min" id="simulátor-cca-30-min">Simulátor (cca 30 min)</a></h2>
<p>Ze <a href="https://github.com/Robotics-BUT/BPC-PRP">stránek kurzu</a> si pullněte aktuální stav repozitáře.</p>
<p>Repozitář obsahuje ve složce &quot;bin/&quot; skompilovanou binárku simulátoru nazvanou &quot;simulator&quot;. Pokud máte korektně nainstalovaný ROS, otevřete si 3 terminály</p>
<details>
    <summary>Tip pro práci s více terminály</summary>
<br>
Pro práci s více okny terminálů je dobré si nainstalovat pomocí balíčkovacího manažeru program "terminator". Ten Vám umožní v jednom okně mít otevřených více terminálu.
</details>
<br>
<details>
    <summary>Vím jak se pracuje s balíčkovacím manažerem, jen potřebuji osvěžit paměť.</summary>
<br>
sudo apt install terminator
</details>
<br>
<p>Ve složce &quot;resources/&quot; naleznete soubor config.yaml. Z něj si bude simulátor načítat hodnoty pro Vaší simulaci, mezi jinými nastavení síťové komunikace, simulované rozměry robota, parametry podvozku, rozmístění snímačů, a hlavně cestu k mapě, se kterou bude simulátor pracovat. Tu si upravte pro svůj vlastní souborový systém.</p>
<p>Dále se ve slořce serources nachází také jedna vzorová mapa. Nahlédněté do ní a všiměnte si struktury YAML dat. Nachází se zde informace o šířce čáry a následně je zde pole úseček definovaných vždy [bod1_x, bod1_y, bod2_x, bod2_y]. V budoucnu si budete vytvářet taky vlastní mapy.</p>
<p>✅ Nastavte si v souboru config.yaml validní cestu k mapě route_1.yaml.</p>
<p>✅ Po změně obsahu souboru si vyzkoušejte validitu yamlu souboru v <a href="http://www.yamllint.com/">online nástroji</a>.</p>
<p>Nyní zbývá si vyzkoušet oživit celý systém.</p>
<p>✅ V 1. terminále zapněte roscore</p>
<p>✅ V 2. terminále spusťte binárku simulátoru, jako argument programu přidejte absolutní cestu ke konfiguračnímu souboru, který jste dříve editovali.</p>
<p>✅ V 3. terminále zapněte rviz a přidejte si vizualizaci topicků </p>
<h3><a class="header" href="#konfigurace-rvizu" id="konfigurace-rvizu">Konfigurace RVizu</a></h3>
<p><img src="cviceni/../images/rviz_1.jpg" alt="empty RViz" /></p>
<p>Pokud běží simulátor, v levé dolní sekci tlačítkem &quot;ADD&quot; otevřete okno pro přidání vizualizací.</p>
<p><img src="cviceni/../images/rviz_2.jpg" alt="RViz add topic by display type" /></p>
<p>V záložce &quot;By Display Type&quot; vyberte položku &quot;TF&quot; a dvojitým polikem jí přidejte do zobrazení. Dále v levé horní části v záložce &quot;Global Options&quot; nastavte položku &quot;Fixed Frame&quot; na hodnotu &quot;origin&quot;. Tímto jsme RVizu řekli, že má zobrazovat souřadný systém &quot;origin&quot; a vůči němu vykreslovat všechny ostatní souřadné systémy, se kterými simulátor pracuje.</p>
<p>Opětovně otevřete okno pro přidání vizualizací a přejděte do záložky &quot;By Topic&quot;. </p>
<p><img src="cviceni/../images/rviz_3.jpg" alt="RViz add topic by topic" /></p>
<p>Postupně si přidejte všenchy vizualizace markerů pod topicky:</p>
<ul>
<li>/bpc_prp/line</li>
<li>/bpc_prp/robot_body</li>
<li>/bpc_prp/sensors</li>
<li>/bpc_prp/wheels/left</li>
<li>/bpc_prp/wheels/right</li>
</ul>
<p>Ihned po přidání nové vizualizace si jí můžete přejmenovat použitím tlačítka &quot;Rename&quot; na penelu vlevo dole.</p>
<p>✅ Výsledek by měl vypadat následovně:</p>
<p><img src="cviceni/../images/prp_1.jpg" alt="RViz Ready" /></p>
<p>Současné nastavení RVizu uložíte klávesovou zkratkou CTRL+S</p>
<p>✅ Prozkoumejte další možnosti nastavení vizualizací v RVizu, jako velikost mříždy, průhlednost, barva pozadí, atd.</p>
<h1><a class="header" href="#udp-komunikace" id="udp-komunikace">UDP komunikace</a></h1>
<p>Cvičící: Ing. Tomáš Lázna</p>
<h2><a class="header" href="#založení-projektu-cca-10-minut" id="založení-projektu-cca-10-minut">Založení projektu (cca 10 minut)</a></h2>
<p>Zapněte CLion a vytvořte nový projekt (File &gt; New Project) typu <em>C++ Executable</em>. Zvolte umístění a název svého projektu (např. jméno týmu) a <em>Language standard</em> nastavte na <em>C++17</em>.</p>
<p>CLion by vám měl generovat prázdnou šablonu C++ aplikace. V prvé řadě budeme editovat soubor <em>CMakeLists.txt</em>, abychom kompilátoru řekli, kde má hledat hlavičkové a zdrojové soubory. 
Doporučuji si v adresářové struktuře projektu vytvořit složku <em>include</em> pro umístění .h souborů a složku <em>src</em> pro .cpp soubory (včetně <code>main.cpp</code>, který je defaultně v rootu projektu). 
Zároveň si k projektu přilinkujeme knihovny pro práci s YAML soubory pro načítání konfiguračních souborů (volitelné) a pro práci s vlákny (rovněž volitelné). Soubor by měl mít následující strukturu:</p>
<pre><code>cmake_minimum_required(VERSION 3.17)
project(bpc_prp_cool_name)

set(CMAKE_CXX_STANDARD 17)

find_package(Yaml-cpp)
find_package(Threads REQUIRED)

include_directories(include)

set(SOURCES
        src/main.cpp
        src/cool_code.cpp
        src/another_source_file.cpp)

add_executable(bpc_prp_cool_name ${SOURCES})
target_link_libraries(bpc_prp_cool_name yaml-cpp Threads::Threads) 
</code></pre>
<p>Pokud CMake nereloaduje konfiguraci automaticky, v CLionu vám vyskočí panel <em>CMake project needs to be reloaded</em>, kliknete na tlačítko <em>Reload changes</em>.</p>
<h2><a class="header" href="#zpracování-nmea-zpráv-cca-1-hodina" id="zpracování-nmea-zpráv-cca-1-hodina">Zpracování NMEA zpráv (cca 1 hodina)</a></h2>
<p>Komunikace se simulátorem probíhá formou NMEA zpráv posílaných přes UDP protokol. Pro sestavení, kontrolu a parsování NMEA zpráv je výhodné si vytvořit sadu utilitárních metod a zabalit je do třídy. Přikládám návrh deklarace
4 metod, kterým se můžete (ale nemusíte) inspirovat, pozornost věnujte zejména vstupním a návratovým typům:</p>
<pre><code>std::string string_to_nmea_message(const std::string&amp; message);
uint16_t get_message_checksum(const std::string&amp; message);
std::string extract_nmea_message_content(const std::string&amp; nmea_message);
bool is_nmea_message_valid(const std::string&amp; nmea_message);
</code></pre>
<p>Obecně je v C++ dobrým nápadem předávat metodám objekty, které nechcete modifikovat, jako konstantní reference (const type&amp;), tím pádem se funkci předá jen odkaz na daný objekt (nemusí se kopírovat) 
a přitom se (díky const) chráníte před tím, abyste omylem objekt modifikovali.</p>
<p>Metody můžete definovat jako statické, tj. pro jejich volání nebude nutné vytvářet instanci třídy.</p>
<p>Pozn. Struktura NMEA zprávy je následující:</p>
<pre><code>$MESSAGE_TYPE,PARAMETERS,SEPARATED,BY,COMMAS*checksum
</code></pre>
<p>Checksum je dvoučíslicové hexadecimální číslo (tj. v rozsahu 0-255), které vznikte jako bitová nonekvivalence (XOR) ASCII kódů všech znaků mezi $ a * (ty nejsou zahrnuty).</p>
<p>Následuje příklad volání jednotlivých metod s očekávanými výstupy tak, abyste si mohli ověřit správnost své implementace.</p>
<pre><code>string_to_nmea_message(&quot;PING,HELLO&quot;) -&gt; &quot;$PING,HELLO*7E&quot;
get_message_checksum(&quot;RESET,&quot;) -&gt; 121 (= 79 v hexa)
extract_nmea_message_content(&quot;$PONG,HELLO*78&quot;) -&gt; &quot;PONG,HELLO&quot;
is_nmea_message_valid(&quot;$PONG,HELLO*78&quot;) -&gt; true
is_nmea_message_valid(&quot;$PONG,HELLO*AA&quot;) -&gt; false
</code></pre>
<p>Pozn. Pro sestavování a parsování C++ řetězců (<code>std::string</code>) doporučuji využít třídu <code>std::stringstream</code> ze standardní knihovny <code>&lt;stringstream&gt;</code>.</p>
<p>Úspěšná implementace metod pro práci s NMEA zprávami je nutnou podmínkou pro úspěšnou komunikaci se simulátorem v dalším kroku.</p>
<h2><a class="header" href="#udp-komunikace-přes-socket-api-cca-40-minut" id="udp-komunikace-přes-socket-api-cca-40-minut">UDP komunikace přes socket API (cca 40 minut)</a></h2>
<p>Komunikace se simulátorem je realizována ve formě UDP paketů, které budeme odesílat a přijímat pomocí socket API, které je k dispozici ve standardních C knihovnách.</p>
<p>Pro úspěšné fungování je nutné includovat několik hlavičkových souborů:</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
</code></pre>
<p>Pro inicializaci socketu zavoláme funkci <code>socket</code>, která má následující předpis:</p>
<pre><code>int fd = socket(int domain, int type, int protocol);
</code></pre>
<p>Ve filosofii jazyka C se se sockety pracuje jako se soubory (lze do nich zapisovat a číst z nich), proto funkce vrací celé číslo <em>file descriptor</em>, pomocí kterého se daný socket referencuje dále v kódu.</p>
<p>Nápovědu k tomu, s jakými parametry socket inicializovat naleznete v dokumentaci funkce <code>socket</code> - budeme pracovat v doméně IPv4 a typem bude UDP (připomeňte si, co tato zkratka znamená). 
V běžných případech (jako i tento) je protokol již definován prostřednictvím typu, třetí parametr tedy může být nastaven na 0.</p>
<p>Korektní je po skončení práce se socketem jej uzavřít pomocí volání:</p>
<pre><code>close(fd)
</code></pre>
<h3><a class="header" href="#odesílání-zpráv" id="odesílání-zpráv">Odesílání zpráv</a></h3>
<p>Existují v zásadě dvě varianty, jak odesílat UDP zprávy. </p>
<ol>
<li>Datagramy je možné posílat i přes tzv. nepojmenované sockety (nemají přiřazenou žádnou adresu a port), přičemž adresát je specifikován ve volání funkce <code>sendto</code>. 
Pro pojmenování příjemce využijeme strukturu <code>sockaddr_in</code>, a to následujícím způsobem:</li>
</ol>
<pre><code>struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_addr.s_addr = inet_addr(&quot;ip.adresa.pri.jemce&quot;);
addr.sin_port = htons(11111);
</code></pre>
<p>Odeslání zprávy je realizováno následujícím voláním:</p>
<pre><code>std::string msg = &quot;message&quot;;
ssize_t no_of_sent_bytes = sendto(fd, msg.c_str(), msg.length(), 0, (struct sockaddr *) &amp;addr, sizeof(addr));
</code></pre>
<p>Funkci jsou předány tyto parametry: deskriptor socketu, obsah zprávy (typ char* = řetězec v C), délka zprávy, příznaky (flags), struktura s popisem adresáta, velikost této struktury. Vrácen je počet odeslaných bytů.</p>
<ol start="2">
<li>Pokud komunikuji opakovaně se stejným příjemcem, je možné socket tzv. pojmenovat a odesílání realizovat funkcí <code>send</code>, která nevyžaduje strukturu s adresátem (tato informace bude již předána přes deskriptor socketu).
Způsob pojmenování závisí na tom, zda je vaše aplikace klientem (aktivně se připojuje k jinému socketu) nebo serverem (naopak čeká, než se jiný socket připojí k vašemu). Pro variantu klienta použijeme funkci <code>connect</code>:</li>
</ol>
<pre><code>int res = connect(fd, (struct sockaddr *) &amp;addr, sizeof(addr));
</code></pre>
<p>Funkci jsou předány tyto parametry: deskriptor socketu, struktura s popisem serveru, velikost této struktury. V případě úspěchu je vrácena 0, při chybě -1.</p>
<p>Varianta serveru bude popsána později v sekci Přijímání zpráv, využívá se funkce <code>bind</code>.</p>
<p>K odeslání zprávy slouží následující volání:</p>
<pre><code>std::string msg = &quot;message&quot;;
ssize_t no_of_sent_bytes = send(fd, msg.c_str(), msg.length(), 0);
</code></pre>
<p>Parametry a návratová hodnota jsou analogické s funkcí <code>sendto</code>.</p>
<p>Při využití pojmenovaného socketu může nastat situace, kdy se spojení přeruší, v takovém případě je nutné jej obnovit opětovným voláním funkce <code>connect</code>. </p>
<h3><a class="header" href="#přijímání-zpráv" id="přijímání-zpráv">Přijímání zpráv</a></h3>
<p>Socket je před přijímáním zpráv nutné pojmenovat, a to pomocí funkce <code>bind</code>, kterou socketu sdělíme, přes jaké rozhraní má komunikovat: </p>
<pre><code>int res = bind(fd, (struct sockaddr *) &amp;addr, sizeof(addr));
</code></pre>
<p>Můžete si povšimnout, že volání je stejné jako v případě funkce <code>connect</code>. V případě úspěchu je vrácena 0, při chybě -1.</p>
<p>Pro pojmenování rozhraní využijeme opět strukturu <code>sockaddr_in</code>, a to následujícím způsobem:</p>
<pre><code>struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_addr.s_addr = htonl(INADDR_ANY);
addr.sin_port = htons(22222);
</code></pre>
<p>Všimněte si rozdílu na 3. řádku, kdy tentokrát nespecifikujeme konkrétní adresu, ale pomocí <code>INADDR_ANY</code> říkáme, že chceme přijímat zprávy přes libovolné místní síťové rozhraní.</p>
<p>Příjem zprávy je poté realizován následujícím voláním:</p>
<pre><code>unsigned char buffer[100];
socklen_t senderlen = sizeof(addr);

ssize_t no_of_received_bytes = recvfrom(fd, buffer, sizeof(buffer), 0, (struct sockaddr *) &amp;addr, &amp;senderlen);
std::string received_message(buffer, buffer + no_of_received_bytes);
</code></pre>
<p>Funkci jsou předány tyto parametry: deskriptor socketu, buffer pro příjem, délka bufferu, příznaky (flags), struktura s popisem rozhraní, <em>ukazatel</em> na velikost této struktury. Vrácen je počet přijatých bytů. 
Volání je obdobné jako v případě <code>sendto</code>, všimněte si ale, že tentokrát předáváme referenci na délku struktury, ne přímo délku; to proto, že funkce <code>recvfrom</code> do struktury zapisuje údaje o odesilateli zprávy 
a může její délku změnit.</p>
<p>Je-li socket správně nabindován/připojen a neřešíme konflikt s více odesilateli, které bychom potřebovali rozlišit pomocí struktury <code>sockaddr_in</code>, můžeme přijímat zjednodušeným způsobem pomocí funkce <code>recv</code>. 
K příjmu zprávy poté slouží následující volání:</p>
<pre><code>ssize_t no_of_received_bytes = recv(fd, buffer, sizeof(buffer), 0);
</code></pre>
<p>Parametry a návratová hodnota jsou analogické s funkcí <code>recvfrom</code>.</p>
<h2><a class="header" href="#testování-komunikace-se-simulátorem-cca-10-minut" id="testování-komunikace-se-simulátorem-cca-10-minut">Testování komunikace se simulátorem (cca 10 minut)</a></h2>
<p>Jak již bylo řečeno, se simulátorem komunikujeme UDP protokolem pomocí NMEA zpráv. V případě, že simulátor máte spuštěný na stejném stroji jako svůj program (což vřele doporučuji), budete zprávy odesílat na adresu <em>localhostu</em> 
(127.0.0.1). Simulátor komunikuje na portech specifikovaných v souboru <code>config.yaml</code>, vypíše je do konzole po spuštění. Všimněte se, že příjem a odesílání dat probíhá na jiných portech, budete tedy potřebovat dva sockety.</p>
<p>Základní fungování komunikace můžete ověřit pomocí zprávy <code>PING,&lt;dalsi-parametry&gt;</code>. Po přijetí vám simulátor vrátí zprávu <code>PONG,&lt;dalsi-parametry&gt;</code>.</p>
<p>Pozn. Simulátor očekává, že všechny příchozí zprávy mají minimálně dva segmenty (tj. minimálně jednu čárku), proto nestačí poslat pouze <code>PING</code>.</p>
<p>✅ Na konci cvičení musíte být schopní odeslat do simulátoru zprávu Ping a vypsat do konzole odpověď extrahovanou z NMEA zprávy (tj. bez znaků $, * a checksumu).</p>
<p>Doporučujeme, abyste dbali na kulturu kódu a používali třídy. Komunikace bude fungovat i pokud veškerý potřebný kód zahrnete do souboru <code>main.cpp</code>, ale s tímto přístupem by v brzké budoucnosti funkce <code>main</code> rychle nabobtnala
a stala se těžko přehlednou. Pokud se budete řídit příklady dobré praxe od počátku projektu, bude vás to na začátku stát více času, ale v pozdějších fázích jej naopak budete šetřit.</p>
<h2><a class="header" href="#bonus-vyčtení-dat-ze-senzorů" id="bonus-vyčtení-dat-ze-senzorů">Bonus: vyčtení dat ze senzorů</a></h2>
<p>Vyzkoušejte další zprávy pro komunikaci se simulátorem, které vrací hodnoty ze senzorů:</p>
<p>✅ Zpráva <code>SENSOR,&lt;id&gt;</code> posílá požadavec na měření senzoru číslo <code>&lt;id&gt;</code> (indexováno od nuly).</p>
<p>✅ Zprávy <code>LODO</code> a <code>RODO</code> posílají požadavek na zjištění ujeté vzdálenost levého, resp. pravého motoru.</p>
<p>✅ Ve zbývajícím čase můžete začít pracovat na funkci, která rozdělí příchozí zprávu na segmenty (oddělené čárkou) a převede texty na čísla (v závislosti na typu zprávy).</p>
<h1><a class="header" href="#Řízení-motorů" id="Řízení-motorů">Řízení motorů</a></h1>
<p>Cvičící: Bc. Matouš Hýbl, Ing. Lukáš Kopečný Ph.D.</p>
<h2><a class="header" href="#cile" id="cile">Cile</a></h2>
<ul>
<li>Rozpohybovat kola simulovaneho robota tak, aby bylo mozne ridit jeho pohyb pomoci kinematiky.</li>
<li>Zprovoznit cteni ujete drahy jednotlivych motoru.</li>
</ul>
<h2><a class="header" href="#prerekvizity" id="prerekvizity">Prerekvizity</a></h2>
<ul>
<li>Funkční komunikace se simulátorem (ověřit pomocí zprávy <code>PING</code>)</li>
<li>Funkční parsování NMEA řetězců
&gt;</li>
</ul>
<h2><a class="header" href="#reset-simulátoru" id="reset-simulátoru">RESET simulátoru</a></h2>
<p>V tomto cvičení již budete ovládat robota v simulátoru, je tedy nutné pravidelně navracet simulátor do výchozího stavu.
Toho lze dosáhnout jak opětovným spuštěním jak simulátoru, tak vašeho programu, lze to ale řešit přímočařeji, a to tak, že při startu vašeho programu simulátoru pošlete NMEA zprávu pro reset, tedy <code>$RESET,*CHKSUM</code>.</p>
<p>✅ Po odeslání resetu byste měli přijmout NMEA zprávu začínající slovy <code>$RESET,DONE</code>.</p>
<h2><a class="header" href="#ovladání-motorů-v-simulátoru" id="ovladání-motorů-v-simulátoru">Ovladání motorů v simulátoru</a></h2>
<p>Simulátor simuluje chování dvou krokových motorů, na které jsou namonotována kola uživatelsky definovaného průměru.
Motory jsou řízeny každý separátně pomocí NMEA zpráv posílaných simulátoru.</p>
<p>Zprávy, kterými lze řídit motory jsou následující:</p>
<table><thead><tr><th>příkaz</th><th>parametr</th><th>význam</th></tr></thead><tbody>
<tr><td>LSPEED</td><td>float rychlost levého motoru v microstepech za sekundu</td><td>nastaví rychlost levého kola na požadovanou hodnotu</td></tr>
<tr><td>RSPEED</td><td>float rychlost pravého motoru v microstepech za sekundu</td><td>nastaví rychlost pravého kola na požadovanou hodnotu</td></tr>
<tr><td>LODO</td><td>-</td><td>posílá požadavek na zjištění ujeté vzdálenosti levého motoru v microstepech od posledního zavolání tohoto příkazu, hodnota je interně ukládána jako 64b int</td></tr>
<tr><td>RODO</td><td>-</td><td>posílá požadavek na zjištění ujeté vzdálenosti pravého motoru v microstepech od posledního zavolání tohoto příkazu, hodnota je interně ukládána jako 64b int</td></tr>
</tbody></table>
<p>Zde stojí za zmínku podivné nastavování rychlosti v microstepech za sekundu.
Jak jistě víte krokový motor se s každým impulzem na vinutích posunuje o 1 krok (step).</p>
<p>✅ Počet kroků na otáčku je vlastností daného krokového motoru.</p>
<p>Tyto kroky je ale možné interpolovat, každý krok se tedy rozdělí na X tzv. mikrokroků (microstepů).</p>
<p>✅ Mikrostepování a množství jeho úrovní je vlastností použitého driveru motorů.
<br/><br/><br/>
✅ Z datasheetu motoru byste zjistili, že rozměr kroku je 1.8°, na plnou otáčku tedy připadá kolik kroků?</p>
<details>
    <summary>Odpověď</summary>
    360 / 1.8 = 200
</details>
<br/><br/><br/>
✅ Zadaný driver motorů má interpoluje krok do 32 mikrokroků, kolik mikrokroků připadá na celou otáčku?
<details>
    <summary>Odpověď</summary>
    200 * 32 = 6400
</details>
<br/><br/>
Pokud řídíme reálné fyzikální systémy je vhodné programova pomocí reálných fyzikálních jednotek a vždy to dodržovat, nestane se nám tak, že nebudeme vědět jaký rozměr má nějaká proměnná.
<p>Zvolme si tedy, že požadovaným vstupem do našeho softwareového driveru motorů bude úhlová rychlost zadaná v otáčkách za sekundu a tuto rychlost máme převést na microstepy za sekundu. Jak to provedeme?</p>
<details>
    <summary>Odpověď</summary>
    float speedInMicrosteps = targetSpeed * microstepsPerRevolution
</details>
<br/><br/>
<h3><a class="header" href="#posílaní-řídicích-zpráv" id="posílaní-řídicích-zpráv">Posílaní řídicích zpráv</a></h3>
<p>Nezbytnou teorii máme za sebou, pusťme se tedy do samotného programování.
Z tabulky výše víme, že příkaz pro nastavení rychlosti levého motoru je <code>LSPEED</code>.
Pošleme tedy tento příkaz simulátoru s nějakou malou rychlostí, třeba 0.05 otáčky za sekundu.</p>
<p>✅ Pokud nám vše správně funguje, měl by se robot v simulátoru začít pomalu otáčet.</p>
<p>Motor se po asi 1 s otáčení zastaví, toto je bezpečnostní funkce, která je implementována v našich reálných driverech. 
V případě softwareové chyby, kdy by spadl řídicí program, by se totiž robot mohl nekontrolovatelně rozjet. 
Je tedy nutné řídicí příkazy posílat pořád.</p>
<p>Nyní zkusme nastavit rychlost motoru na nějakou velkou rychlost, třeba 1 otáčku za sekundu. Co se stane?</p>
<details>
    <summary>Odpověď</summary>
    Robot stojí na místě. Je to proto, že tímto simulujeme reálnou vlastnost mechanických systémů a zvláště krokových motorů, které mají nízký kroutící moment ve vysokých otáčkách, ale vysoký v nízkých.
    Tento problém je nutné řešit takzvaným generátorem ramp, který zajistí, že zrychlování/zpomalování motoru bude probíhat postupně po definovaných přírustcích rychlosti.
</details>
<h3><a class="header" href="#generování-ramp" id="generování-ramp">Generování ramp</a></h3>
<p>Jak jsme si ukázali v minulé části, s krokovým motorem nelze zrychlovat s neomezenou akcelerací, je teda nutné zrychlovat postupně s konstantním malým zrychlením.</p>
<p>Implementací tohoto postupuje takzvané generování ramp, které v průběhu času generuje z požadované rychlosti a diference rychlosti v každém kroku momentální rychlost motoru. V tomto cvičení budeme implementovat jednoduchý generátor trapézoidních ramp.</p>
<p>✅ Algoritmus takového generátoru je prostý. V každém kroku k momentální rychlosti motoru přičteme požadovanou diferenci rychlosti se stejným znaménkem jako má rozdíl <code>požadovaná rychlost - momentální rychlost</code>.</p>
<p>Pro implementaci lze jako návod použít následující modelovací schéma.
<img src="cviceni/../images/ramp_gen.jpg" alt="Generator Ramp" /></p>
<p>Toto opakujeme ve smyčce s frekvencí která odpovídá tomu jak rychle chceme provádět zrychlování na požadovanou hodnotu.</p>
<p>Generátor rampy, který běží periodicky pořád, nám efektivně řeší problém s opakováním řídicích zpráv pro motory, stačí periodicky získávat novou hodnotu rychlosti z generátoru ramp a tu posílat simulátoru.</p>
<p>✅ Pro programování separátních smyček pro generování ramp lze s výhodou použít separátní vlákno, je ale nutné pamatovat na správnou synchronizaci přístupu ke sdíleným prostředkům - není například možné, aby dvě vlákna současně posílala příkazy simulátoru.</p>
<p>✅ Maximální rychlost motorů je zasaturována v simulátoru, pokuste se najít maximální rychlost, které jste schopni dosáhnout.</p>
<h2><a class="header" href="#Čtení-ujeté-vzdálenosti" id="Čtení-ujeté-vzdálenosti">Čtení ujeté vzdálenosti</a></h2>
<p>Pro lokalizaci robota v prostředí lze využít výpočtu odometrie z ujeté vzdálenosti obou kol, to bude předmětem dalších cvičení, je ale vhodné si to již teď připravit.
Čtení ujeté vzdálenost je v simulátoru implementováno pomocí příkazů <code>LODO</code> a <code>RODO</code>. Tyto příkazy spůsobí, že nám simulátor pošle ujetou vzdálenost v mikrostepech a sám si vnitřní hodnotu ujeté vzdálenosti vynuluje.</p>
<p>✅ Vyzkoušejte si čtení ujeté vzdálenosti jednotlivých a jejich přepočet na metry.</p>
<p>✅ Vyzkoušejte si, že se hodnota ujeté vzdálenosti opravdu nuluje.</p>
<h2><a class="header" href="#očekávané-výstupy-práce-v-tomto-cvičení" id="očekávané-výstupy-práce-v-tomto-cvičení">Očekávané výstupy práce v tomto cvičení</a></h2>
<p>✅ Jste schopni ovládat oba motory simulovaného robota v plném rozsahu rychlostí.</p>
<p>✅ Máte naimplementováno generování ramp pro oba motory.</p>
<p>✅ Jste schopni ze simulátoru získávat data o ujeté vzdálenosti pro oba motory.</p>
<p>﻿# Snímání čáry
Cvičící: Ing. Tomáš Jílek, Ph.D.</p>
<h2><a class="header" href="#cíle" id="cíle">Cíle</a></h2>
<ul>
<li>Realizovat zpracování signálu z emulovaného optočlenu CNY70.</li>
<li>Implementovat výpočet pozice/orientace čáry vzhledem k ose jízdy robotu s využitím jednoho nebo více emulovaných optočlenů CNY70.</li>
</ul>
<h2><a class="header" href="#prerekvizity-1" id="prerekvizity-1">Prerekvizity</a></h2>
<ul>
<li>Funkční komunikace se simulátorem (ověřit pomocí zprávy <code>PING</code>).</li>
<li>Funkční parsování NMEA řetězců.</li>
<li>Funkční ovládání motorů.</li>
<li>Funkční vyčítání dat z emulovaného KM2 pro výpočet odometrie.</li>
<li>Znalost práce s daty v MATLABu/GNU Octave/Excelu nebo jiném SW pro analýzu dat.</li>
</ul>
<h2><a class="header" href="#výstupy" id="výstupy">Výstupy</a></h2>
<ul>
<li>Spolehlivě fungující měření pozice vodicí čáry vzhledem k ose jízdy robotu s jedním optočlenem CNY70.</li>
<li>Základní verze měřicího systému složeného z více optočlenů CNY70 (např. diferenční zapojení se 2 ks CNY70).</li>
</ul>
<h2><a class="header" href="#odevzdání-výsledku-řešení-cvičení-do-pátku-2-dubna-2021" id="odevzdání-výsledku-řešení-cvičení-do-pátku-2-dubna-2021">Odevzdání výsledku řešení cvičení (do pátku 2. dubna 2021)</a></h2>
<ul>
<li>Do 'odevzdávací' složky v repozitáři Vašeho projektu uložte:
<ul>
<li>graf změřené převodní charakteristiky samotného senzoru bez jakéhokoliv zpracování,</li>
<li>graf převodní charakteristiky senzoru po Vašem zpracování,</li>
<li>textový soubor formátovaný v jazyce Markdown, který krátce popisuje Vámi zvolený způsob zpracování dat ze senzoru a odkazuje se na dva předchozí grafy (krátká technická zpráva, rozsah postačí ekv. 1/2 A4, mnohem důležitější je úroveň obsahu, než množství textu).</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#Úkol-č-1-realizace-měření-převodní-charakteristiky-senzoru-cny70" id="Úkol-č-1-realizace-měření-převodní-charakteristiky-senzoru-cny70">Úkol č. 1: Realizace měření převodní charakteristiky senzoru CNY70</a></h2>
<p>Proveďte implementaci automatizovaného měření převodní charakteristiky emulovaného senzoru CNY70. Jedná se o závislost <code>u_raw=f(dD)</code> nebo <code>u_raw=f(dA)</code>, kde <code>u_raw</code> je celočíselná hodnota reprezentující měřené napětí, která je získána z AD převodníku s 12 bitovým registrem pro uložení výsledku AD převodu. Veličina <code>dD</code> odpovídá délkové odchylce senzoru od vodicí čáry. Veličina <code>dA</code> odpovídá úhlové odchylce senzoru od vodicí čáry.</p>
<p>Hodnotu, která je výsledkem A/D převodu, získáte pomocí NMEA zprávy <code>SENSOR</code>, která je ve formátu: <code>$SENSOR,&lt;id&gt;*&lt;chksum&gt;</code>, kde <code>id</code> odpovídá pořadovému číslu senzoru, který je součástí robotu. Senzory jsou indexované od nuly. Registr, ze kterého jsou data čteny, je 12bitový. Skutečné rozlišení převodníku je ale pouze 10bitové, spodní 2 bity jsou tedy vždy nulové. Emulátor navrací zprávu <code>$SENSOR,&lt;id&gt;,&lt;value&gt;*&lt;chksum&gt;</code>, kde <code>value</code> je celočíselná hodnota, která je výsledkem A/D převodu.</p>
<h3><a class="header" href="#možný-způsob-řešení-nápověda" id="možný-způsob-řešení-nápověda">Možný způsob řešení (nápověda)</a></h3>
<p>Charakteristiku <code>u_raw=f(dD)</code> můžete získat např. tak, že robotem nakolmo přejedete čáru a uložíte si změřené hodnoty <code>u_raw</code>, <code>dGamma1</code> a <code>dGamma2</code>. <code>dGamma1</code> a <code>dGamma2</code> jsou počty mikrokroků ujeté každým kolem během příslušné periody vzorkování. Charakteristiku <code>u_raw=f(dA)</code> můžete získat obdobným způsobem, t.j. robot stojí na místě a otáčí se kolem své osy.</p>
<h2><a class="header" href="#Úkol-č-2-návrh-detekčního-systému-s-jedním-optočlenem-cny70-pro-měření-pozice-čáry-vzhledem-k-ose-jízdy-robotu" id="Úkol-č-2-návrh-detekčního-systému-s-jedním-optočlenem-cny70-pro-měření-pozice-čáry-vzhledem-k-ose-jízdy-robotu">Úkol č. 2: Návrh detekčního systému s jedním optočlenem CNY70 pro měření pozice čáry vzhledem k ose jízdy robotu</a></h2>
<p>Navrhněte vlastní systém pro měření pozice čáry s využitím optočlenu CNY70. Pro snažší pochopení chování optočlenu v uvedené aplikaci Vám může pomoci proměření vlivu vzdálenosti odrazné roviny na převodní charakteristiku. Umístěte senzor na robot tak, aby bylo možné snímat vychýlení optočlenu od osy vodící čary v co největším rozsahu a současně spolehlivě! Výstupní hodnotu algoritmu pro zpracování měřených dat kalibrujte v metrech příp. milimetrech.</p>
<h2><a class="header" href="#Úkol-č-3-návrh-detekčního-systému-s-více-optočleny-cny70-pro-měření-poziceorientace-čáry-vzhledem-k-ose-jízdy-robotu" id="Úkol-č-3-návrh-detekčního-systému-s-více-optočleny-cny70-pro-měření-poziceorientace-čáry-vzhledem-k-ose-jízdy-robotu">Úkol č. 3: Návrh detekčního systému s více optočleny CNY70 pro měření pozice/orientace čáry vzhledem k ose jízdy robotu</a></h2>
<p>Pro zvýšení měřicího rozsahu a robustnosti měření je možné použít více optočlenů CNY70, které budou vhodně prostorově rozmístěny. Nejprve je doporučeno vyzkoušet diferenční zapojení dvou optočlenů a až potom se pouštět do sofistikovanějších zapojení s více optočleny.</p>
<p>Při návrhu měřicího systému vhodného pro detekci pozice/orientace vodicí čáry je doporučeno zvážit minimálně tyto parametry/vlastnosti:</p>
<ul>
<li>minimální počet potřebných optočlenů CNY70,</li>
<li>prostorové rozmístění optočlenů CNY70 (jejich souřadnice <code>x</code>, <code>y</code>, <code>z</code> v souřadnicovém systému robotu),</li>
<li>linearizace převodní charakteristiky jednotlivých optočlenů/celého detekčního systému,</li>
<li>kalibrace jednotlivých optočlenů (statická - po zapnutí / dynamická - po celou dobu jízdy),</li>
<li>způsob vyhodnocení dat ze senzoru - charakter výstupní veličiny (počet diskrétních stavů - 2 a nebo více).</li>
</ul>
<h2><a class="header" href="#nápověda-č-1-zápis-naměřených-dat-do-souboru" id="nápověda-č-1-zápis-naměřených-dat-do-souboru">Nápověda č. 1: Zápis naměřených dat do souboru</a></h2>
<p>Naměřená data je doporučeno prozatím logovat do souborů. Kdo zvládne logovat přes síť, může použít i tento způsob. Real-time sběr telemetrie bude náplní jednoho z dalších cvičení.</p>
<p>Pro snadnou, rychlou a bezproblémovou práci je doporučeno ukládat měřená data do snáze čitelného formátu souboru, který bude používán v aplikaci, kterou budete naměřená data analyzovat. Doporučen je primárně <code>MATLAB</code> nebo <code>GNU Octave</code>. Kdo s tím má problém, je to jeho problém. Příznivci jazyka Python mohou použít např. prostředí <code>Spyder</code> a v něm balíček <code>NumPy</code>. V nouzi postačí i tabulkový procesor (<code>MS Office Excel</code>, <code>LibreOffice Calc</code>, atd.).</p>
<h3><a class="header" href="#formát-csv-comma-separated-values-souboru" id="formát-csv-comma-separated-values-souboru">Formát CSV (Comma-separated values) souboru</a></h3>
<p>Čísla jsou v textovém vyjádření, desetinným oddělovačem je tečka, odělovačem hodnot v řádku je čárka, oddělovačem nových řádků v tabulce je konec řádku <code>&lt;CR&gt;&lt;LF&gt;</code> pro platformu Windows, pro Linux je to jen <code>&lt;LF&gt;</code>.</p>
<h3><a class="header" href="#zápis-dat-do-souboru-v-jazyce-c" id="zápis-dat-do-souboru-v-jazyce-c">Zápis dat do souboru v jazyce C</a></h3>
<pre><code>#include &lt;stdio.h&gt;
FILE *fopen(const char *pathname, const char *mode);
int fprintf(FILE *stream, const char *format, ...);
int fflush(FILE *stream);
int fclose(FILE *stream);
</code></pre>
<h2><a class="header" href="#nápověda-č-2-přístup-k-souborům-a-jejich-přenos-mimo-os-linux" id="nápověda-č-2-přístup-k-souborům-a-jejich-přenos-mimo-os-linux">Nápověda č. 2: Přístup k souborům a jejich přenos mimo OS Linux</a></h2>
<p>Naměřená data, které jste si uložili v OS Linux budete chtít nejspíše analyzovat mimo tento systém. Uložené soubory tedy budete v tomto případě potřebovat přenést na jiné zařízení nebo např. z hostovaného OS (Ubuntu), který vám běží ve VM do hostujícího OS (např. Windows), na kterém běžně pracujete. Existuje několik způsobů jak toto realizovat:</p>
<ul>
<li>Zpřístupnit lokální složku v OS Linux prostřednictvím protokolu SMB (externí přístup z platforem Windows, Linux i Mac k souborům na Ubuntu přes sdílenou síťovou složku)</li>
<li>Přenést soubory přes síť s využitím protokolu SFTP (dostupné aplikace: <code>WinSCP</code>, <code>FileZilla</code>, <code>psftp</code>, <code>Total Commander</code> + <code>SFTP plugin</code>, atd.)</li>
<li>Soubory přenést na externí úložiště připojené v Ubuntu přes rozhraní USB (flash disk, HDD/SSD) nebo síť (NAS, atd.)</li>
</ul>
<h2><a class="header" href="#nápověda-č-3-zobrazení-naměřených-dat-v-matlabu--gnu-octave" id="nápověda-č-3-zobrazení-naměřených-dat-v-matlabu--gnu-octave">Nápověda č. 3: Zobrazení naměřených dat v MATLABu / GNU Octave</a></h2>
<h3><a class="header" href="#načtení-souboru-ve-formátu-csv-s-naměřenými-daty" id="načtení-souboru-ve-formátu-csv-s-naměřenými-daty">Načtení souboru ve formátu CSV s naměřenými daty</a></h3>
<pre><code>M = csvread(filename)
</code></pre>
<h3><a class="header" href="#vykreslení-grafu" id="vykreslení-grafu">Vykreslení grafu</a></h3>
<pre><code>figure(f)
clf
plot(X, Y, LineSpec)
plot(X, Y, LineSpec, 'LineWidth', width, 'MarkerSize', size)
xlabel(txt)
ylabel(txt)
title(txt)
legend(label1,...,labelN)
</code></pre>
<h2><a class="header" href="#nápověda-č-4-textový-bargraf-v-konzoli" id="nápověda-č-4-textový-bargraf-v-konzoli">Nápověda č. 4: Textový bargraf v konzoli</a></h2>
<pre><code>// funkce na vytvoreni jedne hodnoty grafu do konzole
// buffer ... predalokovany pracovni buffer do ktereho se bude zapisovat text
// nchars ... pocet znaku v bufferu
// val ... hodnota (0...1) k vytisteni
// navratovou hodnotu lze rovnou pouzit jako parametr do printf (&quot;%s&quot;, s)
const char *graf(char* buffer, int nchars, float value)
{
  int end = (int)(value * nchars) - 3; // start pipe, end pipe a koncova nula

  buffer[0] = '|';
  int i=1;

  while (i &lt; end)
    buffer[i++] = '=';

  buffer[i++] = '|';

  while (i &lt; nchars)
    buffer[i++] = ' ';

  buffer[nchars-1] = 0;
  return buffer;
}

printf(&quot;%d %%: %s&quot;, value, graf(buffer, 20, value));
</code></pre>
<h1><a class="header" href="#návrh-regulátoru" id="návrh-regulátoru">Návrh regulátoru</a></h1>
<h1><a class="header" href="#telemetrie-a-vizualizace" id="telemetrie-a-vizualizace">Telemetrie a vizualizace</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
