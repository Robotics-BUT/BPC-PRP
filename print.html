<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>BPC-PRP</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Uvod</a></li><li class="chapter-item expanded affix "><a href="prednasky.html">Přednášky</a></li><li class="chapter-item expanded affix "><a href="cviceni.html">Cvičení</a></li><li class="chapter-item expanded "><a href="chap_1_software/text/intro.html"><strong aria-hidden="true">1.</strong> Softwarové vybavení</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chap_1_software/text/linux.html"><strong aria-hidden="true">1.1.</strong> Linux a příkazová řádka</a></li><li class="chapter-item expanded "><a href="chap_1_software/text/git.html"><strong aria-hidden="true">1.2.</strong> Git - Verzovací systému</a></li><li class="chapter-item expanded "><a href="chap_1_software/text/clion.html"><strong aria-hidden="true">1.3.</strong> CLion IDE</a></li><li class="chapter-item expanded "><a href="chap_1_software/text/ros.html"><strong aria-hidden="true">1.4.</strong> Robotic Operating System</a></li><li class="chapter-item expanded "><a href="chap_1_software/text/vb.linux_installation.html"><strong aria-hidden="true">1.5.</strong> Příprava prostředí</a></li></ol></li><li class="chapter-item expanded "><a href="simulator/intro.html"><strong aria-hidden="true">2.</strong> Simulátor</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="simulator/rozhrani.html"><strong aria-hidden="true">2.1.</strong> Rozhraní</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="simulator/transport.html"><strong aria-hidden="true">2.1.1.</strong> Transportní protokol (UDP)</a></li><li class="chapter-item expanded "><a href="simulator/prez.html"><strong aria-hidden="true">2.1.2.</strong> Prezentační protokol (NMEA)</a></li><li class="chapter-item expanded "><a href="simulator/zpravy.html"><strong aria-hidden="true">2.1.3.</strong> Aplikační protokol (popis zpráv)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="simulator/zpravy/BEEP.html"><strong aria-hidden="true">2.1.3.1.</strong> Zpráva BEEP</a></li><li class="chapter-item expanded "><a href="simulator/zpravy/BTN.html"><strong aria-hidden="true">2.1.3.2.</strong> Zpráva BTN</a></li><li class="chapter-item expanded "><a href="simulator/zpravy/GPIO.DIR.html"><strong aria-hidden="true">2.1.3.3.</strong> Zpráva GPIO.DIR</a></li><li class="chapter-item expanded "><a href="simulator/zpravy/GPIO.GET.html"><strong aria-hidden="true">2.1.3.4.</strong> Zpráva GPIO.GET</a></li><li class="chapter-item expanded "><a href="simulator/zpravy/GPIO.SET.html"><strong aria-hidden="true">2.1.3.5.</strong> Zpráva GPIO.SET</a></li><li class="chapter-item expanded "><a href="simulator/zpravy/HELP.html"><strong aria-hidden="true">2.1.3.6.</strong> Zpráva HELP</a></li><li class="chapter-item expanded "><a href="simulator/zpravy/KILL.html"><strong aria-hidden="true">2.1.3.7.</strong> Zpráva KILL</a></li><li class="chapter-item expanded "><a href="simulator/zpravy/LED.html"><strong aria-hidden="true">2.1.3.8.</strong> Zpráva LED</a></li><li class="chapter-item expanded "><a href="simulator/zpravy/ODO.html"><strong aria-hidden="true">2.1.3.9.</strong> Zpráva ODO</a></li><li class="chapter-item expanded "><a href="simulator/zpravy/PING.html"><strong aria-hidden="true">2.1.3.10.</strong> Zpráva PING</a></li><li class="chapter-item expanded "><a href="simulator/zpravy/PWM.html"><strong aria-hidden="true">2.1.3.11.</strong> Zpráva PWM</a></li><li class="chapter-item expanded "><a href="simulator/zpravy/RESET.html"><strong aria-hidden="true">2.1.3.12.</strong> Zpráva RESET</a></li><li class="chapter-item expanded "><a href="simulator/zpravy/SENSOR.html"><strong aria-hidden="true">2.1.3.13.</strong> Zpráva SENSOR</a></li><li class="chapter-item expanded "><a href="simulator/zpravy/SERVO.html"><strong aria-hidden="true">2.1.3.14.</strong> Zpráva SERVO</a></li><li class="chapter-item expanded "><a href="simulator/zpravy/SPEED.html"><strong aria-hidden="true">2.1.3.15.</strong> Zpráva SPEED</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="simulator/nmea.html"><strong aria-hidden="true">2.2.</strong> Program nmea</a></li><li class="chapter-item expanded "><a href="simulator/robot.html"><strong aria-hidden="true">2.3.</strong> Program robot</a></li></ol></li><li class="chapter-item expanded "><a href="cviceni/cviceni_uvod.html"><strong aria-hidden="true">3.</strong> Cviceni</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cviceni/cviceni_01_linux_install.html"><strong aria-hidden="true">3.1.</strong> Instalace a seznámení se s prostředím</a></li><li class="chapter-item expanded "><a href="cviceni/cviceni_02_linux_cli_cpp.html"><strong aria-hidden="true">3.2.</strong> Linux CLI a C++</a></li><li class="chapter-item expanded "><a href="cviceni/cviceni_03_git.html"><strong aria-hidden="true">3.3.</strong> GIT, simulátor</a></li><li class="chapter-item expanded "><a href="cviceni/cviceni_04_udp.html"><strong aria-hidden="true">3.4.</strong> UDP komunikace</a></li><li class="chapter-item expanded "><a href="cviceni/cviceni_05_i2c.html"><strong aria-hidden="true">3.5.</strong> Hardware, I2C, ADC</a></li><li class="chapter-item expanded "><a href="cviceni/cviceni_06_motory.html"><strong aria-hidden="true">3.6.</strong> Řízení motorů</a></li><li class="chapter-item expanded "><a href="cviceni/cviceni_07_snimac_cary.html"><strong aria-hidden="true">3.7.</strong> Snímání čáry</a></li><li class="chapter-item expanded "><a href="cviceni/cviceni_08_regulacni_smycka.html"><strong aria-hidden="true">3.8.</strong> Regulační smyčka</a></li><li class="chapter-item expanded "><a href="cviceni/cviceni_09_regulatory.html"><strong aria-hidden="true">3.9.</strong> Návrh regulátorů</a></li><li class="chapter-item expanded "><a href="cviceni/cviceni_10_telemetrie_vizualizace.html"><strong aria-hidden="true">3.10.</strong> Telemetrie a vizualizace</a></li></ol></li><li class="chapter-item expanded "><a href="principy/INDEX.html"><strong aria-hidden="true">4.</strong> Principy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="principy/superloop.html"><strong aria-hidden="true">4.1.</strong> Supersmyčka a zpětnovazební řízení</a></li><li class="chapter-item expanded "><a href="principy/mediator.html"><strong aria-hidden="true">4.2.</strong> Mediator - Protokolový eventový parser</a></li><li class="chapter-item expanded "><a href="principy/controller.html"><strong aria-hidden="true">4.3.</strong> Stavový controller</a></li><li class="chapter-item expanded "><a href="principy/protostack.html"><strong aria-hidden="true">4.4.</strong> Procházení komunikačním protokolem ISO/OSI</a></li><li class="chapter-item expanded "><a href="principy/splitfiles.html"><strong aria-hidden="true">4.5.</strong> Organizace projektu / práce v týmu</a></li><li class="chapter-item expanded "><a href="principy/isolate.html"><strong aria-hidden="true">4.6.</strong> Oddělení modulů - Zrychlení kompilace</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">BPC-PRP</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#prakticka-robotika-a-pocitacove-videni-bpc-prp-online-skripta" id="prakticka-robotika-a-pocitacove-videni-bpc-prp-online-skripta">Prakticka robotika a pocitacove videni (BPC-PRP) online skripta</a></h1>
<p>Tento text predstavuje online skripta a studijni materialy pro prednasky a cviceni predmetu BPC-PRP - povinneho premetu 3. rocniku bakalarskeho studiniho oboru Automatizacni a merici technika na Fakulte elektrotechniky a komunikacnich technologii Vysokeho Uceni Technickeho v Brne.</p>
<p>Skripta rovnez obsahuji texty tykajici se dalsich oblasti robotiky, ktere jiz ale nejsou vyzadovany samotnou naplni predmetu.</p>
<h2><a class="header" href="#autori" id="autori">Autori</a></h2>
<p>Ing. Adam Ligocki, Ph.D.</p>
<p>Ing. Tomas Lazna</p>
<p>Ing. Petr Gabrlik</p>
<p>Ing. Tomas Jilek, Ph.D.</p>
<p>Ing. Frantisek Burian, Ph.D.</p>
<p>Ing. Tomáš Horeličan</p>
<h2><a class="header" href="#seznam-přednášek" id="seznam-přednášek">Seznam přednášek</a></h2>
<h3><a class="header" href="#1-Úvodní-přednáška" id="1-Úvodní-přednáška">1. Úvodní přednáška</a></h3>
<pre><code>Přednášející: Ing. František Burian Ph.D.
Datum:
</code></pre>
<h3><a class="header" href="#2-linux-shell-virtual-box-clion" id="2-linux-shell-virtual-box-clion">2. Linux, shell, virtual box, CLion</a></h3>
<pre><code>Základy principy OS Linux
Práce v příkazové řádce
Virtuální stroj
Možné způsoby vývoje aplikací na Linuxu
CLion vývojové prostředí (IDE)

Přednášející: Ing. Adam Ligocki
Datum:
</code></pre>
<h3><a class="header" href="#3-git-integrace-gitu-v-ide" id="3-git-integrace-gitu-v-ide">3. GIT, integrace GITu v IDE</a></h3>
<pre><code>Úvod do verzovacího systému GIT
Ovládání GITu z příkazové řádky
Decentralizace dat v GIT repozitáři
Příklad práce více vývojářů na jednom repozitáři
Integrace GITu v IDE CLIon a další GUI

Přednášející: Ing. Adam Ligocki Ph.D.
Datum:
</code></pre>
<h3><a class="header" href="#4-tcp-udpip-komunikace" id="4-tcp-udpip-komunikace">4. TCP-UDP/IP komunikace</a></h3>
<pre><code>Základy práce v GIT repozitáři
ISO/OSI a TCP/IP model
Síťové standardy IEEE 802.3, 802.11
Síťové protokoly - IPv4, UDP, TCP
Konfigurace sítě v Linuxu
Nástroje dostupné z příkazové řádky
Analýza síťové komunikace
Popis rozhraní socket API
Síťová komunikace z C/C++ aplikace

Přednášející: Ing. Tomáš Jílek, Ph.D.
Datum:
</code></pre>
<h3><a class="header" href="#5-ovládání-hardware-i2c-gpio-adc" id="5-ovládání-hardware-i2c-gpio-adc">5. Ovládání hardware, I2C, GPIO, ADC</a></h3>
<pre><code>Popis sběrnice I2C, její vlastnosti a problémy
Popis GPIO expanderu
Popis A/D převodníku  AD7997

Přednášející: Ing. František Burian, Ph.D.
Datum:
</code></pre>
<h3><a class="header" href="#6-výkonová-elektronika-pohony" id="6-výkonová-elektronika-pohony">6. Výkonová elektronika, pohony</a></h3>
<pre><code>Vybrané druhy motorů a jejich vlastnosti výhodné pro robotiku (DC, BLDC, Krokový, PMSM)
Způsoby řízení krokového motoru, mikrostep
Kinematika víceosých pohonů, interpolace
Úvod do dynamiky pohonů, rampový generátor, S-křivka

Přednášející: Ing. František Burian, Ph.D.
Datum:
</code></pre>
<h3><a class="header" href="#7-snímání-vodicí-čáry" id="7-snímání-vodicí-čáry">7. Snímání vodicí čáry</a></h3>
<pre><code>Koncepce a blokové schéma implementace celého projektu
Optické snímání čáry pomocí optočlenů CNY70
Zpracování měřených dat

Přednášející: Ing. Tomáš Jílek, Ph.D.
Datum:
</code></pre>
<h3><a class="header" href="#8-kinematika-a-regulace-pohybu-podvozku-robotu" id="8-kinematika-a-regulace-pohybu-podvozku-robotu">8. Kinematika a regulace pohybu podvozku robotu</a></h3>
<pre><code>Přímá a inverzní kinematická úloha pro diferenciálně řízený podvozek
Regulace pohybu podvozku

Přednášející: Ing. Tomáš Jílek, Ph.D.
Datum:
</code></pre>
<h3><a class="header" href="#9-popis-závěrečné-soutěže-příklady-možných-způsobů-řešení" id="9-popis-závěrečné-soutěže-příklady-možných-způsobů-řešení">9. Popis závěrečné soutěže, příklady možných způsobů řešení</a></h3>
<pre><code>Pravidla soutěže
Návrh možných způsobů řešení soutěže
***ÚČAST POVINNÁ***

Přednášející: Ing. Tomáš Lázna
Datum:
</code></pre>
<h3><a class="header" href="#10-robotic-operating-system-ros-rviz-vizualizace-v-robotice" id="10-robotic-operating-system-ros-rviz-vizualizace-v-robotice">10. Robotic Operating System ROS, Rviz, vizualizace v robotice</a></h3>
<pre><code>Úvod do platformy ROS
Principy fungování
Využití rozhraní ROS
Vizualizace (RViz)

Přednášející: Ing. Adam Ligocki Ph.D.
Datum:
</code></pre>
<h3><a class="header" href="#11-computer-vision-v-robotice" id="11-computer-vision-v-robotice">11. Computer Vision v robotice</a></h3>
<pre><code>Přednášející: Ing. Adam Ligocki Ph.D.
Datum:
</code></pre>
<h3><a class="header" href="#12-embedded-systémy-v-robotice" id="12-embedded-systémy-v-robotice">12. Embedded systémy v robotice</a></h3>
<pre><code>TODO:

Přednášející: Ing. Matouš Hýbl
Datum:
</code></pre>
<h2><a class="header" href="#seznam-cvičení" id="seznam-cvičení">Seznam cvičení</a></h2>
<h3><a class="header" href="#1-osnova-projektu-bezpečnost-v-rámci-přednášky-cvičení-se-nekoná" id="1-osnova-projektu-bezpečnost-v-rámci-přednášky-cvičení-se-nekoná">1. Osnova projektu, bezpečnost (v rámci přednášky, cvičení se nekoná)</a></h3>
<p>Vyučující: František Burian</p>
<h3><a class="header" href="#2-instalace-virtual-boxu-linuxu-clionu" id="2-instalace-virtual-boxu-linuxu-clionu">2. Instalace Virtual Boxu, Linuxu, CLionu</a></h3>
<p>Vyučující: Tomáš Horeličan</p>
<h3><a class="header" href="#3-práce-s-gitem-zprovoznění-simulátoru" id="3-práce-s-gitem-zprovoznění-simulátoru">3. Práce s GITem, zprovoznění simulátoru</a></h3>
<p>Vyučující: Tomáš Horeličan</p>
<h3><a class="header" href="#4-udp-komunikace-se-simulátorem-nmea-protokol" id="4-udp-komunikace-se-simulátorem-nmea-protokol">4. UDP komunikace se simulátorem, NMEA protokol</a></h3>
<p>Vyučující: Tomáš Lázna</p>
<h3><a class="header" href="#5-ovládání-hardware---i2c-gpio-adc" id="5-ovládání-hardware---i2c-gpio-adc">5. Ovládání hardware - I2C, GPIO, ADC</a></h3>
<p>Vyučující: František Burian</p>
<h3><a class="header" href="#6-ovládání-motorů-reálného-i-simulovaného-robota" id="6-ovládání-motorů-reálného-i-simulovaného-robota">6. Ovládání motorů reálného i simulovaného robota</a></h3>
<p>Vyučující: František Burian</p>
<h3><a class="header" href="#7-snímání-čáry-v-simulátoru" id="7-snímání-čáry-v-simulátoru">7. Snímání čáry v simulátoru</a></h3>
<p>Vyučující: Tomáš Jílek</p>
<h3><a class="header" href="#8-kinematika-mobilního-robotu" id="8-kinematika-mobilního-robotu">8. Kinematika mobilního robotu</a></h3>
<p>Vyučující: Tomáš Jílek</p>
<h3><a class="header" href="#9-návrh-regulátoru-pro-sledování-čáry" id="9-návrh-regulátoru-pro-sledování-čáry">9. Návrh regulátoru pro sledování čáry</a></h3>
<p>Vyučující: Tomáš Jílek</p>
<h3><a class="header" href="#10-telemetrie-a-vizualizace-ros" id="10-telemetrie-a-vizualizace-ros">10. Telemetrie a vizualizace, ROS</a></h3>
<p>Vyučující: Adam Ligocki</p>
<h3><a class="header" href="#11-samostatná-práce-na-projektu-samostatná-práce" id="11-samostatná-práce-na-projektu-samostatná-práce">11. Samostatná práce na projektu (samostatná práce)</a></h3>
<p>Vyučující: osobní konzultace s příslušným vyučujícím po předchozí domluvě</p>
<h3><a class="header" href="#12-zápočtový-týden" id="12-zápočtový-týden">12. Zápočtový týden</a></h3>
<p>Vyučující:</p>
<p>Kapitola &quot;Softwarové vybavení&quot; má za úkol seznámit Vás se základy práce s operačním systémem Linux, ovládání verzovacího systému Git, použití vývojového prostředí CLion, dále dát Vám povědomí o ROS (Robotic Operating System) a jako poslední, ale nejdůležitěnjí, provést Vás přípravou prostředí, ve kterém budete řešit projekt v rámci předmětu BPC-PRP.</p>
<h3><a class="header" href="#podkapitoly" id="podkapitoly">Podkapitoly:</a></h3>
<ul>
<li><a href="chap_1_software/text/linux.html">Orientace v Linuxu</a></li>
<li><a href="chap_1_software/text/git.html">Úvod do Gitu</a></li>
<li><a href="chap_1_software/text/clion.html">CLion IDE</a></li>
<li><a href="chap_1_software/text/ros.html">Robotic Operating System</a></li>
<li><a href="chap_1_software/text/vb.linux_installation.html">Příprava prostředí</a></li>
</ul>
<h1><a class="header" href="#linux-a-příkazová-řádka-terminál" id="linux-a-příkazová-řádka-terminál">Linux a příkazová řádka (terminál)</a></h1>
<p>Tuto kapitolu berte jako rozcestník pro práci v operačním systému Linux.</p>
<p>Není potřeba znát všechny příkazy, včetně jejich parametrů z paměti, avšak měli by jste mít o nich povědomí a případně na internetu, či v Linux manuále být schopni dohledat jejich přesný způsob použití.</p>
<h2><a class="header" href="#přehled-příkazů-v-terminále" id="přehled-příkazů-v-terminále">Přehled příkazů v terminále</a></h2>
<h3><a class="header" href="#příkaz" id="příkaz">příkaz</a></h3>
<p>vysvětlení funkce</p>
<pre><code>příklad použití      ...      vysvětlení
</code></pre>
<h3><a class="header" href="#ls---list" id="ls---list">ls - (list)</a></h3>
<p>Vypiš všechny soubory a složky (složka je taky typ souboru) v aktuálním bodě file systému.</p>
<pre><code>ls
ls -la      ...      vypíše všechny soubory, včetně sktytých a přidá k výpisu detailní informace
</code></pre>
<h3><a class="header" href="#cd---change-directory" id="cd---change-directory">cd - (change directory)</a></h3>
<p>Změna složky.</p>
<pre><code>cd my_directory      ...      přesun do adresáře s názvem my_directory
cd ~                 ...      návrat do domovské složky (v linuxu nazýváme &quot;home&quot;)
cd ..                ...      návrat o adresář výš (dvojtečka)
cd /                 ...      návrat do kořene file systému (v linuxu nazýváme &quot;root&quot;)
cd ../my_folder      ...      vrať se o adresář výš a pak se přesuň do adresáře &quot;my_folder&quot;
cd .                 ...      přesuň se do &quot;současného adresáře&quot;. V podstatě nic neudělá. Příklad ilustruje existenci symbolu pro aktuální adresář (tečka).
</code></pre>
<h3><a class="header" href="#pwd---print-working-directory" id="pwd---print-working-directory">pwd - print working directory</a></h3>
<p>Vypíše aktuální pozici ve file systému.</p>
<pre><code>pwd
</code></pre>
<h3><a class="header" href="#mkdir---make-directory" id="mkdir---make-directory">mkdir - (make directory)</a></h3>
<p>Vytvoření nového adresáře.</p>
<pre><code>mkdir my_folder      ...      vytvoří nový adresář s názvem &quot;my_folder&quot;
</code></pre>
<h3><a class="header" href="#cp---copy" id="cp---copy">cp - (copy)</a></h3>
<p>Kopíruje soubor.</p>
<pre><code>cp zdrojovy_soubor cilovy_soubor                    ...      vytvoří novou kopii zdrojovy_soubor nazvanou cilovy_soubor
cp ../secter.txt secret_folder/supersecret.txt      ...      vem soubor secret.txt, který se nachází o složku výš a zkopíruj ji do složky secret_folder. Kopie původního souboru se bude jmenovat &quot;supersecret.txt&quot;     
</code></pre>
<h3><a class="header" href="#mv---move" id="mv---move">mv - (move)</a></h3>
<p>Příkaz původně pro přesun souboru, hlavně se však využívá pro přejmenováni soborů.</p>
<pre><code>mv old_name.txt new_name.html      ...      přejmenuje soubor &quot;old%name.txt&quot; na &quot;new_name.html&quot;
</code></pre>
<h3><a class="header" href="#rm---remove" id="rm---remove">rm - (remove)</a></h3>
<p>Smaže soubor/složku.</p>
<pre><code>rm old_file.txt      ...      vymaže soubor &quot;old_file.txt&quot;
rm -r my_folder      ...      smaže složku. Při mazání složky vždy musíme použít modifikátor rekurze (-r). Ten říká, že se má rekurzivně smazat také obsah složky.
</code></pre>
<h3><a class="header" href="#chmod---change-mode" id="chmod---change-mode">chmod - (change mode)</a></h3>
<p>Změní přístupová práva k souboru.</p>
<pre><code>chmod 777 /dev/ttyUSB0      ...      umožní všem uživatelům PC přístup na USB port s pořadovým číslem 0. Pro detail fungováni přístupových práv ve file systému viz [7].
</code></pre>
<h3><a class="header" href="#sudo" id="sudo">sudo</a></h3>
<p>Meta příkaz. Operace provedená v rámci tohoto příkazu bude provedena v režimu oprávnění administrátora operačního systému. Obvykle používáme, když zasahujeme do systémových souborů.</p>
<pre><code>sudo mkdir /etc/config      ...      vytvoří složku &quot;config&quot; v systémovém adresáři &quot;/etc&quot;.
sudo rm -r /                ...      příkaz rekurzivně smaže celý adresář &quot;root&quot; (v podstatě smaže celý disk včetně OS)
</code></pre>
<h3><a class="header" href="#cat---concatenate-files-to-standard-output" id="cat---concatenate-files-to-standard-output">cat - (Concatenate FILE(s) to standard output)</a></h3>
<p>Program vypíše do termínálu obsah souboru.</p>
<pre><code>cat ~/my_config_file.txt      ...      vytiskne v terminále obsah zvoleného souboru
</code></pre>
<h3><a class="header" href="#man---manual-referenční-manuál-operačního-systému" id="man---manual-referenční-manuál-operačního-systému">man - (manual) referenční manuál operačního systému</a></h3>
<p>Rychlá pomoc když zapomenu, jak pracovat s daným programem</p>
<pre><code>man ls      ...      vytiskne v terminále manuál k programu ls
</code></pre>
<h3><a class="header" href="#distribuce-linuxu" id="distribuce-linuxu">Distribuce Linuxu</a></h3>
<p>Hovoříme-li o Linuxu, máme na mysli jádro operačního systému, které je zpravováno autoritou (tvůrce linuxu Linus Torvards) a ta zajišťuje integritu veškerého kódu, který je do jádra OS zaintegrován.</p>
<p>Nad jádrem operačního systému je však nádstavka balíčkovacích systémů, grafického rozhraní, a dalšího podpůrného software. Distribucí se v Linuxu rozumí balíček těchto podpůrných software, který je dodáván a garantován konkrétní právnickou osobou (komerční subjekt, organizace, atd.).</p>
<p>Často používané distribude:</p>
<p>Debian - nejrošířenější distribuce Linuxu.</p>
<p>Ubuntu - derivát Debianu. Nejrozšířenějí distribuce na domácích stanicích.</p>
<p>Mint - derivát Ubuntu. GUI se blíží Windows.</p>
<p>RaspberryOS (dříve Raspbian) - derivát Debianu pro Raspberry Pi</p>
<p>Arch Linux - Distribuce orienovaná na profi uživatele - velká volnost při konfiguraci systému</p>
<p>Fedora - Alternativa k Debianu.</p>
<p>ElementaryOS - Minimalistická a rychlá distribuce. Vhodná pro slabé počítače.</p>
<p>... mnoho dalších</p>
<h2><a class="header" href="#orientace-v-systému" id="orientace-v-systému">Orientace v systému</a></h2>
<p>Souborová struktura Linuxu se odvozuje od tzv. kořene (root), který značíme jako / (vzdáleny ekvivalent C:/ na Windows).</p>
<p>V kořenovém adresáři pak nalezneme složky jako:</p>
<ul>
<li>bin/ - obsahuje binárky (spustitelné soubory operačního systému).</li>
<li>home/ - adresář, který obsahuje domovské složky uživatelů.</li>
<li>dev/ - obsahuje soubory které mapují fyzické interfacy počítače (interní a externí disky, sériovou linku, usb, síťové rozhraní, atd.).</li>
<li>tmp/ - temporary složka. Zde si programy odkládají svá dočasná data.</li>
<li>media/ - místo kde se mountují (připojují) externí disky.</li>
<li>etc/ - složka obsahuje klíčové systémové soubory.</li>
</ul>
<p>Po příhlášení se obvykle nacházíte v domovském adresáři, tj na místě /home/&lt;jmeno_uzivatele&gt;/</p>
<h2><a class="header" href="#základní-programy" id="základní-programy">Základní programy</a></h2>
<h3><a class="header" href="#apt" id="apt">apt</a></h3>
<p>Jedná se o Balíčkovací systém Debianu. Na Linuxu nejčastěji instalumeme programy tak, že si jej stáhneme z veřejného repozitáře, tedy obvykle ověřeného a bezpečného serveru.</p>
<p>Při instalaci musíme vždy disponovat administrátorskými právy.</p>
<p>Příklad instalace Gitu:</p>
<pre><code>sudo apt update
sudo apt install git
</code></pre>
<p>Říkáme: &quot;s administrátorskými právy zavolej program apt a aktualizuj si záznamy o repozitářích&quot;, a &quot;s administrátorskými právy zavolej program apt a ten neinstaluje git&quot;.</p>
<h3><a class="header" href="#nano" id="nano">nano</a></h3>
<p>Editace textu podobná poznámkovému bloku</p>
<p>Ctrl + X - ukončení programu. Program se zeptá, zda má uložit změny</p>
<h3><a class="header" href="#vim" id="vim">vim</a></h3>
<p>Profi editace textu. Ovládání programu je však poněkud složitější a vyžaduje pochopení několika principů. Práce s vim je však mnohonásobně rychlejší než s nano. Před použitím doporučuji projít libovolny &quot;vim noob tutoriál&quot; na youtube.</p>
<p>Kdyby se Vám přeci jen povedlo vim zapnout, vězte že jej vypnete kobinací kláves Shift + Z + Z (držíme shift a dvakrát zmáčkneme klávesu 'Z').</p>
<h3><a class="header" href="#mc" id="mc">mc</a></h3>
<p>Midnight Commander - grafické prostředí pro pohyb v souborovém systému. Připomíná MS Dos.</p>
<p>Vypíná se klávesou F10.</p>
<h3><a class="header" href="#curl" id="curl">curl</a></h3>
<p>Nástroj přikazového řádku pro přenos dat mnoha protokoly. Curl je často používán pro http komunikaci, instalaci programu, či stahování souborů.</p>
<h3><a class="header" href="#wget" id="wget">wget</a></h3>
<p>Program pro stahování souborů ze sítě.</p>
<p>Příklad stažení posledního releasu wordpresu:</p>
<pre><code>wget https://wordpress.org/latest.zip
</code></pre>
<h3><a class="header" href="#slovo-na-závěre" id="slovo-na-závěre">Slovo na závěre</a></h3>
<p>Pokud jste v Linuxu nováčky, hlavně se nebote experimentovat. Ideálně si nainstalulte systém do Virtual Boxu a udělejte si zálohu virtuálního disku. Když se Vás podaří systém rozhasit, stačí si natánout backup a jedete dál.</p>
<h1><a class="header" href="#git---verzovací-systému" id="git---verzovací-systému">Git - Verzovací systému</a></h1>
<p>Git je distribuovaný systém pro verzováni a management zálohování zdrojových kódů. Obecně ale Git funguje dobře pro verzování libovolného textu. Primární motivací k výuce Gitu v rámci tohoto předmětu je fakt, že Git je dnes nejrozšířenějí verzovací systém v konerční svéře a zároveň je na webu dostupná obrovská paleta Git-based online verzovacích služeb.</p>
<h2><a class="header" href="#základní-terminologie" id="základní-terminologie">Základní terminologie</a></h2>
<p>Vymezme si několik základních pojmů, abychom si rozuměli.</p>
<h3><a class="header" href="#repozitář-repo" id="repozitář-repo">repozitář (repo)</a></h3>
<p>Sada verzovaných souborů a záznamy o jejich historii. Pokud je repozitář uložen na našem počítači, nazýváme jej lokální repozitář (local repo). Jeli uložen na jiném stroji, hovoříme o vzdáleném repozitáři (remote repo).</p>
<h3><a class="header" href="#klonování-cloning" id="klonování-cloning">klonování (cloning)</a></h3>
<p>Stažení repozitáře z remote repa. Klonujeme v okamžiku, kdy na lokálním počítači repozitář neexistuje.</p>
<h3><a class="header" href="#snapshot" id="snapshot">snapshot</a></h3>
<p>Stav repozitáře v konkrétním bodě v historii.</p>
<h3><a class="header" href="#diff" id="diff">diff</a></h3>
<p>Rozdíl mezi dvěmi snapshoty. Tedy rozdíl stavu verzovaných souborů.</p>
<h3><a class="header" href="#commit" id="commit">commit</a></h3>
<p>Záznam, který obsahuje referenci na předchozí, následujicí snapshot a diff mezi nimi. Zároveň každý commit má svůj unikátní dvaceti bytový hash, který jej jednoznačně identifikuje v rámci repozitáře.</p>
<h3><a class="header" href="#push" id="push">push</a></h3>
<p>Nahrání nových comitů na remote repo.</p>
<h3><a class="header" href="#fetch" id="fetch">fetch</a></h3>
<p>Stažení commitů z remote repo na lokál. Fetchujeme, pokud na lokále máme repozitář naklonovaný, ale nemáme stažené nejnovější commity.</p>
<h3><a class="header" href="#větev-branch" id="větev-branch">větev (branch)</a></h3>
<p>Řetězec na sebe navazujicích commitů. Ze základu má každý repozitáž jednu větev (&quot;master&quot;, někdy &quot;main&quot;). Probíha-li však vývoj několika funkcionalit vedle sebe, je možné tyto vývoje rozdělit do zvláštnich větví a připojit je spátky k hlavní větni, až je funkcionalita dokončená.</p>
<h2><a class="header" href="#princip-fungování" id="princip-fungování">Princip fungování</a></h2>
<p>Primární funkcí Gitu je verzování textových souborů. Jedním dechem je potřeba dodta, že Git NENÍ vhodny pro verzování binárních souborů. Vyvíjíme-li tedy program a verzujeme vývoj v Gitu, vždy verzujeme pouuze zdrojové kódy, nikdy ne zkompilované spustitelné soubory (binárky).</p>
<p>Zároveň Git umožňuje velmi efektivní spolupráci mnoha lidí na stejném projektu (repozitáři). Vývojáři mohou pracovat společně, případně každý na separátním branchi. Důležité pravidlo však je, že dva lidé nesmí přepsat stejný řádek kódu ve dvou různých commitech. To způsobi tzv. konflikt. Obecné doporučení je, aby dva lidé neměnili stejný soubor.</p>
<p>Ve srovnání s SVN je ale Git tzv. decentralizovaný systém. To znamená, že v systému repozitářů neexistuje žaden nadřazeny, důležitější repozitář, či něco ve smyslu centrálního serveru. Všechny repozitáře mají stejnou funkcionalitu a jsou schopny udržovat kompletní historii celého repozitáře a ponohodnotně komunikovat se všemi ostatními klony. Praxe je však taková, že obvykle existuje repozitář, který funguje jako centrální místo pro výměnu commitů mezi vývojáři. Takový repozitář se obvykle jmenuje &quot;origin&quot;. Důležité však je, že kterýkolik repozitář, si může z originu stáhnout kompletní historii a tak v případě selhání originu nedojde ke ztrátě dat, protože každý vývojář může mít jeho plnohodnotnou kopii na svém počítačí.</p>
<p>Obvykla práce s Gitem vypadá následovně:</p>
<ul>
<li>Na serveru vytvoříme repozitář projektu.</li>
<li>vývojáři si naklonujou repozitář na lokální počítače. Z jejich pohledu loklálních repozitářů je server tzv &quot;origin&quot;.</li>
<li>vývojáři na lokálních počítačích vytváří kód a commitujou.</li>
<li>na konci dne každý vývojáž pushne (nahraje) své denní commity na origin.</li>
<li>na druhý den ráno si každý fetchne (stáhne) commity kolegů z dne předchozího.</li>
</ul>
<h2><a class="header" href="#instalace-gitu-na-linuxu" id="instalace-gitu-na-linuxu">Instalace Gitu na Linuxu</a></h2>
<p>V případě, že pracujeme na distribuci Debian, Git nainstalujeme následovně:</p>
<pre><code>sudo apt install git
</code></pre>
<p>nebo</p>
<pre><code>sudo snap install git
</code></pre>
<h2><a class="header" href="#přehled-příkazů" id="přehled-příkazů">Přehled příkazů</a></h2>
<h3><a class="header" href="#git-init" id="git-init">git init</a></h3>
<p>Inicializace repozitře. Z obvyklé složky v souborovém systému vytvořím repozitář.</p>
<p>Repozitář se od obyčejné složky liší tím, že v sobě obsahuje skrytou složku s názvem .git a ta obsahuje historii repozitáře.</p>
<pre><code>git init     ...      inicializuje repozitář
</code></pre>
<h3><a class="header" href="#git-add" id="git-add">git add</a></h3>
<p>Příkaz přidává změny vytvořené od posledního commitu do tzv. indexu. Index je soubor změn, které budou součástí nejbližšího commitu. Díky mezistupni index je možné commitnout jen některé změny, které jsme od posledního commitu vytvořili.</p>
<pre><code>git add myfile.txt     ...      přidá do indexu změny provedené nad souborem myfile.txt
git add .              ...      přidá do indexu všechny aktuální změny
</code></pre>
<h3><a class="header" href="#git-commit" id="git-commit">git commit</a></h3>
<p>Vytvoř nový commit, který je odvozený od posledního commitu v současné větví, a zahrni do commitu změny (diffy), které jsou v indexu.</p>
<pre><code>git commit -m &quot;komentář k danému commitu&quot;     ...      vytvoří nový commit v rámci větve, ve které se nacházíme
</code></pre>
<h3><a class="header" href="#git-checkout" id="git-checkout">git checkout</a></h3>
<p>Příkaz slouží k přecházení mezi snapshoty.</p>
<pre><code>git checkout .          ...     vrať větev do stavu posledního commitu (zahoď všechny do té doby vytvořené změny)
git checkout abcdef     ...     přepni mě do stavu, který vznikl po commitu s hexadecimálním označením abcdef
git checkout master     ...     přepni mě do stavu posledního dostupného commitu na větvi master
</code></pre>
<h3><a class="header" href="#git-clone" id="git-clone">git clone</a></h3>
<p>Příkaz vytvoří klon vzdáleného repozitáře na lokále. Klonujeme-li, není potřeba inicializovat repozitář pomocí git init. Metadata repozitáře se stáhnou automaticky s obsahem.</p>
<pre><code>git clone https://adresa_vzdaleneho_repozitare.git     ...      vytvoří klon daného repozitáře na lokálním stroji
</code></pre>
<h3><a class="header" href="#git-remote" id="git-remote">git remote</a></h3>
<p>Příkaz vytvoří klon vzdáleného repozitáře na lokále. Klonujeme-li, není potřeba inicializovat repozitář pomocí git init. Metadata repozitáře se stáhnou automaticky s obsahem.</p>
<pre><code>git remote -v                                            ...      vypíše konfiguraci vzdálených repozitářů
git remote add origin https://adresa_repozitare.git      ...      přidá do lokálního repozitáře alias vzdáleného repozitáře s danou adresou
git remote remove origin                                 ...      smaže alias origin na vzdálený repozitář  
</code></pre>
<h3><a class="header" href="#git-push" id="git-push">git push</a></h3>
<p>Odešle nové commity vytvořené na lokále na vzdálený repozitář.</p>
<pre><code>git push origin master     ...     odešle na mastera nové commity vytvořené v rámci větvě (branche) master
</code></pre>
<h3><a class="header" href="#git-fetch" id="git-fetch">git fetch</a></h3>
<p>Stáhne z remotu commity do lokálního repozitáře. Stažené komity se ale nestanou součástí větve. Změny zůstanou pouze zapsány v paměti.</p>
<pre><code>git fetch origin           ...     stáhne nové commity ve všech větvích z originu na lokál
git fetch origin master    ...     stáhne nové commity pouze pro větev master z originu na lokál
</code></pre>
<h3><a class="header" href="#git-merge" id="git-merge">git merge</a></h3>
<p>Na aktuální větví vytvoří nový commit tak, že spojí naagregované diffy dvou různých větví. Tím pádem se v součacné větvi objeví všechny změny, které byly vytvořeny v jiné větví. Větve se tak spojí.</p>
<pre><code>git merge cool_branch        ...      na současné větví vytvoří nový commit, který obsahuje všechny změny větve cool_branch
</code></pre>
<h3><a class="header" href="#git-pull" id="git-pull">git pull</a></h3>
<p>Kombinace příkazů git fetch a git merge. Obvykle se používá při stažení změn ze serveru. Příkaz nejprve stáhne commity z vzdáleného repozítáře (provede fetch) a následně je připojí do současné větve (provede merge).</p>
<pre><code>git pull origin master        ...      stáhne z originu nové commity na větvi master a přidá je do lokální větve master
</code></pre>
<h3><a class="header" href="#git-diff" id="git-diff">git diff</a></h3>
<p>Vytiskne rozdíl stavu repozitáře mezi dvěma commity.</p>
<pre><code>git diff abcdef 012345        ...      vytiskne rozdíl mezi commity, které jsou identifikovány hexadecimálními hashy abcdef a 012345
</code></pre>
<h3><a class="header" href="#git-status" id="git-status">git status</a></h3>
<p>Zobrazí současný stav změn provedených od posledního commitu, včetně zobrazení změn, které jsou již přidány do indexu.</p>
<pre><code>git status        ...      vytiskne současný stav změn
</code></pre>
<h3><a class="header" href="#git-log" id="git-log">git log</a></h3>
<p>Vytiskne chronologicky výpis commitů spolu s jejich metadaty (časem vytvoření commitu, popiskem, identifikačním hashem, atd.)</p>
<pre><code>git log        ...      vytiskne historii současné větve
</code></pre>
<h3><a class="header" href="#git-stash" id="git-stash">git stash</a></h3>
<p>Slouží pro ukládání a načítání změn do zásobníku. Vhodné například, když si všimnete, že píšete kód na jiné větvi, než byl záměr. Pomocí git stash uložíte změny do zásobníku, přepnete se na jinou větev a změny si ze zásobníku vytáhnete.</p>
<pre><code>git stash        ...      Uloží změny provedené od posledního commitu do zásobníku a vrátí větev do stavu, v jakém byla po posledním commitu (jako by jste zdrojový kód nikdy nenapsali).
git stash pop      ...      Vytáhne změny uložené ze zásobníku a aplikuje je na současný stav (jako by jste kód právě ručně napsali).
</code></pre>
<h2><a class="header" href="#cvičení" id="cvičení">Cvičení</a></h2>
<p>Několik scénářů se kterými se můžete během vývoje software potkat. Vyzkoušejte si je opakovaně, aby jste si vryli do paměti způsob práce s Gitem. Zároveň doporučuji si příklady nejprvé projít v příkazové řádce, aby jste chápali zůpsob, jakým Git funguje na nejnižší vrstvě a následně si cvičení absolvovali i v grafickém rozhraní Vašecho vývojového prostředí.</p>
<h3><a class="header" href="#základní-obsluha" id="základní-obsluha">Základní obsluha</a></h3>
<ul>
<li>Vytvořte si repozitář.</li>
<li>Vytvořte v něm 2 textové soubory a do každého napište několik řádků.</li>
<li>Přídejte provedené změny do indexu a následně změny commitněte.</li>
<li>Nyní zeditujte jeden soubor a opět jej commitněte.</li>
<li>Zeditujte druhý soubor a změny commitněte.</li>
<li>Vytvořte si účet na <a href="https://github.com">GitHubu</a>, a založte si tam nový repozitář.</li>
<li>Přidejte vzdálený repozitář jako &quot;origin&quot; do lokálního repozitáře a pushněte změny na origin.</li>
<li>Ve vebovém prostředí ověřte obsah repozitáře.</li>
<li>Na jiním místě v počítači, nebo na jiném počítači si naklonujte právě pushnutý repozitář.</li>
<li>V novém klonu proveďte změnu a commitněte jí pushnete na origin.</li>
<li>V původní složce pullněte nové commity z originu.</li>
<li>Příkazem git log si prohlédněte historii.</li>
</ul>
<h3><a class="header" href="#konflikt" id="konflikt">Konflikt</a></h3>
<p>Příklad, co se stane, když dva vývojáří změní tentýž kód.</p>
<ul>
<li>Po vzoru předchozího cvičení si vytvořte na počítači, případně na dvou počítačích dvě kopie repozitáře, který bude mít společný origin na webu.</li>
<li>V prvním klonu upravte konkrétní řádek souboru, commitněte a pushněte.</li>
<li>V druhém klonu upravte tentýž řádek, commitněne a pushněte (push zahlásí chybu).</li>
<li>Nyní jsme si vyrobili konflikt. Ve stejném bodě v historii větve repozitáře proběhly dvě změny,které se navzájem vylučují (tzv. conflict).</li>
<li>Konflikt opravíme tak, že v druhém klonu, který nedokázal pushnout provedeme pull z originu.</li>
<li>Nyní nahlédněme do souboru, který obsahuje konflikt. Konflikt je označen speciální syntaxí &lt;&lt;&lt;&lt;&lt;&lt;&lt; lokalni_zmena ======= zmena_z_originu &gt;&gt;&gt;&gt;&gt;&gt;&gt;. Vyberte verzi, která je žádoucí a speciální syntaxi odstraňte. Tím je konflikt vyřešen.</li>
<li>Zavolejte příkaz git commit bez dalších parametrů a provede se commit s automatickým popiskem, že se jedná o řešení konflitku.</li>
<li>Pushněte nový commit na origin a poté pullněte jej v původním repozitáři.</li>
<li>Příkazem git log si prohlédněte historii.</li>
</ul>
<h2><a class="header" href="#doporučené-materiály" id="doporučené-materiály">Doporučené materiály</a></h2>
<p><a href="https://atlassian.com">Tutoriál Atlassianu</a></p>
<p><a href="https://git.com">Oficiální dokumentace Gitu</a></p>
<p><a href="https://ohshithit.com/cs">Užitečný rádce při potížích s Gitem (cs)</a></p>
<h1><a class="header" href="#remote-development-v-prostredi-clion" id="remote-development-v-prostredi-clion">Remote development v prostredi CLion</a></h1>
<p>Clion je integrované vývojové prostředí vyvíjené firmou JetBrains. Jedná se o zajímavou alternativu ke konvenčním prostředím jako je například Eclipse nebo NetBeans.
Oproti těmto uvedeným prostředím Clion vyčnívá zejména kvůli své rychlosti, přehlednosti a modernosti. 
Díky napojení na ekosystém firmy JetBrains je možné do studia doinstalovat spoustu rozšiřujících pluginů přinášejících podporu pro nové jazyky, vývojářské nástroje atp. 
Velkou výhodou může být i integrovaná práce s Gitem.</p>
<p>V tomto manuálu bude rozebráno použití prostředí Clion v předmětu BPC-PRP tedy jako nástroje pro vývoj firmware mobilního robotu založeného na platformě KAMBot. 
Nejprve bude stručně rozebrán build system CMake.
Poté se manuál již bude věnovat CLionu a to zejména jeho instalaci, vytvoření jednoduchého projektu typu Hello World a jeho zprovoznení. 
Dále je popsána stěžejní kapitola tohoto manuálu, a to vzdálený vývoj umožňující vzdálené programování Raspberry Pi pomocí standardního počítače. Na konci je popsán jednoduchý projekt blikání LEDkou a kapitola zabývající se odstraňováním nejčastějších problémů se vzdáleným vývojem.</p>
<p>Příklady v tomto manuálu byly zpracovány ve verzi Clion 2018.3, je tedy možné, že se v budoucnosti některé postupy budou měnit.</p>
<h2><a class="header" href="#build-system-cmake" id="build-system-cmake">Build system CMake</a></h2>
<p>CMake je soubor nástrojů, které zjednodušují kompilaci projektů a knihoven takovým
způsobem, aby byly nezávislé na operačním systému a kompilátoru. Funguje tak,
že pomocí jednotného konfiguračního souboru CMakeLists.txt vygeneruje Makefile
pro UNIX-like systémy a pro Windows generuje MSVC pracovní prostory. Velkou
výhodou CMake je správa závislostí - aplikace si mohou definovat na jakých knihovnách
jsou závislé, přičemž CMake kontroluje, jestli jsou tyto knihovny dostupné a navíc v
požadované verzi. Další velkou výhodou je možnost vytvářet jak spustitelné soubory
tak knihovny pomocí jedné jednoduché konfigurace umístěné v CMakeLists.txt.</p>
<p>Ukázkový soubor CMakeLists.txt pro aplikaci:</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.7)
project(MyCoolRobot)

set(CMAKE_CXX_STANDARD 17) 

add_executable(MyCoolRobot main.cpp)
</code></pre>
<p>Ukázkový soubor CMakeLists.txt pro knihovnu:</p>
<pre><code class="language-cmake">cmake_minimum_required (VERSION 3.7)
project (MyCoolLibrary VERSION 0.1 LANGUAGES CXX )

include(GNUInstallDirs)
set (CMAKE_CXX_STANDARD 17)
file (GLOB SOURCES src/*.cpp )

file (GLOB HEADERS include/*.h)

add_library(libmycoollibrary ${SOURCES})

target_include_directories(libmycoollibrary PUBLIC
    $&lt;BUILD_INTERFACE : ${CMAKE_CURRENT_SOURCE_DIR}/include&gt; 
    $&lt;INSTALL_INTERFACE : include&gt;
    PRIVATE src)

install (TARGETS libmycoollibrary EXPORT MyCoolLibraryConfig
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})

install(DIRECTORY include/DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})

install(EXPORT RoboUtilsConfig DESTINATION share/MyCoolLibrary/cmake)

export(TARGETS libroboutils FILE MyCoolLibraryConfig.cmake)
</code></pre>
<p>V případě, že máme nějaký projekt, který používá CMake a chceme jej spustit,
provedeme to pomocí příkazů:</p>
<pre><code class="language-shell">cd MyCoolRobot
cmake . 
make
./MyCoolRobot
</code></pre>
<h2><a class="header" href="#instalace-clion" id="instalace-clion">Instalace CLion</a></h2>
<p>Instalace CLion probíhá pomocí stažení instalačního balíčku ze stránky <a href="https://www.jetbrains.com/clion/">https://www.jetbrains.com/clion/</a> po kliknutí na &quot;GET FREE 30 DAY TRIAL&quot;.
Studenti mají nárok na bezplatné využívání plné verze po dobu studia, což se ostatně týká všech produktů firmy JetBrains. 
Získání plné verze je možné pomocí postupu na stránce <a href="https://www.jetbrains.com/student/">https://www.jetbrains.com/student/</a>.
Po stažení instalačního balíčku provedeme instalaci standardním způsobem podle zvyklostí jednotlivých operačních systémů.</p>
<h2><a class="header" href="#hello-world-projekt" id="hello-world-projekt">Hello World Projekt</a></h2>
<p>Nejprve vytvoříme jednoduchý HelloWorld projekt, ve kterém se seznámíme s procesem vytvoření projektu, prostředím a vývojem na lokálním počítači. 
Po spuštění CLion nás přivítá úvodní obrazovka se seznamem naposledy otevřených projektů, kde klikneme na tlačítko &quot;New Project&quot;.</p>
<p><img src="chap_1_software/text/../images/clion/clion1.png" alt="uvodni obrazovka" /></p>
<p>Po kliknutí se nám otevře okno s konfigurací nového projektu, kde nastavíme cestu, kde chceme mít projekt vytvořený a standard jazyka C++, v našempřípadě C++17.</p>
<p><img src="chap_1_software/text/../images/clion/clion2.png" alt="vytvareni projektu" /></p>
<p>Po kliknutí na &quot;Create&quot; nás přivítá samotné vývojové prostředí tak jak je zobrazeno na obrazku.</p>
<p><img src="chap_1_software/text/../images/clion/clion3.png" alt="IDE" /></p>
<p>Pojďme se nyní podívat, co se na obrazovce nachází.</p>
<p><img src="chap_1_software/text/../images/clion/clion4.png" alt="IDE popis" /></p>
<ol>
<li>podokno s aktuálně editovaným zdrojovým kódem</li>
<li>aktuálně otevřené soubory</li>
<li>soubory v projektu</li>
<li>zleva: kompilace projektu, výběr targetu, kompilace a spuštění, kompilace aspuštění v debug módu</li>
</ol>
<p>Verze CMake dodávaná v Raspbianu je bohužel relativně stará, zatím co CLion předpokládá použití relativně novou verzi, pro vyřešení tohoto problému je nutné změnit v souboru CMakeLists.txt verzi CMake z 3.12 na 3.7 tak jak je zobrazeno ve výpisu:</p>
<p>NOTE: Dnes jiz pravdepodobne neplati a Raspbian obsahuje znatelne novejsi verzi CMake.</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION  3.7)
project(HelloWorld)
set(CMAKE_CXX_STANDARD  14)
add_executable(HelloWorld  main.cpp)
</code></pre>
<p>Nyní klikneme na tlačítko pro kompilaci a spuštění, kdy se nám nejprve ve spodní části obrazovky zobrazí okno s průběhem kompilace a následně s konzolí spuštěného programu:</p>
<p><img src="chap_1_software/text/../images/clion/clion5.png" alt="Run" /></p>
<p>Při debugování se breakpointy přidávají kliknutím vedle čísla řádku. 
Po přidání breakpointu je nutné program spustit v debug módu v horní části okna. 
Po kompilacise ve spodní části zobrazí okno debuggeru. 
Navigace v debuggovaném kódu probíhá pomocí šipek v debuggovacím okně.</p>
<p><img src="chap_1_software/text/../images/clion/clion6.png" alt="Debug" /></p>
<p>Pro přidání nové třídy do projektu klikneme v podokně se soubory projektu na náš projekt pravým tlačítkem, najedeme na &quot;New&quot; a tam zvolíme &quot;C/C++ Class&quot;, jak je zobrazeno na obrázku. 
Při přidávání a odebírání souborů je nutné, aby všechny <code>.cpp</code> soubory byly uvedeny v CMakeLists.txt.</p>
<p><img src="chap_1_software/text/../images/clion/clion7.png" alt="new class" /></p>
<p>CLion obsahuje spoustu funkcí a možností, jejichž popsání je zcela nad rámec tohoto návodu, doporučuji tedy si s ním pohrát a vyzkoušet, co všechno se v něm dá dělat a jak efektivně. 
Dobré je rovněž si všímat toho, když je řádek označený žlutě, většinou se jedná o CLion doporučující nějaké zlepšení kódu.</p>
<h2><a class="header" href="#vzdálený-vývoj" id="vzdálený-vývoj">Vzdálený vývoj</a></h2>
<p>Vzdálený vývoj (remote development) znamená, že výpočetně náročné vývojové prostředí běží na běžném počítači, zatímco kompilace a spouštění programu probíhána cílovém počítači. 
Tímto způsobem lze například velmi pohodlně programovat embedded hardware případně servery. 
Velká výhoda je, že například jde z Windows nebo MacOS programovat aplikace pro Linux, což nemusí vždy být možné kvůli chybějícím knihovnám napřiklad i2c-dev. 
Funkcionalita vzdáleného vývoje byla doprostředí CLion přidána ve verzi 2018.3.</p>
<p>Pro nakonfigurování vzdáleného vývoje je nutné nejprve přejít do nastaveníprostředí CLion (Preferences). 
Zde ve stromu vybereme &quot;Build, Execution, Deployment&quot; a položku &quot;Toolchains&quot; viz obrazek. 
Dále klikneme na tlačítko &quot;+&quot;.</p>
<p><img src="chap_1_software/text/../images/clion/clion8.png" alt="toolchain" /></p>
<p>Následně vyplníme jméno toolchainu a volbu &quot;System&quot; přepneme na &quot;RemoteHost&quot; tak, jak je to zobrazeno na obrazku. 
Následně klepneme na ikonu složky upoložky &quot;Credentials&quot; a nastavíme je podle konfigurace našeho robotu. 
Pokud konfigurace Raspberry Pi nebyla měněna, lze použít hodnoty uvedené v tabulce a zobrazené na obrázku.
Na Raspberry Pi musí být povoleno SSH.</p>
<p><img src="chap_1_software/text/../images/clion/clion9.png" alt="toolchain" />
<img src="chap_1_software/text/../images/clion/clion10.png" alt="toolchain" /></p>
<table><thead><tr><th>parametr</th><th>hodnota</th></tr></thead><tbody>
<tr><td>Host</td><td>raspberrypi.local</td></tr>
<tr><td>Port</td><td>22</td></tr>
<tr><td>User name</td><td>pi</td></tr>
<tr><td>Password</td><td>raspberry</td></tr>
</tbody></table>
<p>Po kliknutí na OK, se CLion pokusí připojit k danému Raspberry Pi a zkontroluje,zda jsou všechny potřebné programy k dispozici. 
Připojování je vidět na obrazku a úspěšné připojení je vidět na dalsim obrazku.</p>
<p><img src="chap_1_software/text/../images/clion/clion11.png" alt="toolchain" />
<img src="chap_1_software/text/../images/clion/clion12.png" alt="toolchain" /></p>
<p>Dalším důležitým krokem je konfigurace CMake, ta se provádí rovněž v okně Preferences tak jak je zobrazeno na obrazku.</p>
<p><img src="chap_1_software/text/../images/clion/clion13.png" alt="toolchain" />
Po kliknutí na &quot;+&quot; nakonfigurujeme CMake tak aby používal náš nový toolchain,tak jak je to zobrazeno na obrázku a klikneme na OK.</p>
<p><img src="chap_1_software/text/../images/clion/clion14.png" alt="toolchain" /></p>
<p>Po kliknutí na OK proběhne upload souborů na Raspberry Pi, po uploadu je nutné přepnout konfiguraci CMake na naši nově vytvořenou jak je zobrazenona obrazku.</p>
<p><img src="chap_1_software/text/../images/clion/clion15.png" alt="toolchain" />
<img src="chap_1_software/text/../images/clion/clion16.png" alt="toolchain" /></p>
<p>Poté následuje reload konfigurace jak je zobrazeno na obrazku.</p>
<p><img src="chap_1_software/text/../images/clion/clion17.png" alt="toolchain" /></p>
<p>Po kliknutí na tlačítko kompilace a spuštění se náš firmware zkompiluje naRaspberry Pi a spustí se, tak jak je vidět na obrazku, kdy úspěch poznáme podle toho, že se spustitelný soubor spouští z adresáře tmp.</p>
<p><img src="chap_1_software/text/../images/clion/clion18.png" alt="toolchain" /></p>
<p>Vzdálený vývoj je nyní nakonfigurován a měl by fungovat téměř bez problémů, častým problémům je věnována kapitola Troubleshooting.</p>
<h2><a class="header" href="#troubleshooting" id="troubleshooting">Troubleshooting</a></h2>
<p>V této kapitole bude rozebráno řešení problémů vznikajících při použití vzdáleného vývoje.</p>
<h3><a class="header" href="#cmake-312-is-required-you-are-running-version-372" id="cmake-312-is-required-you-are-running-version-372">CMake 3.12 is required. You are running version 3.7.2</a></h3>
<p>Problém je ve vašem CMakeLists.txt, změňte parametr &quot;cmake_minimum_required&quot;.</p>
<h3><a class="header" href="#v-raspberry-pi-chybí-požadované-soubory" id="v-raspberry-pi-chybí-požadované-soubory">V Raspberry Pi chybí požadované soubory</a></h3>
<p>Po kliknuti na slozku projektu v levem panelu, kliknete na &quot;Deployment&quot;, &quot;Upload to&quot; a vyberte Raspberry Pi.</p>
<h3><a class="header" href="#ultimátní-řešení-problémů" id="ultimátní-řešení-problémů">Ultimátní řešení problémů</a></h3>
<p>Zkontrolujte, jestli v CMakeLists.txt jsou uvedeny všechny soubory, které se mají kompilovat. 
Zkuste v podokně CMake provést reload, jak je zobrazeno na obrazku. 
Pokud to nepomůže, přes SSH se připojte k Raspberry Pi, v /tmp smažte momentálně používanou složku pro vzdálený vývoj, restartujte CLion.</p>
<p><img src="chap_1_software/text/../images/clion/clion19.png" alt="toolchain" /></p>
<h1><a class="header" href="#robotic-operating-system" id="robotic-operating-system">Robotic Operating System</a></h1>
<p>Název &quot;Robot Operating System&quot; poněkud klame svým zněním. Nejedná se o samostaný operační sýstém, nýbrž spíše o middle-ware, tedy softwarový nástroj (knihovnu), který pomáha propojit dílčí programy do komplexnejšího celku. V praxi si to můžem představit tak, že máme jednoduchou aplikaci pro robota jezdícího po čáre, kterou realizujeme pomoci 3 navzájem spolupracujících programů (příklad funguje jako ilustrační; takového robota samozřejmě můžeme naprogramovat pomocí jednoho programu; ilustrujeme tím ale komplexnější problém). První program vyčítá data ze snímače a provádí jednoduchou filtraci dat. Druhý program je mozkem celého řešení a rozhoduje o pohybu robota. Třetí program pak přijímá řídicí pokyny a na jejich základě ovládá motory.</p>
<p><img src="chap_1_software/text/../images/robot_scheme.png" alt="Rviz" /></p>
<p>Obr: Schéma fungování pomyslého line-tracking robota na platformě Rapserry Pi s pouřitím ROSu.</p>
<p>V případě absence ROSu bychom museli vymyslet způsob jak tyto tři programy spolu budou komunikovat. Mohli bychom sdílet paměť, pipovat, posílat si IP zprávy, používat DBus, etc. Všechny tyto techniky fungují, ale vyžadují určitý programátorský um. My se těmito nízkouúrovňovými problémy nechceme zabývat a proto použijeme ROS.</p>
<p>V praxi si pak můžeme říct, že ROS komunikuje mezi procesy právě pomocí posílání UDP paketů. To umožňuje také komunikovat procesům, které běží na různých počítačích. Tomu říkáme distribuovaný systém.</p>
<p>Celý ROS je postaven na 4 stavebních kamenech.</p>
<ul>
<li>ROS Core</li>
<li>ROS Node</li>
<li>ROS Topic</li>
<li>ROS Message</li>
</ul>
<p>ROS Core - Zjednodušeně řečeno se jedná o IP server, který zajištujě propojení programů (Nodů), které si chtějí vyměnovat data (Message) . Core nativně otevře port 11311 na localhostu a čeká na příchozí komunikaci.</p>
<p>ROS Node - Nodem je myšlený každý program do kterého přídáme klinetskou knihovnu ROSu. Naučíme tedy program používat funkce ROSu.</p>
<p>ROS Topic - Doména, ve které se posílá specifický okruh ROS Messagů.</p>
<p>ROS Message - Jedna instance odeslané zprávy. V rámci ROSu je možné posílat jenom zprávy, které jsou striktně zadefinovány a mají svůj jasně daný formát. Často obsahují také časovou značku, kdy byly odeslány.</p>
<p>Dále si zadefinujme dva typy postavení ROS Nodů při komunikaci.</p>
<p>Subscriber - ROS Node, který přijímá všechny zprávy v rámci daného ROS Topicku.</p>
<p>Publisher - ROS Node, který vytváří a odesíla zprávy v rámci daného ROS Topicku.</p>
<p>Náš robot-sledující-čáru příklad si pak můžem ilustrovat takto:</p>
<p><img src="chap_1_software/text/../images/ros_com_scheme.png" alt="Rviz" /></p>
<p>Nejprve zapneme ROS Core, tedy server, který začte poslouchat příchozí komunikaci. Dále si napíšeme zmíněne 3 programy. Jeden pro čtení dat ze snímače, druhý pro rozhodování, jak se pohybovat a třetí pro ovládání motorů. První program (Node) se přihlásí k serveru, jako publisher pro topick &quot;SensorData&quot;. Druhý se přihlásí serveru, jako subscriber v tomtéž topicku. Server si tyto dva nody poznamená a publisherovi odešle informaci, že je v sídi na dané adrese a portu připravený subscriber, který si vyžádal data z topicku, který oba nody sdílí. Když pak první program přečte data ze snímače, vyfiltruje je a vytvoří z nich message, kterou pošle na dříve obdrženou adresu a port, aby data obdržel subscriber. Obdobným způsobem se vymění data i mezi druhým a třetím programem, pouze pod hlavičkou jiného topicku.</p>
<p>Nyní máme vytvořené všechny tři programy. Ty spolu komunikují, ale robot přesto nefunguje podle přestav. Tušíme, že chyba je v tom, jak druhý program převádí data ze snímače na pohyb kol. Proto si napíšeme 4. program, který bude poslouchat veškerou komunikaci a bude ji logovat do souboru. Náš nový program tedy bude subscriberem pro oba dříve zavedené topicky &quot;SensorData&quot; a &quot;MotorControl&quot;. V okamžiku kdy tento program zapneme, tak se ohlásí serveru a od tohoto okamžiku všechny zprávy odeslané v topicích &quot;SensorData&quot; a &quot;MotorControl&quot; budo poslány také našemu logovcímu programu. Ten zprávy přijíme a jejich obsach včetně časové značky vytiskne do souboru. Když se pak do souboru podíváme, zjistíme, že plánovací program vatváří akční zásah vždy s opačným znaménkem, proto přídáme &quot;-&quot; do výpočtu akčního zásahu a vše začne fungovat.</p>
<h2><a class="header" href="#instalace-rosu" id="instalace-rosu">Instalace ROSu</a></h2>
<p>Tento návod je pouze českým přepisem oficiální dokumentace (Instalace pro Ubuntu)[http://wiki.ros.org/noetic/Installation/Ubuntu]. Prim8rn2 prosím používejte oficiální verzi. Tento návod je pouze doprovodný.</p>
<p>Instalace je doporučená na distribuci Ubuntu 20.04 LTS (long term stable). Instalovat budeme verzi ROSu z roku 2020, Noetic.</p>
<p>Přidáme do Linuxu repozitáře (servery) ze kterých je možné stáhnout ROS.</p>
<pre><code>sudo sh -c 'echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list'
</code></pre>
<p>Přidáme do systému klíč pro zabezpečenou komunikace s repozitářem.</p>
<pre><code>sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654
</code></pre>
<p>Necháme baličkovací systém načíst nově přidaná data.</p>
<pre><code>sudo apt update
</code></pre>
<p>Samotný ROS nainstalujeme příkazem. Trvá cca 10 min.</p>
<pre><code>sudo apt install ros-noetic-desktop-full
</code></pre>
<p>A na závěr si do souboru ~/.bashrc přídáme záznam o náčítání ROSu do proměnného prostředí, kdykoliv zapneme terminál.</p>
<pre><code>echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc
source ~/.bashrc
</code></pre>
<h2><a class="header" href="#tvorba-vlastního-nodu" id="tvorba-vlastního-nodu">Tvorba vlastního nodu</a></h2>
<p>Vytvoříme si jednoduchou aplikaci, kte jeden node bude odesílat zprávu s pořadovým číslem a časovou značkou a druhý node zprávu přijíme, vypíše a zjisti, s jakým zpožděním zpráva došla.</p>
<p>Nejprve si vytvoříme tzv workspace pro náš projekt. Workspacem se myslí speciálně uspořádaná složka.</p>
<pre><code>cd ~/
mkdir ros_ws
cd ros_ws
mkdir src
cd src
</code></pre>
<h3><a class="header" href="#c-node" id="c-node">C++ Node</a></h3>
<p>Dále si pomocí catkinu (balíčkovací nástroj pro ROS) necháme vztgenerovat nový balíček (package).</p>
<pre><code>catkin_create_pkg cpp_publisher std_msgs roscpp
</code></pre>
<p>Příkaz nám říká, že budeme volat program catkin_create_pkg a chceme po něm, aby nám vytvořil balíček cpp_publisher a připojil k němu knihovny std_msgs, která obsahuje základní sadu ROS zpráv a taktéž knihovnu roscpp, což je základní knihovana pro implementaci ROS Nodu v C++.</p>
<p>Nyní se náš balíček skládá z několika následujícíh souborů</p>
<pre><code>~/ros_ws/src/cpp_publisher/
    include/
    src/
    CMakeLists.txt
    package.xml
</code></pre>
<p>Do adresářů include a src budeme ukládat naše zdrojové kódy a soubory CMakeLists.txt a package.xml slouží ke kompilaci balíčku.</p>
<p>CMakeLists.txt a package.xml obsahují velké množství předpřipravených direktiv, které slouží složitějším příkladům. Pro naše potřeby si můžeme tyto dva soubory smazat.</p>
<pre><code>cd ~/ros_ws/src/cpp_publisher/
rm CMakeLists.txt
rm package.xml
</code></pre>
<p>Pomocí programu nano, nebo vim si oba soubory znovu vytvoříme tak a přidáme následující obsah.</p>
<pre><code>nano CMakeLists.txt
</code></pre>
<pre><code>cmake_minimum_required(VERSION 2.8.3)
project(cpp_publisher)

## Find catkin and any catkin packages
find_package(catkin REQUIRED COMPONENTS roscpp std_msgs)


## Declare a catkin package
catkin_package()

## Build talker and listener
include_directories(include ${catkin_INCLUDE_DIRS})

add_executable(cpp_publisher src/main.cpp)
target_link_libraries(cpp_publisher ${catkin_LIBRARIES})
</code></pre>
<p>a</p>
<pre><code>nano package.xml
</code></pre>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;package format=&quot;2&quot;&gt;
  &lt;name&gt;cpp_publisher&lt;/name&gt;
  &lt;version&gt;0.0.0&lt;/version&gt;
  &lt;description&gt;The cpp_publisher package&lt;/description&gt;

  &lt;maintainer email=&quot;my@email.todo&quot;&gt;adash&lt;/maintainer&gt;

  &lt;license&gt;TODO&lt;/license&gt;

  &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;
  &lt;build_depend&gt;roscpp&lt;/build_depend&gt;
  &lt;build_depend&gt;std_msgs&lt;/build_depend&gt;
  &lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;
  &lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;
  &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;
  &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;

  &lt;export&gt;

  &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<p>Nyní si můžeme vytvořit soubor main.cpp ve složce src a do něj napíšeme vlastní program</p>
<pre><code>nano src/main.cpp
</code></pre>
<pre><code>#include &lt;sstream&gt;

#include &quot;ros/ros.h&quot;
#include &quot;std_msgs/Header.h&quot;

int main(int argc, char **argv) {
    ros::init(argc, argv, &quot;cpp_publisher&quot;);
    ros::NodeHandle n;

    ros::Publisher publisher = n.advertise&lt;std_msgs::Header&gt;(&quot;/my_topic&quot;, 1);
    ros::Rate loop_rate(10);

    int count = 0;
    while (ros::ok()) {

        std_msgs::Header msg;
        msg.stamp = ros::Time::now();
        msg.seq = count++;
        msg.frame_id = &quot;origin&quot;;

        publisher.publish(msg);

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}
</code></pre>
<p>Nyní se vrátíme do kořene našeho workspacu a zavoláme příkaz pro build celého workspacu.</p>
<pre><code>cd ~/ros_ws
catkin_make
</code></pre>
<p>Pokud se nevypíše žádná chyba, máme hotový publisher, který je uložený v  ~/ros_ws/devel/lib/cpp_publisher.</p>
<p>Aby si Linux načetl nově zkompilované programy z našeho ros_ws přidámi si tento workspace do systémového prostředí (environmentu).</p>
<pre><code>source ~/ros_ws/devel/setup.bash
</code></pre>
<p>Abychom tuto akci již nemuseli opakovat přidáme si tento řádek také do ~/.bashrc</p>
<pre><code>echo &quot;source ~/ros_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc
</code></pre>
<p>Nyní si otevřeme další 2 terminály tak, abychom celkem měli 3 okna terminálu. V jednom aktivujeme roscore</p>
<pre><code>roscore
</code></pre>
<p>Ve druhém námi vytvořený publisher.</p>
<pre><code>rosrun cpp_publisher cpp_publisher
</code></pre>
<p>A ve třetím si poslechneme zprávy na topicku /my_topic</p>
<pre><code>rostopic echo /my_topic
</code></pre>
<p>Pokud vidíte v terminále výpis zpráv, vše pracuje, jak má.</p>
<h3><a class="header" href="#python-node" id="python-node">Python Node</a></h3>
<p>Vytvoříme si další balíček pomocí</p>
<pre><code>cd ~/ros_ws/src/
catkin_create_pkg python_subscriber std_msgs rospy
</code></pre>
<p>a upravíme si strukturu balíčku tak, aby vypadala následovně.</p>
<pre><code>~/ros_ws/src/python_subscriber/
    bin/
        python_subscriber.py
    include/
    src/
    setup.py
    CMakeLists.txt
    package.xml
</code></pre>
<p>Složka bin bude soužit k uložení hlavního skriptu python_subscriber.py, include a src pro další zdrojové kódy, které ale dneska nevyužijeme a CMakeLists.txt a package.xml obdobně jako pro C++ příklad. setup.py slouží k instalaci pythoniho balíčku do workspacu.</p>
<p>Zmíněné soubory si pak upravíme následovně.</p>
<pre><code>cmake_minimum_required(VERSION 2.8.3)
project(python_subscriber)

find_package(catkin REQUIRED COMPONENTS
  rospy
  std_msgs
)

catkin_package()

catkin_python_setup()
</code></pre>
<p>dále</p>
<pre><code>nano package.xml
</code></pre>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;package format=&quot;2&quot;&gt;
  &lt;name&gt;python_subscriber&lt;/name&gt;
  &lt;version&gt;0.0.0&lt;/version&gt;
  &lt;description&gt;The python_subscriber package&lt;/description&gt;

  &lt;maintainer email=&quot;my@email.todo&quot;&gt;adash&lt;/maintainer&gt;

  &lt;license&gt;TODO&lt;/license&gt;

  &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;
  &lt;build_depend&gt;rospy&lt;/build_depend&gt;
  &lt;build_depend&gt;std_msgs&lt;/build_depend&gt;
  &lt;build_export_depend&gt;rospy&lt;/build_export_depend&gt;
  &lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;
  &lt;exec_depend&gt;rospy&lt;/exec_depend&gt;
  &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;

  &lt;export&gt;

  &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<p>pak</p>
<pre><code>nano setup.py
</code></pre>
<pre><code>## ! DO NOT MANUALLY INVOKE THIS setup.py, USE CATKIN INSTEAD

from distutils.core import setup
from catkin_pkg.python_setup import generate_distutils_setup

# fetch values from package.xml
setup_args = generate_distutils_setup(
    packages=['python_subscriber'],
    package_dir={'': 'src'},
)

setup(**setup_args)
</code></pre>
<p>a finálně</p>
<pre><code>nano python_subscriber.py
</code></pre>
<pre><code>#!/usr/bin/env python
import rospy
from std_msgs.msg import Header

def callback(message):

    now = rospy.Time.now()
    delta_t = (now.secs - message.stamp.secs)*1000000000 + (now.nsecs - message.stamp.nsecs)

    print('seq: ' + str(message.seq))
    print('frame id: ' + message.frame_id)
    print('send time: ' + str(message.stamp.secs) + '.' + str(message.stamp.nsecs).zfill(9) + 's')
    print('receive time: ' + str(now.secs) + '.' + str(now.nsecs).zfill(9) + 's')
    print('delay [ns]: ' + str(delta_t))
    print(30*'*')

def listener():

    rospy.init_node('listener', anonymous=True)

    rospy.Subscriber(&quot;/my_topic&quot;, Header, callback)

    # spin() simply keeps python from exiting until this node is stopped
    rospy.spin()

if __name__ == '__main__':
    listener()
</code></pre>
<p>a přídáme souboru python_subscriber.py flag pro spouštění, aby bylo možné zapnout skript.</p>
<pre><code>chmod +x ~/ros_ws/src/python_subscriber/bin/python_subscriber.py
</code></pre>
<p>Nyní se můžeme vrátit do kořene workspacu a vše ykompilovat.</p>
<pre><code>cd ~/ros_ws/
catkin_make
</code></pre>
<p>Zaktualizujeme si proměné prostředí.</p>
<pre><code>source ~/ros_ws/devel/setup.bash
</code></pre>
<p>Pokud máme aktivní roscore i cpp_publisher, pak zampene node pomocí</p>
<pre><code>rosrun python_subscriber python_subscriber
</code></pre>
<p>a vidíme výpis přijímaných zpráv.</p>
<p>Pomocí programu rqt_graph si můžeme prohlédnout aktuální stav propojení nodů.</p>
<pre><code>rosrun rqt_graph rqt_graph
</code></pre>
<p><img src="chap_1_software/text/../images/rqt_graph.png" alt="rqt_graph" /></p>
<p>Obr: vizualizace komunikace mezi nody pomocí rqt_graph</p>
<h2><a class="header" href="#rviz" id="rviz">Rviz</a></h2>
<p>Rviz je vizualizační nástroj, který je dodáván jako součást ROSu. Jedná se o aplikaci, která dokáže poslouchat širokou paletu předdefinovaných ROS zpráv a vizualizovat je v 3D grafickém prostředí.</p>
<p>Obvzkle Rviz používáme pro vizualizaci pointcloudů (mrařna bodů z LIDARu), obrázků z kamery, vykreslování geometrických primitiv v prostoru, vizualizace occupancy grid map, atd.</p>
<p>Pokud nám již běži roscore, rviz aktivujeme pomocí</p>
<pre><code>rosrun rviz rviz
</code></pre>
<p>Vizualizaci konkrétního topicku pak aktivujeme pomocí</p>
<p>Add -&gt; By topic -&gt; [náš topick]</p>
<p>V sekci</p>
<p>Add -&gt; By display type</p>
<p>vidíme všechny podporované typy zpráv (viz online dokumentace ROSu).</p>
<p><img src="chap_1_software/text/../images/rviz.png" alt="rqt_graph" />
Obr: příklad vizualizace pointcloudu a kamery v Rvizu</p>
<p>Nyní si skusme vytvořit vlastní Node, který bude vykreslovat geometrické primitivum do RVizu. Vyjděme z příkladu cpp_ros_publishera a vytvořné následujicí program.</p>
<pre><code>cd ~/ros_ws/src
catkin_create_pkg cpp_rviz_publisher std_msgs visualization_msgs roscpp
</code></pre>
<p>CMakeLists.txt</p>
<pre><code>cmake_minimum_required(VERSION 2.8.3)
project(cpp_rviz_publisher)

## Find catkin and any catkin packages
find_package(catkin REQUIRED COMPONENTS roscpp std_msgs visualization_msgs)


## Declare a catkin package
catkin_package()

## Build talker and listener
include_directories(include ${catkin_INCLUDE_DIRS})

add_executable(cpp_rviz_publisher src/main.cpp)
target_link_libraries(cpp_rviz_publisher ${catkin_LIBRARIES})
</code></pre>
<p>package.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;package format=&quot;2&quot;&gt;
  &lt;name&gt;cpp_rviz_publisher&lt;/name&gt;
  &lt;version&gt;0.0.0&lt;/version&gt;
  &lt;description&gt;The cpp_rviz_publisher package&lt;/description&gt;

  &lt;maintainer email=&quot;my@email.todo&quot;&gt;adash&lt;/maintainer&gt;

  &lt;license&gt;TODO&lt;/license&gt;

  &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;
  &lt;build_depend&gt;roscpp&lt;/build_depend&gt;
  &lt;build_depend&gt;std_msgs&lt;/build_depend&gt;
  &lt;build_depend&gt;visualization_msgs&lt;/build_depend&gt;
  &lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;
  &lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;
  &lt;build_export_depend&gt;visualization_msgs&lt;/build_export_depend&gt;
  &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;
  &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;
  &lt;exec_depend&gt;visualization_msgs&lt;/exec_depend&gt;

  &lt;export&gt;

  &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<p>src/main.cpp</p>
<pre><code>#include &lt;sstream&gt;
#include &lt;ros/ros.h&gt;
#include &lt;visualization_msgs/Marker.h&gt;

visualization_msgs::Marker createCuteCube(float pose) {

    visualization_msgs::Marker marker;
    marker.header.frame_id = &quot;map&quot;;
    marker.header.stamp = ros::Time();
    marker.ns = &quot;cube&quot;;

    marker.id = 0;
    marker.type = visualization_msgs::Marker::CUBE;
    marker.action = visualization_msgs::Marker::ADD;

    marker.pose.position.x = sin(pose);
    marker.pose.position.y = cos(pose);
    marker.pose.position.z = 0.1*sin(5*pose);

    marker.pose.orientation.x = 0.0;
    marker.pose.orientation.y = 0.0;
    marker.pose.orientation.z = 0.0;
    marker.pose.orientation.w = 1.0;

    marker.scale.x = 0.1;
    marker.scale.y = 0.1;
    marker.scale.z = 0.1;

    marker.color.a = 1.0;
    marker.color.r = 0.0;
    marker.color.g = 1.0;
    marker.color.b = 0.0;

    return marker;
}


int main(int argc, char **argv) {

    ros::init(argc, argv, &quot;cpp_rviz_publisher&quot;);
    ros::NodeHandle n;

    ros::Publisher vis_pub = n.advertise&lt;visualization_msgs::Marker&gt;( &quot;/cute_cube&quot;, 0 );
    ros::Rate loop_rate(100);

    float pose = 0;
    while (ros::ok()) {
        visualization_msgs::Marker cube = createCuteCube(pose);
        vis_pub.publish( cube );
        pose += 0.01;

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}
</code></pre>
<p>V Rvizu si pak otevřeme topic /cute_cube .</p>
<h2><a class="header" href="#distribuovaný-ros" id="distribuovaný-ros">Distribuovaný ROS</a></h2>
<p>Tím, že calý backend ROS-ové komunikace je postaven na IP komunikaci (UDP protokolu), je možné snadno komunikaci mezi Nody přenést i na jiné počítače v dostupné síti. Po nainstalování je ROS nakonfigurován tak, že veškerá komunikace s Corem probíha na adrese http://localhost:11311, a Nody si bindují dostupné volné UDP porty a skrze něj komunikují mezi sebou. Pokud ale nastavíme na lokálním stroji proměnnou ROS_MASTER_URI na jinou IP adresu, bude každý nově nastartovaný Node hledat svůj ROS Core na adrese uvedené v ROS_MASTER_URI.</p>
<p>Spojme si 2 počitáče skrze IP síť a ověřme, že na seba navzájem vidí příkazem PING.</p>
<pre><code>ping xxx.yyy.zzz.qqq
</code></pre>
<p>Pokud oba počítače na sebe navzájem vidí, můžeme na počítači, kde chceme provozovat ROS Core nastavit proměnné, a aktivovat Core.</p>
<pre><code>export ROS_MASTER_URI=http://localhost:11311
export ROS_IP=&lt;ip_adresa_pocitace&gt;
roscore
</code></pre>
<p>Na 2. počítači, kde poběží nody musíme nastavit prostředí tak aby dokázalo najít ROS Core v síti.</p>
<pre><code>export ROS_MASTER_URI=http://&lt;ip_adresa_coru&gt;:&lt;port_coru&gt;
export ROS_IP=&lt;ip_adresa_pocitace&gt;
</code></pre>
<p>Ověřit nastavení proměnných můžeme příkazy</p>
<pre><code>echo $ROS_MASTER_URI
echo $ROS_IP
</code></pre>
<p>Nyní, pokud aktivujeme publisher a subscriber na libovolném počítači v takto nastavené ROS síti, budou nody spolu komunikovat.</p>
<p><img src="chap_1_software/text/../images/ros_distributed.png" alt="rqt_graph" />
Obr: příklad konfigurace ROSu na dvou počítačích.</p>
<h2><a class="header" href="#kam-dál" id="kam-dál">Kam dál?</a></h2>
<p>Tento tutoriál je popisuje pouze malý zlomek všech možných funkcionalit této obšírné platformy.</p>
<p>Oficiální web [1] - http://www.ros.org/</p>
<p>Oficiální tutoriály [2] - http://wiki.ros.org/ROS/Tutorials</p>
<p>Naučit se používat ROS Services [6]</p>
<p>Seznamy několika předdefinovaných ROS Messagů - [4] [5]</p>
<p>Pro zdatné ROSáky je možnost se posunout na další kvalitativní level, a totiž ROS 2 [3]. Druhá verze robotického operačního systému je již koncipováná jako real-time middleware s podporou QoS a širokou paletou služeb, které ocení zejména vývojáři sofistikovaných robotických řešení, na která bude kladeny řádově vyžší kvalitativní nároky.</p>
<p>Pro reálnou práci se zdrojovými kódy je vhodné použít nějaké IDE. V případě Linuxu vřele doporučuji programy od  JetBrains, CLion pro vývoj C++ a Pycharm pro práci s pythonem. Oba programy jsou pro studenty VUT zdarma.</p>
<h2><a class="header" href="#reference" id="reference">Reference</a></h2>
<p>[1] http://www.ros.org/</p>
<p>[2] http://wiki.ros.org/ROS/Tutorials</p>
<p>[3] https://github.com/ros2/ros2/wiki</p>
<p>[4] http://wiki.ros.org/std_msgs</p>
<p>[5] http://wiki.ros.org/sensor_msgs</p>
<p>[6] http://wiki.ros.org/Services</p>
<p>[7] https://www.computerhope.com/unix/uchmod.htm</p>
<p>[8] http://wiki.ros.org/ROS/Installation</p>
<h1><a class="header" href="#příprava-prostředí" id="příprava-prostředí">Příprava prostředí</a></h1>
<p>V této kapitole stručně probereme, jak si připravit počítač tak, aby bylo možné začít vyvíjet kód pro BPC-PRP projekt.</p>
<p>V ideálním případě si nainstalujte Linux přímo na Váš počítač, případně je možné jej nainstalovat do virtuálního stroje.</p>
<h2><a class="header" href="#instalace-virtualboxu" id="instalace-virtualboxu">Instalace VirtualBoxu</a></h2>
<p>VirtualBox si nainstalujte podle návodu na příslušném operačním systému.</p>
<p>Postup pro <a href="https://www.virtualbox.org/wiki/Downloads">Windows a Mac</a>.</p>
<p>Pro Linux instalace záleží na distribuci a používaném baličkovacím systému. Na Debianu použijte příkaz &quot;sudo apt install virtualbox&quot;. Poté bude možné VB aktivovat z terminálu voláním &quot;virtualbox&quot;, nebo skrze ikonku v seznamu nainstalovaných programů.</p>
<p><img src="chap_1_software/text/../images/vb.png" alt="VB" /></p>
<h2><a class="header" href="#instalace-linuxu" id="instalace-linuxu">Instalace Linuxu</a></h2>
<p>Stáhněte si obraz instalačního disku <a href="https://ubuntu.com/download/desktop">Ubuntu 20.04</a>.</p>
<p>Pomocí tlačítka &quot;New&quot; vytvořte nový virtuální stroj. Pojmenujte si jej, zvolte typ operačního systému, nastavte velikost operační paměti (vhodné 4GB a více), vytvořte nový virtuální disk, vyberte typ virtuálního disku (VDI), zvolte dynamickou alokaci disku a na poslední obrazovce vyberte umístění virtuálního disku na svém počítači a zvolte maximální možnou velikost virtuálního disku (10 - 20GB).</p>
<p>Nyní v hlavní obrazovce Virtual Boxu zvolte nově vytvořený virtuální stroj a přejděte do nastavení.</p>
<p>V záložce &quot;System&quot; můžete měnit velikost dedikované operační paměti, měnit počet jader procesorů, která budou pro virtuální stroj dostupná a také můžete zapínat/vypínat HW akceleraci pro virtuální stroj.</p>
<p>Dále v záložce &quot;Display&quot; světšete množství dedikované video paměti na maximum (128MB).</p>
<p>V záložce &quot;Storage&quot; klikněte na položku s obrázkem CD a následně úplně v pravo klikněte pravým na ikonku CD s malou šipečkou. Tím otevřete okno pro nastavení cesty k instalačnímu obrazu Ubuntu, které jsme dříve stáhli na počítač. Zavřete nastavení tlačítkem OK.</p>
<p><img src="chap_1_software/text/../images/vb_storage.png" alt="VB" /></p>
<p>Nyní v hlavním okně Virtual Boxu aktivujte virtuální stroj tlačítkem start.</p>
<p>Pokud je vše nastaveno korektně, stroj nabootuje z instalačního obrazu.</p>
<p><img src="chap_1_software/text/../images/ubuntu_install_1.png" alt="VB" /></p>
<p>Zvolte jazyk operačního systému (doporučeno angličtinu), zvolte rozložení klávesnice (doporučeno English US), a nechte pokračovat &quot;Normal Installation&quot;.</p>
<p>Dále se Vás proces dotáže, zda chcete &quot;Smazat disk a nainstalovat Ubuntu&quot;. Pokud nemáte konkrétní přání, jak si nastavit rozložení na disku, souhlaste s touto volbou. Systém Vám vypíše způsob, jakým rozdělí disk. Souhlaste.</p>
<p>Nyní zvolte časové pásmo a dále si vytvořte účet s heslem.</p>
<p>A dále už jen počkejte, až se systém doinstaluje a provede se reset virtuálního stoje.</p>
<p>Po opětovném nabootování v horní liště okna virtuálního stroje zvolte záložku &quot;Devices&quot; a &quot;Insert Guest Additions CD Image&quot;. Za okamžik vyskočí okno, které se dotáže zda má aktivovat autorun vloženého CD. Souhlaste. Systém si vyžádá heslo a poté se doinstalují ovladače pro virtualizovaný hardware.</p>
<p>Po dalším sestartu máte připarevený virtuální stroj s nainstalovaným Linuxem Ubuntu 20.04.</p>
<p><img src="chap_1_software/text/../images/ubuntu_rdy.png" alt="VB" /></p>
<p>Jako alternativu si stáhněte obraz virtuálního stroje s nainstalovaným Ubuntu <a href="https://drive.google.com/file/d/1kTZDLVTljSmCJOvL0AAAgZzEql6RpVrq/view?usp=sharing">zde</a>.</p>
<h2><a class="header" href="#instalace-ros" id="instalace-ros">Instalace ROS</a></h2>
<p>Instalaci ROSu na nově nainstalovaný Linux proveďte pomocí návodu popsaného v kiapitole <a href="chap_1_software/text/ros.html">Robotic Operating System</a>.</p>
<h2><a class="header" href="#clion" id="clion">CLion</a></h2>
<p>CLion si do nově nainstalovaného systému stáhněte z oficiálních stránek (viz <a href="chap_1_software/text/clion.html">CLion</a>)</p>
<h1><a class="header" href="#simulátor" id="simulátor">Simulátor</a></h1>
<h1><a class="header" href="#rozhraní-simulátoru--robotu" id="rozhraní-simulátoru--robotu">Rozhraní simulátoru / robotu</a></h1>
<p>Pro komunikaci se simulátorem i robotem je používán protokol NMEA-0183.</p>
<p>Komunikace pomocí NMEA zpráv je vedena protokolem UDP na jediném portu formou dotaz-odpověď. Simulátor bude v textu značen 
jako &quot;server&quot; a uživatelský program který mu odesílá dotazy jako &quot;klient&quot;.</p>
<p>Pro spojení je využíváno následujících adres:</p>
<table><thead><tr><th>CÍL</th><th>adresa</th></tr></thead><tbody>
<tr><td>simulátor (v linuxu)</td><td><code>127.0.0.1/8080</code></td></tr>
<tr><td>simulátor (přes síť)</td><td><code>&lt;ip adresa simulátoru&gt;/8080</code></td></tr>
<tr><td>robot (přes síť)</td><td><code>&lt;ip adresa robotu&gt;/6666</code></td></tr>
</tbody></table>
<p>Aktuální adresu robotu je nutné zjistit na routeru z DHCP, nebo lze využít příkazů pro zjištění okolních počítačů 
(na linuxu <code>fping</code>, na windows existuje spousta okenních nástrojů)
Adresu simulátoru lze zjistit linuxovým příkazem <code>ip a</code> z terminálu virtuálního stroje kde běží simulátor.</p>
<p>Některé zprávy neobsahují žádnou odpověď serveru. Reálný robot implementuje více příkazů než simulátor z důvodu lepšího<br />
ladění na hardware. Tyto zprávy jsou simulátorem ignorovány.</p>
<table><thead><tr><th>SIM</th><th>REAL</th><th>dotaz</th><th>odpověď</th><th>dokumentace</th></tr></thead><tbody>
<tr><td>ANO</td><td>ANO</td><td><code>SPEED,&lt;left&gt;,&lt;right&gt;</code></td><td><code>OK</code></td><td><a href="simulator/./zpravy/SPEED.html">SPEED</a></td></tr>
<tr><td>ANO</td><td>ANO</td><td><code>ODO</code></td><td><code>ODO,&lt;left&gt;,&lt;right&gt;</code></td><td><a href="simulator/./zpravy/ODO.html">ODO</a></td></tr>
<tr><td>ANO</td><td>ANO</td><td><code>SENSOR,&lt;id&gt;</code></td><td><code>SENSOR,&lt;id&gt;,&lt;hodnota&gt;</code></td><td><a href="simulator/./zpravy/SENSOR.html">SENSOR</a></td></tr>
<tr><td>ANO</td><td>ANO</td><td><code>PING,[&lt;data&gt;]</code></td><td><code>PONG,[&lt;data&gt;]</code></td><td><a href="simulator/./zpravy/PING.html">PING</a></td></tr>
<tr><td>ANO</td><td>ANO</td><td><code>RESET</code></td><td><code>RESET,DONE</code></td><td><a href="simulator/./zpravy/RESET.html">RESET</a></td></tr>
<tr><td>1.7+</td><td>ANO</td><td><code>KILL</code></td><td></td><td><a href="simulator/./zpravy/KILL.html">KILL</a></td></tr>
<tr><td>1.7+</td><td>ANO</td><td><code>HELP</code></td><td><code>HELP,&lt;cmd1&gt;,...</code></td><td><a href="simulator/./zpravy/HELP.html">HELP</a></td></tr>
<tr><td></td><td>ANO</td><td><code>BEEP,[&lt;ms&gt;]</code></td><td></td><td><a href="simulator/./zpravy/BEEP.html">BEEP</a></td></tr>
<tr><td></td><td>ANO</td><td><code>LED,[&lt;ms&gt;]</code></td><td></td><td><a href="simulator/./zpravy/LED.html">LED</a></td></tr>
<tr><td></td><td>ANO</td><td><code>BTN</code></td><td><code>BTN,&lt;left&gt;,&lt;right&gt;</code></td><td><a href="simulator/./zpravy/BTN.html">BTN</a></td></tr>
<tr><td></td><td>ANO</td><td><code>GPIO.GET,[&lt;mask&gt;]</code></td><td><code>GPIO.GET,&lt;mask&gt;</code></td><td><a href="simulator/./zpravy/GPIO.GET.html">GPIO.GET</a></td></tr>
<tr><td></td><td>ANO</td><td><code>GPIO.SET,&lt;mask&gt;,&lt;val&gt;</code></td><td></td><td><a href="simulator/./zpravy/GPIO.SET.html">GPIO.SET</a></td></tr>
<tr><td></td><td>ANO</td><td><code>GPIO.DIR,&lt;mask&gt;,&lt;dir&gt;</code></td><td></td><td><a href="simulator/./zpravy/GPIO.DIR.html">GPIO.DIR</a></td></tr>
<tr><td></td><td></td><td><code>PWM,&lt;output&gt;,&lt;value&gt;</code></td><td></td><td><a href="simulator/./zpravy/PWM.html">PWM</a></td></tr>
<tr><td></td><td></td><td><code>SERVO,&lt;output&gt;,&lt;value&gt;</code></td><td></td><td><a href="simulator/./zpravy/SERVO.html">SERVO</a></td></tr>
</tbody></table>
<h2><a class="header" href="#zprávy-dle-kategorií" id="zprávy-dle-kategorií">Zprávy dle kategorií</a></h2>
<ul>
<li>
<p><em><strong>Zprávy ovládání běhu a ladicí</strong></em></p>
<ul>
<li><a href="simulator/./zpravy/PING.html">PING</a></li>
<li><a href="simulator/./zpravy/RESET.html">RESET</a></li>
<li><a href="simulator/./zpravy/KILL.html">KILL</a></li>
<li><a href="simulator/./zpravy/HELP.html">HELP</a></li>
</ul>
</li>
<li>
<p><strong>Zprávy ovládání robotu</strong></p>
<ul>
<li><a href="simulator/./zpravy/SPEED.html">SPEED</a></li>
<li><a href="simulator/./zpravy/ODO.html">ODO</a></li>
<li><a href="simulator/./zpravy/SENSOR.html">SENSOR</a></li>
</ul>
</li>
<li>
<p><strong>Zprávy interakce s uživatelem</strong></p>
<ul>
<li><a href="simulator/./zpravy/BEEP.html">BEEP</a></li>
<li><a href="simulator/./zpravy/LED.html">LED</a></li>
<li><a href="simulator/./zpravy/BTN.html">BTN</a></li>
<li><a href="simulator/./zpravy/GPIO.GET.html">GPIO.GET</a></li>
<li><a href="simulator/./zpravy/GPIO.SET.html">GPIO.SET</a></li>
<li><a href="simulator/./zpravy/GPIO.DIR.html">GPIO.DIR</a></li>
</ul>
</li>
<li>
<p><strong>Zprávy dosud neimplementované</strong></p>
<ul>
<li><a href="simulator/./zpravy/PWM.html">PWM</a></li>
<li><a href="simulator/./zpravy/SERVO.html">SERVO</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#transportní-protokol-udp" id="transportní-protokol-udp">Transportní protokol (UDP)</a></h1>
<h1><a class="header" href="#prezentační-protokol-nmea-0183" id="prezentační-protokol-nmea-0183">Prezentační protokol (NMEA-0183)</a></h1>
<h2><a class="header" href="#popis-protokolu" id="popis-protokolu">Popis protokolu</a></h2>
<ul>
<li>Používá se obvykle při komunikaci s GNSS přijímači (GPS)</li>
<li>Existují přijímače, které komunikují na sériové lince i UDP (sdílejí protokol)</li>
<li>Jeden přenášený UDP packet může obsahovat <strong>více zpráv</strong></li>
<li>Každá NMEA zpráva je <strong>textový řetězec</strong> sestavený z <strong>argumentů</strong></li>
<li>Každá zpráva je <strong>bezestavová</strong> (není potřeba znát předchozí zprávy na sběrnici)</li>
<li>První argument definuje <strong>typ zprávy</strong> a tím i <strong>význam</strong> následujících argumentů</li>
</ul>
<h2><a class="header" href="#formát-jedné-zprávy" id="formát-jedné-zprávy">Formát jedné zprávy</a></h2>
<pre><code>$NMEA,MESSAGE,3,15,3.14,9E-5*FF\r\n
</code></pre>
<p>Každá zpráva obsahuje následující položky:</p>
<ul>
<li>Před zprávou můžou být <strong>libovolná</strong> (i binární!) data</li>
<li><strong>Začátek</strong> zprávy obsahuje znak <code>$</code> (nebo vyjímečně <code>!</code> nebo <code>?</code>)
<ul>
<li>Zprávy uvozené pomocí znaků <code>!</code> nebo <code>?</code> jsou ignorovány (původně dotaz-odpověď) </li>
</ul>
</li>
<li>Následuje seznam <strong>argumentů</strong> zprávy. V každém argumentu se může vyskytnout:
<ul>
<li>malá a velká písmena základní ASCII (<code>a-zA-Z</code>)</li>
<li>mezera a podtržítko (<code> _</code>) </li>
<li>číslice (<code>0-9</code>)</li>
<li>desetinná tečka (<code>.</code>)</li>
<li>znak znaménka (<code>+-</code>)</li>
<li>čárka oddělující jednotlivé argumenty mezi sebou (<code>,</code>) </li>
</ul>
</li>
<li>Argumenty jsou ukončeny hvězdičkou <code>*</code></li>
<li>Dále následují dva hexadecimální znaky pro <strong>kontrolní součet</strong> zprávy
<ul>
<li>Spočítán jako postupný 8-bitový XOR všech bajtů zprávy mezi <code>$</code> a <code>*</code></li>
<li>Můžou být použita malá i velká písmena</li>
</ul>
</li>
<li>Zpráva může být <strong>volitelně ukončena</strong> znaky <code>\r\n</code> pro lepší zobrazení v souboru </li>
<li>Za zprávou můžou být <strong>libovolná</strong> (i binární!) data</li>
</ul>
<h2><a class="header" href="#doporučené-rozhraní-pro-implementaci" id="doporučené-rozhraní-pro-implementaci">Doporučené rozhraní pro implementaci</a></h2>
<h3><a class="header" href="#data" id="data">Data</a></h3>
<p>Nomenklatura:</p>
<ul>
<li>Zprávu nižší úrovně (transportní) nazýváme <strong>frame</strong></li>
<li>Zprávu vyšší úrovně (aplikační) nazýváme <strong>logická zpráva</strong></li>
</ul>
<p>Fakta:</p>
<ul>
<li>Jelikož je protokol <strong>bezestavový</strong>, není potřeba stav držet
<ul>
<li>Není potřeba instance objektu, stačí <code>static</code> funkce</li>
<li>Dokonce není potřeba objekt, je vhodné ale funkce oddělit alespoň namespace</li>
</ul>
</li>
<li>Zpráva na straně aplikace reprezentuje <strong>seznam textových argumentů</strong>
<ul>
<li>Vhodný typ pro logickou zprávu <code>std::vector(std::string)</code></li>
</ul>
</li>
<li>Zpráva na straně transportu reprezentuje <strong>textový řetězec</strong>
<ul>
<li>Vhodný typ pro frame <code>std::string</code></li>
</ul>
</li>
<li>Zpráva na straně aplikace bude hojně využívána
<ul>
<li>Vytvoříme vhodný logický <strong>alias</strong> <code>Msg</code> abysme nemuseli moc psát</li>
</ul>
</li>
<li>Zprávu musí být <strong>jednoduché vytvořit</strong>, musí být přehledný zápis
<ul>
<li>Konstrukce s initializer-list : <code>return {&quot;ODO&quot;, std::to_string(3.14)}</code></li>
</ul>
</li>
<li>Prázdná aplikační zpráva (<strong>bez položek</strong>) indikuje <strong>neplatnou zprávu</strong>
<ul>
<li>Konstrukce <code>return {}</code></li>
<li>Test <code>if (msg.empty()) ...</code></li>
<li>Výjimka: zprávu &quot;bez dat&quot; lze stále vytvořit: <code>return {&quot;&quot;}</code> např jako heartbeat :o)</li>
</ul>
</li>
</ul>
<p>Implementace:</p>
<pre><code class="language-c++"> using Msg = std::vector&lt;std::string&gt;;                                           // vytvoření aliasu
</code></pre>
<h3><a class="header" href="#rozhraní-komunikace-k-transportní-vrstvě" id="rozhraní-komunikace-k-transportní-vrstvě">Rozhraní komunikace k transportní vrstvě</a></h3>
<p>Fakta:</p>
<ul>
<li>Je třeba vytvořit <strong>konverzi</strong> argumentů z logické zprávy na frame</li>
<li>Funkce nesmí změnit obsah argumentů vyššího protokolu
<ul>
<li>Datová struktura na vstupu tedy odpovídá <code>Immutable</code> <a href="https://cs.wikipedia.org/wiki/Immutable_object">viz odkaz</a> </li>
<li>Realizace v <code>C++</code> - využijeme <code>const</code></li>
</ul>
</li>
<li>Z důvodu optimalizace výkonu je vhodné předat vektor jako ukazatel na data
<ul>
<li>Ukazatel formátujeme pomocí <code>*prom</code></li>
</ul>
</li>
<li>Je nelogické, aby byla formátována zpráva s neplatným ukazatelem (<code>nullptr</code>)
<ul>
<li>Reference je ukazatel který nesmí být <code>nullptr</code></li>
<li>Použijeme referenci <code>&amp;prom</code></li>
</ul>
</li>
<li>Naskýtá se kostra design patternu <code>Builder</code> <a href="https://cs.wikipedia.org/wiki/Builder">viz odkaz</a>
<ul>
<li>Vytváříme objekt (<code>std::string</code>) na základě argumentů (<code>Msg</code>)</li>
<li>Proto tento přechod takto nazveme</li>
</ul>
</li>
<li>Jeden frame může obsahovat více zpráv
<ul>
<li>Je vhodné vytvořit overload funkce <code>Build</code> pro <code>std::vector(Msg)</code></li>
<li>Jiná možnost je přidat funkci <code>BuildAll</code> která vnitřně volá <code>Build</code></li>
</ul>
</li>
</ul>
<p>Implementace: </p>
<pre><code class="language-c++">  //std::string Build(const std::vector&lt;std::string&gt; &amp;msg);                      // bez aliasu
  std::string Build(const Msg &amp;msg);                                             // alias
  std::string BuildAll(const std::vector&lt;const Msg&gt; &amp;msg);                       // overload s aliasem
</code></pre>
<p>Overload funkce pro převod několika zpráv naráz je triviální:</p>
<pre><code class="language-c++">  std::string BuildAll(const std::vector&lt;const Msg&gt; &amp;msg) 
  {
    std::string result;
    
    for (const auto &amp;i : msg)
      result += Build(i);
      
    return result;   
  }
</code></pre>
<h3><a class="header" href="#rozhraní-komunikace-k-aplikační-vrstvě" id="rozhraní-komunikace-k-aplikační-vrstvě">Rozhraní komunikace k aplikační vrstvě</a></h3>
<p>Fakta:</p>
<ul>
<li>Je třeba vytvořit <strong>parser</strong> argumentů z aplikační vrstvy na logickou zprávu</li>
<li>Jedna logická zpráva transportního protokolu <strong>může obsahovat více zpráv</strong></li>
</ul>
<h4><a class="header" href="#implementace-i" id="implementace-i">Implementace I:</a></h4>
<pre><code class="language-c++">  //std::vector&lt;std::string&gt; Parse(const std::string &amp;msg);                      // bez aliasu
  Msg Parse(const std::string &amp;msg);                                             // alias  
</code></pre>
<p>V aplikačním kódu pak obsluha vypadá takto:</p>
<pre><code class="language-c++">  auto packet = &quot;$PING*10$PING*10&quot;;
  // obsluha transportni vrstvy                                              
  auto msg = Parse(packet))                                                      // Zde může být string const z vnitřního API transportního protokolu
  // obsluha aplikacni vrstvy
  if (msg[0] == &quot;PING&quot;) ....
</code></pre>
<p>Tato implementace obsahuje chybu (prvotní implementace na cvičení), kdy veškeré další zprávy uvnitř packetu jsou ignorovány</p>
<p>Pro úspěšné splnění předmětu tato implementace plně dostačuje. Ostatní implementace jsou akademická diskuse nad správným řešením</p>
<h4><a class="header" href="#implementace-ii" id="implementace-ii">Implementace II:</a></h4>
<pre><code class="language-c++">  //std::vector&lt;std::vector&lt;std::string&gt;&gt; ParseAll(const std::string &amp;msg);         // bez aliasu
  std::vector&lt;Msg&gt; ParseAll(const std::string &amp;msg);                             // alias  
</code></pre>
<p>V aplikačním kódu pak obsluha vypadá takto:</p>
<pre><code class="language-c++">  auto packet = &quot;$PING*10$PING*10&quot;;
  // obsluha transportni vrstvy
  for (auto &amp;msg : ParseAll(packet)) {                                           // Zde může být string const z vnitřního API transportního protokolu
    // obsluha aplikacni vrstvy
    if (msg[0] == &quot;PING&quot;) ....
  }
</code></pre>
<p>Tato implementace obsahuje výkonnostní problém v paměti (<strong>každá zpráva bude v paměti vždy několikrát</strong>), 
získáme tím ale optické oddělení vrstev v kódu</p>
<h4><a class="header" href="#implementace-iii" id="implementace-iii">Implementace III:</a></h4>
<ul>
<li>Funkce vyjme každou zprávu ze vstupního řetězce, a zpracuje se postupně
<ul>
<li>Princip pipeliningu</li>
<li>Vstupní řetězec je modifikován !</li>
</ul>
</li>
</ul>
<pre><code class="language-c++">  std::vector&lt;std::string&gt; Parse(std::string &amp;msg);                              // bez aliasu
  Msg Parse(std::string &amp;msg);                                                   // alias
</code></pre>
<p>V aplikačním kódu pak obsluha vypadá takto:</p>
<pre><code class="language-c++">  auto packet = &quot;$PING*10$PING*10&quot;;
  // obsluha transportni vrstvy
  std::string str{packet};                                                       // Zde musí být vytvořena nová lokální proměnná 
  for (auto msg = Parse(str); !msg.empty(); msg = Parse(str)) {
    // obsluha aplikacni vrstvy
    if (msg[0] == &quot;PING&quot;) .... 
  }
</code></pre>
<h4><a class="header" href="#implementace-iv" id="implementace-iv">Implementace IV:</a></h4>
<p>Využití <code>std::string_view</code> - nejlepší možnost, bez kopírování ale korektně lze implementovat až od <code>C++23</code>, který není 
podporován současnými kompilátory použitými v raspbianu (GCC 9)</p>
<h3><a class="header" href="#pomocné-funkce" id="pomocné-funkce">Pomocné funkce</a></h3>
<p>Pro obě rozhraní je potřeba vytvořit funkci, která spočítá checksum z předaných dat</p>
<pre><code class="language-c++">std::string Crc(const std::string &amp;text);
</code></pre>
<h1><a class="header" href="#aplikační-protokol" id="aplikační-protokol">Aplikační protokol</a></h1>
<p>Obsluha protokolu</p>
<pre><code class="language-c++">void loop() 
{
  auto [sender, received] = udp.receive();                                      // udp -&gt; mezivrstva
  if (sender.empty())
    return;
  auto rpacket = from_buffer(received);                                         // mezivrstva -&gt; transport
  std::vector&lt;Msg&gt; replies;    
  for (auto &amp;request : ParseAll(rpacket)) {                                     // transport -&gt; aplikace
    replies.append(ProcessIncoming(request));                                   // obsluha aplikacniho protokolu
  }
  if (!replies.empty()) {
    auto tpacket = BuildAll(replies);                                           // aplikace -&gt; transport
    auto transmit = to_buffer(tpacket);                                         // transport -&gt; mezivrstva
    udp.send(sender, transmit);                                                 // mezivrstva -&gt; udp 
  }
}

void send(std::vector&lt;Msg&gt; msgs) 
{
   auto tpacket = BuildAll(msgs);                                               // aplikace -&gt; transport
   auto transmit = to_buffer(tpacket);                                          // transport -&gt; mezivrstva
   udp.send(sender, transmit);                                                  // mezivrstva -&gt; udp
}
</code></pre>
<p>Principy aneb hloupeko kopni a chytreho nakopni</p>
<pre><code class="language-c++">std::vector&lt;Msg&gt; ProcessIncoming(const Msg &amp;msg) {
  auto res = map.find(msg[0]);
  if (res == map.end())
    return {}
    
  return (res-&gt;second)(msg);
}
</code></pre>
<p>Supersmycka</p>
<pre><code class="language-c++">  controller.state = &amp;Controller::DoSearchLine

  const int T = 20;
  long long ms = millis + T;
  while(rum) {
    send(data.Reads());
    
    while (ms &lt; millis())
      loop();
    ms = millis() + T;
    
    (controller-&gt;*state)();
    
    robot.ComputeMotorRamps();    
    
    send(data.Writes());
  }

</code></pre>
<h1><a class="header" href="#beep" id="beep">BEEP</a></h1>
<p>Robot pípne pípákem s dobou písknutí stanovenou v milisekundách.</p>
<p>V okamžiku překrývajících se písknutí se prodlužuje doba písknutí.</p>
<p>Simulátor neimplementuje.</p>
<h2><a class="header" href="#požadavek" id="požadavek">Požadavek:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;BEEP&quot;</td><td>-</td></tr>
<tr><td>1</td><td>int</td><td>ms</td><td>ms</td></tr>
</tbody></table>
<p>Argument není nutné použit, pípák pak pískne s dobou 100ms.</p>
<h2><a class="header" href="#odpověď" id="odpověď">Odpověď:</a></h2>
<p>žádná</p>
<h1><a class="header" href="#btn" id="btn">BTN</a></h1>
<p>Robot navrátí stav stisknutí obou tlačítek ve zprávě:</p>
<p>Simulátor neimplementuje.</p>
<h2><a class="header" href="#požadavek-1" id="požadavek-1">Požadavek:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;BTN&quot;</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#odpověď-1" id="odpověď-1">Odpověď:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;BTN&quot;</td><td>-</td></tr>
<tr><td>1</td><td>bool</td><td>left</td><td>1=stisknuto</td></tr>
<tr><td>2</td><td>bool</td><td>right</td><td>1=stisknuto</td></tr>
</tbody></table>
<h1><a class="header" href="#gpiodir" id="gpiodir">GPIO.DIR</a></h1>
<p>Simulátor neimplementuje.</p>
<h2><a class="header" href="#požadavek-2" id="požadavek-2">Požadavek:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;GPIO.SET&quot;</td><td>-</td></tr>
<tr><td>1</td><td>int16</td><td>mask</td><td>-</td></tr>
<tr><td>2</td><td>bool</td><td>dir</td><td>-</td></tr>
</tbody></table>
<p>dir obsahuje 1 pro input, 0 pro output</p>
<h2><a class="header" href="#odpověď-2" id="odpověď-2">Odpověď:</a></h2>
<p>žádná</p>
<h1><a class="header" href="#gpioget" id="gpioget">GPIO.GET</a></h1>
<p>Příkaz přečte aktuální stav na digitálním portu desky MAINBOARD. Pole <code>mask</code> v odpovědi obsahuje aktuální hodnotou čtenou
na portu GPIO (všech 16 bitů). Pakliže je v požadavku specifikována maska, je tato na výsledek aplikována.</p>
<p>mask = mask &amp; GPIO.read()</p>
<p>Simulátor neimplementuje.</p>
<h2><a class="header" href="#požadavek-3" id="požadavek-3">Požadavek:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;GPIO.GET&quot;</td><td>-</td></tr>
<tr><td>1</td><td>int16</td><td>mask</td><td>-</td></tr>
</tbody></table>
<p>Pole mask není v požadavku povinné.</p>
<h2><a class="header" href="#odpověď-3" id="odpověď-3">Odpověď:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;GPIO.GET&quot;</td><td>-</td></tr>
<tr><td>1</td><td>int16</td><td>mask</td><td>-</td></tr>
</tbody></table>
<h1><a class="header" href="#gpioset" id="gpioset">GPIO.SET</a></h1>
<p>Simulátor neimplementuje.</p>
<h2><a class="header" href="#požadavek-4" id="požadavek-4">Požadavek:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;GPIO.SET&quot;</td><td>-</td></tr>
<tr><td>1</td><td>int16</td><td>mask</td><td>-</td></tr>
<tr><td>2</td><td>int16</td><td>val</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#odpověď-4" id="odpověď-4">Odpověď:</a></h2>
<p>žádná</p>
<h1><a class="header" href="#help" id="help">HELP</a></h1>
<p>Po přijetí této zprávy server odpoví seznamem všech podporovaných příkazů, oddělených čárkou</p>
<h2><a class="header" href="#požadavek-5" id="požadavek-5">Požadavek:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;HELP&quot;</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#odpověď-5" id="odpověď-5">Odpověď:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;HELP&quot;</td><td>-</td></tr>
<tr><td>1 ... x</td><td>text</td><td>příkaz</td><td>-</td></tr>
</tbody></table>
<p>V odpovědi je seznam podporovaných příkazů serverem</p>
<h1><a class="header" href="#kill" id="kill">KILL</a></h1>
<p>Po přijetí této zprávy se server řízeně ukončí a nadále nepřijímá další příkazy.</p>
<h2><a class="header" href="#požadavek-6" id="požadavek-6">Požadavek:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;KILL&quot;</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#odpověď-6" id="odpověď-6">Odpověď:</a></h2>
<p>žádná</p>
<h1><a class="header" href="#led" id="led">LED</a></h1>
<p>Robot blikne nakonfigurovanou LED dobou svitu stanovenou v milisekundách.</p>
<p>V okamžiku překrývajících se bliknutí se prodlužuje doba svitu o stanovený čas.</p>
<p>Simulátor neimplementuje.</p>
<h2><a class="header" href="#požadavek-7" id="požadavek-7">Požadavek:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;LED&quot;</td><td>-</td></tr>
<tr><td>1</td><td>int</td><td>ms</td><td>ms</td></tr>
</tbody></table>
<p>Argument není nutné použit, led pak blikne s dobou 100ms.</p>
<h2><a class="header" href="#odpověď-7" id="odpověď-7">Odpověď:</a></h2>
<p>žádná</p>
<h1><a class="header" href="#odo" id="odo">ODO</a></h1>
<h2><a class="header" href="#požadavek-8" id="požadavek-8">Požadavek:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;ODO&quot;</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#odpověď-8" id="odpověď-8">Odpověď:</a></h2>
<p>Požaduje od serveru zjištění ujeté vzdálenosti obou motorů v mikrokrocích od posledního zavolání tohoto příkazu, Odpoví zprávou <code>ODO</code><br />
s následujícími hodnotami:</p>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;ODO&quot;</td><td>-</td></tr>
<tr><td>1</td><td>int64</td><td>left</td><td>ukrok</td></tr>
<tr><td>2</td><td>int64</td><td>right</td><td>ukrok</td></tr>
</tbody></table>
<p>Poznámka: Reálný robot počítá pouze s 32bitovým intem, kdežto simulátor se 64bitovým !</p>
<h1><a class="header" href="#ping" id="ping">PING</a></h1>
<p>Server odešle odpověď <code>PONG</code> obsahující stejn0 argumenty, jaké byly zadány ve zprávě <code>PING</code>. Slouží k ladění NMEA komunikace, a k
ověření Round-Trip-Time (RTT) serveru (časového zpoždění mezi serverem a klientem). Výpočet RTT si musí klient (studenti) obhospodařit
sám.</p>
<h2><a class="header" href="#požadavek-9" id="požadavek-9">Požadavek:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;PING&quot;</td><td>-</td></tr>
<tr><td>1 ... x</td><td>libovolný</td><td>argumenty</td><td>-</td></tr>
</tbody></table>
<p>Pole argumenty je volitelné a nemusí být ve zprávě obsaženo</p>
<h2><a class="header" href="#odpověď-9" id="odpověď-9">Odpověď:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;PONG&quot;</td><td>-</td></tr>
<tr><td>1 ... x</td><td>libovolný</td><td>argumenty</td><td>-</td></tr>
</tbody></table>
<p>pole argumenty obsahuje všechny argumenty které byly obsaženy ve zprávě PING</p>
<h1><a class="header" href="#pwm" id="pwm">PWM</a></h1>
<h2><a class="header" href="#požadavek-10" id="požadavek-10">Požadavek:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;PWM&quot;</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#odpověď-10" id="odpověď-10">Odpověď:</a></h2>
<h1><a class="header" href="#reset" id="reset">RESET</a></h1>
<p>Po přijetí této zprávy se server nastaví na výchozí konfiguraci.</p>
<p>Simulátor:</p>
<ul>
<li>pozice</li>
</ul>
<p>Robot:</p>
<ul>
<li>konfigurace ADC</li>
<li>konfigurace GPIO</li>
</ul>
<h2><a class="header" href="#požadavek-11" id="požadavek-11">Požadavek:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;RESET&quot;</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#odpověď-11" id="odpověď-11">Odpověď:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;RESET&quot;</td><td>-</td></tr>
<tr><td>1</td><td>text</td><td>výsledek</td><td>-</td></tr>
</tbody></table>
<p>Pakliže byla operace úspěšná, navrací <code>DONE</code>, při neúspěchu navrací <code>ERROR</code> nebo <code>FAILED</code> v poli výsledek</p>
<h1><a class="header" href="#sensor" id="sensor">SENSOR</a></h1>
<p>Požaduje od serveru změření hodnoty A/D převodníkem s daným indexem.</p>
<h2><a class="header" href="#požadavek-12" id="požadavek-12">Požadavek:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;SENSOR&quot;</td><td>-</td></tr>
<tr><td>1</td><td>int</td><td>index</td><td>0-7 bez rozměru</td></tr>
</tbody></table>
<h2><a class="header" href="#odpověď-12" id="odpověď-12">Odpověď:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;SENSOR&quot;</td><td>-</td></tr>
<tr><td>1</td><td>int</td><td>index</td><td>0-7 bez rozměru</td></tr>
<tr><td>2</td><td>int</td><td>value</td><td>bez rozměru</td></tr>
</tbody></table>
<p>Index udává pořadové číslo senzoru a value udává 12-bitové číslo změřené A/D převodníkem na daném senzoru.</p>
<h1><a class="header" href="#servo" id="servo">SERVO</a></h1>
<h2><a class="header" href="#požadavek-13" id="požadavek-13">Požadavek:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;PWM&quot;</td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="#odpověď-13" id="odpověď-13">Odpověď:</a></h2>
<h1><a class="header" href="#speed" id="speed">SPEED</a></h1>
<h2><a class="header" href="#požadavek-14" id="požadavek-14">Požadavek:</a></h2>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;SPEED&quot;</td><td>-</td></tr>
<tr><td>1</td><td>float</td><td>left</td><td>ukrok / sec</td></tr>
<tr><td>2</td><td>float</td><td>right</td><td>ukrok / sec</td></tr>
</tbody></table>
<p>Server nastaví rychlost levého i pravého kola v mikrokrocích za sekundu na požadovanou hodnotu.</p>
<p>Tato hodnota je držena po dobu 1sec a poté je motor odpojen od napájení (bezpečnost). Je třeba zprávu opakovat pro kontinuální chod.</p>
<h2><a class="header" href="#odpověď-14" id="odpověď-14">Odpověď:</a></h2>
<p>Simulátor odpoví zprávou &quot;OK&quot;, Reálný robot neodpoví nic.</p>
<table><thead><tr><th>argument</th><th>formát</th><th>proměnná</th><th>jednotka</th></tr></thead><tbody>
<tr><td>0</td><td>text</td><td>&quot;OK&quot;</td><td>-</td></tr>
</tbody></table>
<h1><a class="header" href="#nmea---utilita" id="nmea---utilita">nmea - utilita</a></h1>
<p>slouží pro ověření funkčnosti zpráv (na vyzkoušení že vše funguje jak má. Po spuštění v interaktivním režimu je emulována konzole, uživatel může ručně zadat<br />
NMEA příkaz (bez počátečního $ a části s CRC s hvězdičkou. Program spočítá správné CRC a odešle jej na daný UDP port. (vypíše celou zprávu včetně správného CRC)</p>
<p>Příkaz slouží zejména pro ověření že správně počítáte CRC a že vám běží server (oddělení chyb špatně spuštěného simulátoru od vaší chyby v programu).</p>
<p>Příkaz je doporučeno ručně nainstalovat (zkopírovat) do <code>/usr/bin</code> dle platformy. Na platformě raspberry pi si soubor <code>nmea_armhf</code> před zkopírováním do <code>/usr/bin</code> přejmenujte na <code>nmea</code>. identicky pro <code>x86</code> a <code>arm64</code> na osobním počítači</p>
<h2><a class="header" href="#spouštěcí-argumenty" id="spouštěcí-argumenty">Spouštěcí argumenty</a></h2>
<pre><code class="language-shell">nmea [--help] [--version] [--local=&lt;udp port&gt;] [--remote=]&lt;ip addr&gt;/&lt;udp port&gt;
</code></pre>
<p>Jednotlivé argumenty příkazové řádky:</p>
<p><code>--help</code> : Vypiš stručnou nápovědu a ukonči se</p>
<p><code>--version</code> : Vypiš aktuální verzi nástroje a ukonči se.</p>
<p><code>--local=&lt;udp port&gt;</code> : nastaví lokální číslo UDP portu na kterém má naslouchat (default: 6667). <code>&lt;udp port&gt;</code> musí být celé číslo v rozsahu 1024 - 65535. UDP port nesmí být na lokálním počítači obsazený. Pro použití portu pod <code>1024</code> je potřeba program spustit jako <code>sudo</code>.</p>
<p><code>--remote=&lt;ip addr&gt;/&lt;udp port&gt;</code> nebo <code>&lt;ip addr&gt;/&lt;udp port&gt;</code> : <strong>povinný parametr</strong>. Nastaví adresu a port vzdáleného počítače. IP adresa musí být specifikovaná číselně v tečkové konvenci (např 127.0.0.1), DNS překlad není podporován. Port musí být celé číslo v rozsahu 1024-65535. Oddělovač adresy a portu je lomítko z důvodu budoucí kompatibility s IPv6 (adresa ipv6 má dvojtečku jako oddělovač částí takže nejde použít pro oddělení části portu od adresy). Adresy IPv6 prozatím nejsou podporovány, ale je na ně příprava. Pro použití portu pod <code>1024</code> je potřeba program spustit jako <code>sudo</code></p>
<h2><a class="header" href="#příklad-použití-pro-spojení-s-reálným-robotem" id="příklad-použití-pro-spojení-s-reálným-robotem">Příklad použití pro spojení s reálným robotem</a></h2>
<p>V následujícím příkladu se komunikuje s reálným robotem na adrese 10.16.0.247 na portu 6666. uživatel zadal na klávesnici <code>BEEP</code> a stiskl enter, <code>PING</code> a stiskl enter. Je vidět odeslaná zpráva i přijatá zpráva od serveru.</p>
<pre><code class="language-shell">bufran@pcburian:~$ nmea 10.16.0.247/6666
NMEA sender v 0.2 (c) 2022 Frantisek Burian
 communicating with remote 10.16.0.247/6666
 using local port 6667
 Press Ctrl-C to exit
&gt; BEEP                                                   
[ 10.16.0.247/6666 TX] $BEEP*12
&gt; PING                                                   
[ 10.16.0.247/6666 TX] $PING*10
[ 10.16.0.247/6666 RX] $PONG*16                          
&gt;                                                        
</code></pre>
<h2><a class="header" href="#příklad-použití-pro-testování-protokolu-nmea" id="příklad-použití-pro-testování-protokolu-nmea">Příklad použití pro testování protokolu NMEA</a></h2>
<p>Protože program zprávy nijak neinterpretuje je vhodným adeptem pro ladění protokolu.</p>
<p>Nejprve spustíme terminál s programem NMEA, a jako cíl zadáme lokální adresu a port ukazující na číslo které jsme zadali v <code>bind</code> uživatelského programu (zde např <code>1234</code>)</p>
<pre><code class="language-shell">bufran@pcburian:~$ nmea 127.0.0.1/1234
NMEA sender v 0.2 (c) 2022 Frantisek Burian
 communicating with remote 127.0.0.1/1234
 using local port 6667
 Press Ctrl-C to exit
&gt;                                                        
</code></pre>
<p>V kodu aplikace kterou ladíme zapíšeme spojení s programem NMEA a portem, který program nmea vypsal (v příkladu <code>6667</code>, tedy adresa <code>127.0.0.1/6667</code>). Nezapomeneme bind na zvolený port (v příkladu <code>1234</code>)</p>
<p>Vše co Vaše aplikace odešle se zobrazí v terminálu NMEA, pakliže je v pořádku CRC (pokud se nic nezobrazí. máte špatné CRC). Vše co odešlete z terminálu NMEA bude zabaleno do protokolu a odesláno Vaší aplikaci.</p>
<p>Pakliže se nic nezobrazuje, je vhodné se podívat co odesíláte (např výpisem do terminálu, wiresharkem)</p>
<h1><a class="header" href="#robot" id="robot">robot</a></h1>
<p>Program, který je spouštěn z příkazové řádky na fyzickém hardware a zpřístupňuje prostředky robotu přes NMEA protokol</p>
<h1><a class="header" href="#cviceni" id="cviceni">Cviceni</a></h1>
<h1><a class="header" href="#instalace-a-seznámení-se-s-prostředím" id="instalace-a-seznámení-se-s-prostředím">Instalace a seznámení se s prostředím</a></h1>
<p>Cvičící: Ing. Adam Ligocki</p>
<h2><a class="header" href="#instalace-linux-cca-45min" id="instalace-linux-cca-45min">Instalace Linux (cca 45min)</a></h2>
<p>Nainstalujte si operační systém Linux Ubuntu 20.04 na fyzický stroj (preferovaná varianta), případně jako alternativu si vytvořte virtální stroj pomocí VirtualBoxu a operační systém si nainstalujte zde.</p>
<p>Návod naleznete zde <a href="cviceni/../chap_1_software/text/vb.linux_installation.html">Příprava prostředí</a></p>
<p>✅ Senzamte se se GUI systému.</p>
<p>✅ Otevřete si příkazový řádek, vyzkoušejtesi pohyb v souborovém systému</p>
<p>✅ Vytovřte, smažte soubor/složku</p>
<p>✅ Pomocí balíčkovacího manažeru si nainstalujte git, midnight commander (mc). Pro odvážné také textový editor vim</p>
<details>
    <summary>Nainstaloval jsem si vim a omylem jej zapnul. Co teď?</summary>
<p>Vim vypnete touto sekvencí: stiskněte ESC, pak jej pusťte, přidržte LSHITF a dakrát klávesu 'Z'.</p>
<p>Pro zájemce, tutorilál práce s vim: <a href="https://www.openvim.com/">zde</a></p>
</details>
<h2><a class="header" href="#instalace-ros-cca-45min" id="instalace-ros-cca-45min">Instalace ROS (cca 45min)</a></h2>
<p>Projděte si návod na <a href="cviceni/../chap_1_software/text/ros.html">Robotic Operating System</a>. Zde si nastudujte přibližný princip fungování systému ROS aby jste později chápali jeho základní mechanizmy. </p>
<p>Podle návodu si nainstalujte ROS na svůj čerstně nainstalovaný operační systém.</p>
<p>Detailní přednáška na práci s ROSem bude v druhé polovině semestru.</p>
<p>✅ Zavolejte z terminálu příkaz roscore. Měl by se objevit výpis o startu programu. Neměly by být přítomny žádné chybové hlášky</p>
<p>✅ Voláním přžíkazu rviz ověřte, že Vám nastartuje vizualizařní program RVIZ (paralelně musí běžet roscore).</p>
<h2><a class="header" href="#instalace-clion-cca-30-min" id="instalace-clion-cca-30-min">Instalace CLion (cca 30 min)</a></h2>
<p>Nainstalujte si CLion pomocí balíčkovacího manageru Snap</p>
<pre><code class="language-shellscript">sudo snap install --classic clion
</code></pre>
<p>nebo z <a href="https://www.jetbrains.com/clion/">oficiálního webu</a> si stáhněte IDE CLion a seznamte se s ním (viz <a href="cviceni/../chap_1_software/text/clion.html">CLion IDE</a>). Registrací pomocí školního emailu získáte licenci na užití softwaru zdarma.</p>
<p>✅ Pouze prací v konzole si vytvořte jednoduchý hello world program a zkompilujte jej pomocí volání g++ kompilátoru. Otestujte funkčnost programu.</p>
<p>✅ Tentýž hello world program realizujte ve vývojovém prostředí CLion. Zkompilujte jej a ověřte jeho funkčnost.</p>
<p>✅ Diskutujte výhody práce s IDE oproti kompilaci v příkazovém řádku.</p>
<h3><a class="header" href="#záložní-plán" id="záložní-plán">Záložní plán</a></h3>
<p>Předinstalovaný obraz Ubuntu 20.04 s ROSem pro VB</p>
<p>https://drive.google.com/file/d/1_wCduSS30O7lHB2oYQVEErgrPAWc1ALR/view?usp=sharing</p>
<h1><a class="header" href="#instalace-a-seznámení-se-s-prostředím-1" id="instalace-a-seznámení-se-s-prostředím-1">Instalace a seznámení se s prostředím</a></h1>
<p>Cvičící: Ing. Adam Ligocki, Ph.D., Ing. Tomáš Horeličan</p>
<h2><a class="header" href="#linux-command-line-interface---cli-cca-45min" id="linux-command-line-interface---cli-cca-45min">Linux Command Line Interface - CLI (cca 45min)</a></h2>
<p>V první řadě si projděte kapitolu <a href="cviceni/../chap_1_software/text/linux.html">Linux a příkazová řádka</a>. Následně si procvičte použití příkazů
několika cvičnými úlohami:</p>
<p>Tip: při psaní příkazů používejte TAB pro doplnění příkazu a TAB-TAB pro výpis všech možných doplnění příkazů. </p>
<p>✅ Zjistěte, kde se momentálně necházíte v rámci souborového systému</p>
<p>✅ Přepněte se do svého domovského adresáře</p>
<p>✅ Vytvořte si složku ve které bude projekt pro dnešní cvičení</p>
<p>✅ Následně v této složce vytvořte několik podsložek tak, aby struktura vypadala následovně (příkaz tree):</p>
<pre><code>/MyProject
 |--build
 |--include
 | \-- MyProject
 \--src
</code></pre>
<p>✅ Ve Vašem domovském adresáři si pomocí textového editoru (nano nebo vim) vytvořte soubory main.cpp, lib.hpp a CMakeLists.txt</p>
<p>✅ Soubor main.cpp přesuňte (nikoliv zkopirujte) do podsložky &quot;src&quot;</p>
<p>✅ Soubor lib.hpp přesuňte do podsložky &quot;include/MyProject&quot;</p>
<p>✅ Soubor CMakeLists.txt přesuňte do hlavní složky projektu</p>
<p>Nyní by měl Váš projekt mít tuto podobu:</p>
<pre><code>/MyProject
 |--build
 |--CMakeLists.txt
 |--include
 | \--MyProject
 |   \--lib.hpp
 \--src
   \--main.cpp
</code></pre>
<p>✅ Pomocí textového editoru napište v souboru lib.hpp funkci, která vypíše pozdrav do konzole.</p>
<p>✅ Zeditujte CMakeLists.txt na následjící obsah:</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.10)
project(MyProject)
set(CMAKE_CXX_STANDARD 17)
include_directories(include/)
add_executable(hello_world_program src/main.cpp)
</code></pre>
<p>Významem jednotlivých direktiv se budeme zabývat později.</p>
<p>✅ Nyní se přesuňte do složky &quot;build&quot; a zde zavolejte příkaz</p>
<pre><code class="language-shell">cmake ..
</code></pre>
<p>CMake si přečte nastavení vašeho projektu, a připraví makefile pro následnou kompilaci.</p>
<p>✅ Příkazem make zkompilujte program.</p>
<p>✅ vypište si obsah složky build.</p>
<p>✅ Pokud kompilace proběhla úspěšně, spustěte program voláním &quot;./hello_world_program&quot;.</p>
<p>✅ Optional: vyzkoušejte si kompilaci i přímo pomocí volání g++.</p>
<pre><code class="language-shell">g++ &lt;source1 source2 source3 ...&gt; -I &lt;include_directory&gt; -o &lt;output_binary&gt; 
</code></pre>
<p>✅ Smažte celou složku s projektem (pozor, složky se mažou rekurzivně).</p>
<h2><a class="header" href="#clion-a-c-cca-15h" id="clion-a-c-cca-15h">CLion a C++ (cca 1.5h)</a></h2>
<p>✅ Vytvořte identický CMake projekt z minulého bodu zadání pomocí CLionu. Progam zkompilujte a otestujte.</p>
<p>Detail k CLionu <a href="cviceni/../chap_1_software/text/clion.html">zde</a>.</p>
<h3><a class="header" href="#stl-structures" id="stl-structures">STL Structures</a></h3>
<p>Součástí jazyka C++ je tzv. Standard Template Library (STL). Ta obsahuje širokou paletu různých datových struktur a naimplementovaných fukncí.
My se dnes zaměříme na část která implementuje datové konteinery.</p>
<p>Knihovna obsahuje implementace pro pole, zásobník, vektor, frontu, list, množinu, mapu (hash_tabulku/dictionary), atd. <a href="https://en.cppreference.com/w/cpp/container">Dokumentace zde</a>.</p>
<p>My se dnes zamšříme na tři struktury, a totiž std::array, std::vector a std::queue.</p>
<p>Struktury se mezi sebou liší a každá je vhodná pro jiný účel. std::array je struktura v paměti, která má známou svou velikost již během kompilace.
Pokusme se nyní takové pole vytvořit, naplnit jej hodnotami a vypočítat průměr.</p>
<pre><code class="language-cpp">    #include &lt;array&gt;

    auto my_array = std::array&lt;int, 5&gt;{0, 1, 2, 3, 4};
    int sum = 0;
    for (const auto&amp; val : my_array) {
        sum += val; 
        // sum += my_array.at(i); // equivalent approach
    }
    auto avg = sum / my_array.size();
</code></pre>
<p>Vektor se od pole liší tím, že má proměnnou velikost. Vždy když se naplní, tak se automaticky naalokuje navíc jednonásobek jeho současné velikosti.</p>
<p>Vyzkoušíme si naplnit vektor několika hodnotami a najít medián těchto hodnot.</p>
<pre><code class="language-cpp">    #include &lt;vector&gt;
    #include &lt;algorithm&gt;
    
    auto my_vector = std::vector&lt;float&gt;{};
    my_vector.push_back(5.4);
    my_vector.push_back(-3.7);
    my_vector.push_back(10.9);
    my_vector.push_back(1.3);
    my_vector.push_back(-6.5);
    my_vector.push_back(-7.8);
    my_vector.push_back(6.4);

    std::sort(my_vector.begin(), my_vector.end());
    auto med = my_vector.at(my_vector.size()/2);
    my_vector.clear();
</code></pre>
<p>Strukturu fronty využijeme jako buffer v ilustračním scénáří zpracování příchozích dat z UDP.
Uvažujme multivláknový program. Jedno vlákno přijmá data po UDP a plní frontu. Druhé vlákno pracuje asynchronně a vždy,
když přijde na řadu, zpracuje všechny doposud přijaté zprávy v pořadí tak, jak příšly.</p>
<pre><code class="language-cpp">    #include &lt;queue&gt;
        
    // queue shared between threads; Tip: mutex ?!
    auto my_queue = std::queue&lt;std::string&gt;{};
    
    // receive thread filling queue with messages
    my_queue.push(&quot;Message1&quot;);
    my_queue.push(&quot;Message2&quot;);
    my_queue.push(&quot;Message3&quot;);

    // message processing thread
    void parse_message(const std::string&amp; s) {
        std::cout &lt;&lt; &quot;Parsing: &quot; &lt;&lt; s &lt;&lt; std::endl;
    }

    while (!my_queue.empty()) {
        parse_message(my_queue.front());
        my_queue.pop();
    }
</code></pre>
<h3><a class="header" href="#reference-1" id="reference-1">Reference</a></h3>
<p>Reference, někdy také nazývané &quot;alias&quot;, je datový typ, který směřuje (je aliasem) na již existujicí objekt v paměti. 
Při kompilaci je reference obvykle nahrazena ukazatelem, ale z pohledu programátora se jedná o výrazně bezpečnější formu
práce s daty a, či objekty, protože nedovoluje některé nebezpečné operace.</p>
<p>Reference se liší od ukazatele ve dvou základních vlastnostech:</p>
<ul>
<li>Nemůže být NULL; reference je vždy nainicializovaná</li>
<li>Reference se nemůže přesměrovat na jiný objekt/data.</li>
</ul>
<p>Pozor, nezaměňovat datový typ reference &quot;<T>&amp;&quot; s operátorem reference &quot;&amp;variable&quot; !</p>
<pre><code class="language-cpp">    int a = 5;
    int&amp; b = a;
    const int&amp; c = a;
    b = 10;
    c = 15 // invalid (const ref)
    std::cout &lt;&lt; a &lt;&lt; std::endl; // a == 10
</code></pre>
<p>Reference je často používaná pro předání argumentů fukce bez nutnosti kopírování, či pro sdílení jedněch dat mezi více místy v programu.</p>
<pre><code class="language-cpp">    class VeryLargeObject {
    public:
        VeryLargeObject() {}
        const std::array&lt;double, 10000&gt;&amp; data() const {return data_;}
    private:
        std::array&lt;double, 10000&gt; data_;
    };
    
    void porocess_large_data(const VeryLargeObject&amp; d) {
        auto&amp; data = d.data(); // const reference
        auto data = d.data(); // mutable copy
        // ...
    }
    
    auto vlo = VeryLargeObject{};
    porocess_large_data(vlo);
</code></pre>
<p>Reference je často pužívaná pro vrácení hodnot z funkce skrze argument funkce.
Nejedná se však o best-practice metodu. Pokud je to jen trochu možné, měla by metoda vracet hodnotu skrze návratovou 
hodnotu. Pokud je potřeba vrátit více hodnot, použijte strukturu jako návratový typ.</p>
<pre><code class="language-cpp">    void ops(float a, float b, float&amp; sum, float&amp; sub, float&amp; mul, float&amp; div) {
        sum = a + b;
        sub = a - b;
        mul = a * b;
        div = a / b;
    }

    float sum, sub, mul, div;
    ops(5, 10, sum, sub, mul, div);
    std::cout &lt;&lt; sum &lt;&lt; &quot; &quot; &lt;&lt; sub &lt;&lt; &quot; &quot; &lt;&lt; mul &lt;&lt; &quot; &quot; &lt;&lt; div &lt;&lt; std::endl;
</code></pre>
<h3><a class="header" href="#smart-pointers" id="smart-pointers">Smart Pointers</a></h3>
<p>Smart pointery jsou náhradou C-čkových ukazatelů. V základu máme 3 typy těchto smart ukazatelů:</p>
<ul>
<li>std::unique_ptr&lt;T&gt;</li>
<li>std::shared_ptr&lt;T&gt;</li>
<li>std::weak_ptr&lt;T&gt;</li>
</ul>
<p>kde T je datový typ na který bude ukazatel ukazovat.</p>
<p>Vyhodou smart pointerů je, že nemusíme jako programátoři bezprostředně řešit alokaci a zejména uvolnění paměti. 
Jsou li splněny podmínky, smartpointer během svého zániku zavolá také destruktor objektu, na který ukazoval a uvolní naalokovanou paměť.</p>
<p>Výsledkem je, že programátoru už nemusí používat klíčová slova <code>new</code> a <code>delete</code>.</p>
<p>Každý ze smart pointerů se však mírně liší.</p>
<h4><a class="header" href="#stdunique_ptrt" id="stdunique_ptrt">std::unique_ptr&lt;T&gt;</a></h4>
<p>std::unique_ptr<T> je nejtriviálnější implementací smart pointeru. Smart pointer je vlastníkem objektu na který ukazuje a 
neumožní toto vlastnictví (ownership) předat jinému ukazateli. Když unique_ptr zanikne, zavolá destruktor nad vlasněným objektem a dealokuje paměť.</p>
<pre><code class="language-cpp">    #include &lt;memory&gt;

    auto unique_int = std::make_unique&lt;int&gt;(5);
    std::cout &lt;&lt; *unique_int &lt;&lt; std::endl;

    float x = 10;
    auto unique_float = std::make_unique&lt;float&gt;(x);
    std::cout &lt;&lt; *unique_float &lt;&lt; std::endl;

    std::unique_ptr&lt;float&gt; y = unique_float; // error
</code></pre>
<h4><a class="header" href="#stdshared_ptrt" id="stdshared_ptrt">std::shared_ptr&lt;T&gt;</a></h4>
<p>std::shared_ptr<T> je příkladem tzv. Automatic Reference Counter (ACR). Idea je, že při vzniku objektu se vytvoří také čítač, který čítá kolik shared_pointerů na tento objekt ukazuje.
Když vytvářím nové kopie shared pointeru, čítač roste, když tyto smart pointery zanikají, hodnota čítače klesá.</p>
<p>Když čítač dosáhne nuly, to znamená, že na objekt už nic neukazuje, je automaticky zavolán destruktor a je uvolněná paměť.</p>
<p>Pozor, nezaměňovat s Garbage Collectorem (GC), ten funguje výrazně jinak.</p>
<p>Pozor na cyklické vazby. Pokud dva objekty na sebe navzájem ukazují shared pointerem, ani jeden z objektů nikdy nezanikne. Proto zde máme weak pointery.</p>
<pre><code class="language-cpp">    #include &lt;memory&gt;
    
    auto shared_int = std::make_shared&lt;int&gt;(10);
    std::cout &lt;&lt; *shared_int &lt;&lt; std::endl;
    
    std::shared_ptr&lt;int&gt; x = shared_int;
</code></pre>
<h4><a class="header" href="#stdweak_ptrt" id="stdweak_ptrt">std::weak_ptr&lt;T&gt;</a></h4>
<p>Obdoba shared_ptr, ale neinkrementuje čitač, který počítá, kolik je platných ukazatelů na daný objekt. To znamená, že pokud na objekt ukazuje 5 weak_ptr a žáden shared_ptr, objekt zanikne.</p>
<h3><a class="header" href="#oop" id="oop">OOP</a></h3>
<p>Při tvorbě Vaších programů se snažte dodržovat OOP paradigma. Přemýšlejte o programu, jako o sadě black-boxů, kdy tyto schránky 
jsou každá zaměřená na velmi specifický problém. Každou Vaší třídu by měla vystihovat jedna věta. Stejně tak každá funkce
by měla dělat právě jednu věc a nic víc.</p>
<p>Zmíněné blackboxy jsou mezi sebou propojeny a navzájem si předávají data.</p>
<p>Vyhněte se tvorbě &quot;supertříd&quot;, tedy tříd, které řeší &quot;všechno&quot;. Mějte své třídy úzce specializované.</p>
<p>Běžně by se měla třída vměstnant do 100 řádku. Pokud je třída nad 300 řádků, silně zvažte její rozdělení na více tříd.</p>
<p>Oddělte data od algoritmů. Vytvořte si oddělené třídy, které v sobě mají uložená data a oddelené třídy, které implementují algoritmy pro zpracování dat.</p>
<h4><a class="header" href="#příklad" id="příklad">Příklad</a></h4>
<p>Naimplementujte příklad pomocí OOP C++. Při implementaci využijte reference a smart pointery.</p>
<p>Mějme univerzitu. Každá univerzita má 5 ročníků, v každém ročníku je libovolný počet studentů.
Když studenti nastupují na univerzitu, jsou automaticky zařazeni do 1. ročníku. Vždy, když proběhne rok, 
tak univerzita prozkouší všechny studenty v ročnících a s pravděpodobností 0.9 posune studenta do vyžšího ročníku. Pokud student projde pátý ročníku, 
univerzita si jej zaznamená jako absolventa.
Na konci každého roku vytiskněte stav univerzity a všech studentů na ní.</p>
<p>Tip: Třídy a jejich členské proměnné:</p>
<pre><code>Trida Student:
promenne:
    jmeno, 
    prijmeni
metody:
</code></pre>
<pre><code>Trida Rocnik:
proměnné:
    seznam_vsech_studentu
metody:
    pridat_studenta_do_rocniku(student)
    evaluovat_ročník() -&gt; seznam_uspesnych_studentu
</code></pre>
<pre><code>Třída Univezita:
proměnné:
    seznam_rocniku
    seznam absolventu
metody:
    vykonat_akademicky_rok()
    vytisknout_stav_univerzity();
</code></pre>
<p>Implementace:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;array&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;random&gt;

class Student {
public:
    Student(const std::string&amp; first_name, const std::string&amp; surname)
        : first_name_{first_name}
        , surname_{surname} {}
    std::string first_name() const {return first_name_;};
    std::string surname() const {return surname_;};
private:
        const std::string first_name_;
        const std::string surname_;
    };
    
    
class Grade {
        static constexpr float change_of_student_passes_grade = 0.8f;
public:
    void add_student(std::shared_ptr&lt;Student&gt; stud) {students_.push_back(stud);}
    std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; evaluate_year() {
        std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; successful_students{};
        std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; failed_students{};
        for (auto&amp; stud : students_) {
            auto random_num = get_random_number(0.0f, 1.0f);
            if (random_num &gt; change_of_student_passes_grade) {
                failed_students.push_back(stud);
            }
            else {
                successful_students.push_back(stud);
            }
        }
        students_ = failed_students;
        return successful_students;
    }
    std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; students() const {return students_;}
    float get_random_number(float min, float max) {
        static std::random_device rd;
        static std::mt19937 gen(rd());
        static std::uniform_real_distribution&lt;float&gt; distr(min, max);
        return distr(gen);
    }
private:
    std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; students_;
};
    
    
class University {
    static constexpr size_t no_of_grades = 5;
public:
    void add_student(std::shared_ptr&lt;Student&gt; stud) {grades_.at(0).add_student(stud);}
    void evaluate_year() {
        for (int i = no_of_grades-1 ; i &gt;= 0 ; i--) {
            auto successfull_studs = grades_.at(i).evaluate_year();
            if (i == no_of_grades-1) { // last grade
                for (auto&amp; stud : successfull_studs) {graduated_.push_back(stud);}
            } else {
                for (auto&amp; stud : successfull_studs) {grades_.at(i+1).add_student(stud);}
            }
        }
    }
    void print_state() {
        for(size_t i = 0 ; i &lt; no_of_grades ; i++) {
            std::cout &lt;&lt; &quot;    Grade:&quot; &lt;&lt; i+1 &lt;&lt; std::endl;
            auto studs = grades_.at(i).students();
            for (const auto&amp; stud : studs) {
                std::cout &lt;&lt; &quot;       &quot; &lt;&lt; stud-&gt;first_name() &lt;&lt; &quot; &quot; &lt;&lt; stud-&gt;surname() &lt;&lt; std::endl;
            }
        }
        std::cout &lt;&lt; &quot;    Graduated:&quot; &lt;&lt; std::endl;
        for (const auto&amp; stud : graduated_) {
            std::cout &lt;&lt; &quot;       &quot; &lt;&lt; stud-&gt;first_name() &lt;&lt; &quot; &quot; &lt;&lt; stud-&gt;surname() &lt;&lt; std::endl;
        }
    }
private:
    std::array&lt;Grade, no_of_grades&gt; grades_;
    std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; graduated_;
};
    
int main() {
    University Oxenfurt;
    Oxenfurt.add_student(std::make_shared&lt;Student&gt;(&quot;Triss&quot;, &quot;Merigold&quot;));
    Oxenfurt.add_student(std::make_shared&lt;Student&gt;(&quot;Geralt&quot;, &quot;of Rivia&quot;));
    Oxenfurt.add_student(std::make_shared&lt;Student&gt;(&quot;Zoltan&quot;, &quot;Chivay&quot;));
    Oxenfurt.add_student(std::make_shared&lt;Student&gt;(&quot;Yennefer&quot;, &quot;of Vengerberg&quot;));
    Oxenfurt.add_student(std::make_shared&lt;Student&gt;(&quot;Cirilla&quot;, &quot;of Cintra&quot;));
    for (size_t i = 0 ; i &lt; 6 ; i++) {
        std::cout &lt;&lt; &quot; ---------- &quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;Year &quot; &lt;&lt; i+1 &lt;&lt; std::endl;
        Oxenfurt.evaluate_year();
        Oxenfurt.print_state();
    }
    return 0;
}
</code></pre>
<h3><a class="header" href="#const" id="const">Const</a></h3>
<p>Rychlý přehled užití const v kódu</p>
<pre><code class="language-cpp">
    // Helpre Object
    class Object {
    public:
        void do_non_const_work() {counter++;} // non-const member method
        void do_const_work() const {std::cout &lt;&lt; counter &lt;&lt; std::endl;} // const method, can not modify member variables
    private:
        int counter = 0;
    };


     // Variables
     
    int a = 1; // mutable variable
    const int b = 2; // non-mutable (const) variable
    
    
    // References
    
    int&amp; c = a; // mutable reference to a
    const int&amp; d = a; // const reference to a
    
    
    // Pointers
    
    int* e = &amp;a;    // pointer to a
    const int* f = &amp;a;  // pointer to constant a (value of a can not be changed)
    int const* g = &amp;a;  // the same
    *f = 5; // error
    f = e;  // ok
    
    int *const h = &amp;a;  // non-mutable (const) pointer to mutable variable
    h = e;  // error
    *h = 5; // ok
    
    const int * const i = &amp;a; // const pointer to const variable
    *i = 5; // error
    i = e;  // error
    
    
    // Data Structures
    
    std::vector&lt;Object&gt; v1 = {Object{}, Object{}, Object{}};    // Vector of 3 objects
    const std::vector&lt;Object&gt; v2 = {Object{}, Object{}, Object{}};   // constant vector (can not add or remove values from it); returns const refs to object
    v2.push_back(Object{}); // error
    v2.clear(); // error
    v2.at(0).do_non_const_work(); // error
    v2.at(0).do_const_work(); // ok
    
    
    // Smart Pointers
    
    std::shared_ptr&lt;int&gt; sp1 = std::make_shared&lt;int&gt;(5); // normal shared pointer
    std::shared_ptr&lt;const int&gt; sp2 = sp1; // shared pointer to const value
    *sp2 = 5; // error
    sp2 = sp1; // ok
    const std::shared_ptr&lt;int&gt; sp3 = sp1;   // constant pointer to mutable value
    *sp3 = 5; // ok
    sp3 = sp2; // error
    const std::shared_ptr&lt;const int&gt; sp4 = sp1;
    *sp4 = 5; // error
    sp4 = sp2; // error
    
    
    // Const vs Constexpr vs Define
    
    const int x = 5; // this variable can be initialized in runtime (read user input)
    #define Y = 5 // const defined for preprocessor (non type safe)
    constexpr int y = 5; // this variable MUST be initialized in compile-time (similar to #define Y 5, but type-safe)
    
    
    // &quot;Rustification&quot;
    
    #define let const auto
    #define mut auto
    
    let a = 5;  // cosnt variable
    mut b = 3;  // mutable variable
    let&amp; c = a; // const reference
    mut&amp; d = b; // mutable reference
</code></pre>
<h1><a class="header" href="#git-simulátor" id="git-simulátor">GIT, simulátor</a></h1>
<p>Cvičící: Ing. Adam Ligocki, Ph.D., Ing. Tomáš Horeličan</p>
<h2><a class="header" href="#git-cca-1-hod" id="git-cca-1-hod">GIT (cca 1 hod)</a></h2>
<p>Každý student se nejprve zaregistruje na studentském <a href="https://student.robotika.ceitec.vutbr.cz/">GitLab serveru</a>. Doporučuji také verifikovat emailovou adresu, bude se Vám to hodiť při některých operacích.</p>
<p>Tento server bude po zbytek kurzu BPC-PRP Vás tzv. <code>origin</code>, tedy vzdálené repozitář.</p>
<p>Vyučující mají náhled do všech Vaších repozitářů, včetně jejich historii a mohou přůběžně sledovat Vaší práci, případně kdo, kdy a jak intenzivně &quot;commitoval&quot;.</p>
<p>Na serveru si můžete vytvořit repozitář, ve kterém budete následne udržovat kód po zbytek kurzu.
Nejprve je ale potřebné zajistit by Váš počítač měl k tomuto repozitáři přístup a mohl si z něj <code>&quot;pullovat&quot;</code> nové změny a <code>&quot;pushovat&quot;</code> na něj své lokálni změny.
Pro toto budete využívat SSH (Secure SHell) klíče.</p>
<h3><a class="header" href="#vytvoření-ssh-klíčů-pro-přístup-k-repozitářům" id="vytvoření-ssh-klíčů-pro-přístup-k-repozitářům">Vytvoření SSH klíčů pro přístup k repozitářům</a></h3>
<p>Pár klíčů vygenerujte pouze jeden krát na jednom počítači.</p>
<p>Klíče se ukádají lokálně na počítači a jsou pak spárované s účtem na gitlabu. Pokud tedy pracujete na školním PC, vyberte si jednoho člena týmu, který svůj účet na gitlabu s tímto párem následně v dalších krocích propojí.</p>
<p>Pokud pracujete na svém vlastním počítači postupujte s vaším vlastním gitlab účtem.</p>
<blockquote>
<p><strong><em>POZNÁMKA:</em></strong>  Kdykoliv uvidíte špicaté závorky s nějakým textem <code>&lt;text&gt;</code>, znamená to, že máte tento text včetě závorek něčím nahradit.</p>
</blockquote>
<ol>
<li>Vygenerujte si klíče pomocí příkazu <code>ssh-keygen -t ed25519 -C &quot;&lt;comment&gt;&quot;</code></li>
</ol>
<details>
    <summary>Tip!</summary>
Jako koment doporučuji zadat emailovou adresu, kterou máte spojenou s vaším gitlab účtem. Snadněji pak spoznáte k čemu klíče patří. 
</details>
<ol start="2">
<li>Poté (po vyzváni) zadejte adresářovou cestu, kam se mají klíče uložit. Doporučuji ponechat &quot;defaultni&quot; cestu
ale upravit jméno, například takto: <code>/home/&lt;user-name&gt;/.ssh/id_ed25519_gitlab_uamt_&lt;group-number&gt;</code>.</li>
</ol>
<details>
    <summary>Tip!</summary>
<p>Tá poslední část (tedy <code>id_ed25519_gitlab_uamt_&lt;group-number&gt;</code>) je jméno, se kterým se klíče vygenerují.
Můžete ho nahradit čím chcete ale musíte to samé pak taky použít v dalších krocích. Tady při psaní nepoužívejte šípky (nebudou Vám fungovat).</p>
</details>
<ol start="3">
<li>
<p>Poté (po vyzváni), pokud chcete, zadejte heslo pro zabezpečení klíče. Jinak jen potvrďte stisknutím <code>Enter</code>.</p>
</li>
<li>
<p>Otevřete soubor <code>/home/&lt;user-name&gt;/.ssh/config</code> (například v nano) a přidejte následujíci:</p>
</li>
</ol>
<pre><code># Student gitlab instance at student.robotika.ceitec.vutbr.cz
Host student.robotika.ceitec.vutbr.cz
  PreferredAuthentications publickey
  IdentityFile ~/.ssh/id_ed25519_gitlab_uamt_&lt;group-number&gt;
</code></pre>
<details>
    <summary>Tip!</summary>
Pokud jste si zvolili jiné jméno klíče, musíte ho stejně zadat i zde.
</details>
<ol start="5">
<li>Zkopírujte obsah souboru <code>/home/&lt;user-name&gt;/.ssh/id_ed25519_gitlab_uamt_&lt;group-number&gt;.pub</code></li>
</ol>
<details>
    <summary>Tip!</summary>
Pokud jste si zvolili jiné jméno klíče, musíte ho opět stejně zadat i zde.
</details>
<blockquote>
<p><strong>POZOR!</strong> Kopírujte jen ze souboru s příponou <code>.pub</code>!
Pokud má obsah více než jeden řádek a nebo začíná řádkem <code>-----BEGIN OPENSSH PRIVATE KEY-----</code>, pravdepodobne kopírujete z nesprávneho souboru!</p>
</blockquote>
<ol start="6">
<li>
<p>V gitlabu přejdete do <code>Preferences &gt; SSH Keys</code>, vložte zkopírovaný obsah, pojmenujte tady svůj klíč (např. &quot;Notebook-Ubuntu&quot;) a potvrďte stisknutím <code>Add key</code>.</p>
</li>
<li>
<p>Teď by ste meli mít z Vašeho počítače přístup ke všem Vaším (budoucím) repozitářům.
Zároveň ste se naučili jak můžete v budoucnu spravovat více různych klíčů pro různe git servery.</p>
</li>
</ol>
<p><sup>*</sup>Detailnejší návody najdete také na stránkach <a href="https://student.robotika.ceitec.vutbr.cz/help/ssh/index#generate-an-ssh-key-pair">GitLabu</a> nebo <a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh">GitHubu</a>. <br /></p>
<p>V rámci týmu si teď vyzkoušejte následujicí cvičení:</p>
<h3><a class="header" href="#základní-nastavení-gitu" id="základní-nastavení-gitu">Základní nastavení GITu</a></h3>
<p>✅ Jeden člen vytvoří repozitář na serveru přímo v gitlabu.</p>
<p>✅ Všichni členové si naklonují repozitár k sobě na PC (na školním PC klonuje, zamozřejmě, jen jeden užívatel).</p>
<details>
    <summary>Jak naklonovat vdálený repozitář?</summary>
<p><code>git clone &lt;ssh-link-to-repo.git&gt;</code></p>
</details>
<p>✅ Každý si ve svém naklonovaném repozitáři nastavi jméno a emailovou adresu, se kterýma bude do repozitáře commitovat.
Na školním PC to bude pouze ten člen, který si pro ňej pároval i SSH klíče.</p>
<details>
    <summary>Jak nastavit jméno a email?</summary>
<pre><code>git config user.name &quot;&lt;committing-user-name&gt;&quot;
git config user.email &lt;committing-user-email&gt;
</code></pre>
<p>Doporučuji nastavit stejnou emailovou adresu jakou máte ve svém gitlab účtu.</p>
</details>
<details>
    <summary>Tip!</summary>
<p>Podívejte se jak vypadá soubor <code>.git/config</code>. Nastavení můžete měnit i editováním přímo v tomto souboru.</p>
</details>
<h3><a class="header" href="#základní-git-workflow-bash" id="základní-git-workflow-bash">Základní GIT workflow (Bash)</a></h3>
<p>✅ Jeden člen týmu vytvoří na lokále hello world program, <code>&quot;commitne&quot;</code> jej a <code>&quot;pushne&quot;</code> jej na <code>origin</code>.</p>
<details>
    <summary>Jak se commituje a pushuje?</summary>
<pre><code>git add &lt;files-to-add&gt;
git commit -m &quot;my first commit&quot;
git push
</code></pre>
</details>
<details>
    <summary>Tip!</summary>
<p>Pomocí příkazů <code>git status</code> a <code>git diff</code> sledujte průběžně změny v repozitáři.</p>
</details>
<p>✅ Zbytek týmu si <code>&quot;pullne&quot;</code> změny k sobě na lokál.</p>
<details>
    <summary>Jak se pulluje?</summary>
<pre><code>git pull
</code></pre>
</details>
<p>✅ Dva členové týmu si skusí vyrobit konflikt tak, že zároveň změní stejný řádek v kódu a pokusí se jej <code>&quot;pushnout&quot;</code> na server.
Druhému v pořádí, který se pokusí o <code>push</code>, git zahlásí chybu.</p>
<p>✅ Nešťastný člen týmu, který má nahlášený konflikt, se pokusí o jeho <code>fix</code> a opravenou verzi <code>&quot;pushne&quot;</code> na origin.</p>
<details>
    <summary>Jak vyřešit konflikt?</summary>
<p>Nejprve si <code>&quot;pullnete&quot;</code> aktualni verzi z <code>&quot;originu&quot;</code>. Podívejte se co se stalo s Vaším kódem.
Upravte ho tak aby v nem bylo vše co požadujete. Opět <code>&quot;commitnete&quot;</code> a zkuste <code>&quot;pushnout&quot;</code>.</p>
</details>
<p>✅ Všichni členové týmu si <code>&quot;pullnou&quot;</code> aktuální verzi repozitáře.</p>
<p>✅ Jeden člen týmu vytvoří nový lokálni <code>branch</code>, <code>&quot;checkoutne&quot;</code> se do nej a vyrobí si vlastní <code>.h</code> soubor a v něm funkci, která vytiskne jeho jméno.
Změny standardně <code>&quot;commitne&quot;</code> a pokusí se <code>&quot;pushnout&quot;</code>.</p>
<details>
    <summary>Jak udělat branch a checkoutnout?</summary>
<pre><code>git branch &lt;name-of-the-new-branch&gt;
git checkout &lt;name-of-an-existing-branch&gt;
</code></pre>
</details>
<details>
    <summary>Tip!</summary>
<p>Co se stalo když ste se pokusili <code>&quot;pushnout&quot;</code> nový branch? Co Vám poradil <code>git</code>?</p>
</details>
<p>✅ Všichni si <code>&quot;pullnou&quot;</code> nové zmeny k sobě a <code>&quot;checkoutnou&quot;</code> se na nový branch v <code>&quot;originu&quot;</code>.
Každý člen týmu si pak vyrobí vlastní <code>.h</code> soubor a v něm taky funkci, která vytiskne jeho jméno.
Všichni <code>&quot;pushnou&quot;</code> své změny na server.</p>
<details>
    <summary>Tip!</summary>
<p>Při <code>&quot;checkoutu&quot;</code> se nažte využívat doplňování pomocí <code>Tab</code>.</p>
</details>
<p>✅ Jeden člen týmu si <code>&quot;pullne&quot;</code> nově vytvořené <code>.h</code> soubory a upraví hello world program tak aby využíval všechen nově vytvořený kód.
Změny pushne na <code>origin</code> a v gilabu vytvoří nový <code>Merge Request</code> z nového <code>&quot;branchu&quot;</code> do <code>&quot;branchu&quot; main</code>.</p>
<blockquote>
<p><strong>POZNÁMKA:</strong> Pokud ste v gitlabu ve svém repozitáři a vlevo nevidíte možnost <code>Merge requests</code>, musíte si je v nastaveních povolit.
Přejdete do (vlevo) <code>Settings &gt; General</code>, v části <code>Visibility, project features, permissions</code> klikněte na <code>Expand</code> a povolte <code>Merge requests</code>.</p>
</blockquote>
<details>
    <summary>Tip!</summary>
<p>Velmi užitečným nástrojem jsou i takzvané <code>Issues</code>, které povolíte v týchž nastaveních jako <code>Merge requesty</code>.
Pomocí nich můžou developeři zaznamenávat chyby, které je třeba opravit nebo diskutovat nové &quot;featury&quot;.
<code>Issues</code> v tomto cviku používat nebudete ale můžete se s nima pohrát samostatně a také je můžete pak využívat při práci na projektu.</p>
</details>
<p>✅ Nyní si všichni skuste pohrát s <code>MR (&quot;Merge Requestem&quot;)</code> v gitlabu.
Přidávejte komentáře a zkuste v nich také vkládat odkazy na <code>&quot;commity&quot;</code> a části kódu.</p>
<p>✅ Jeden člen týmu nakonec <code>Merge Request</code> potvrdí.</p>
<p>✅ Všichni si <code>&quot;pullnou&quot;</code> aktuální stav repozitáře.</p>
<details>
    <summary>Tip!</summary>
<p>Zkuste se pomocí příkazu <code>git log</code> podívat na aktuálni historii <code>&quot;commitů&quot;</code>.
Pokud je <code>log</code> příliž dlouhej, vrátite se zpět stisknutím klávesy <code>q</code>.</p>
</details>
<h3><a class="header" href="#integrace-gitu-v-clion-ide" id="integrace-gitu-v-clion-ide">Integrace GITu v Clion IDE</a></h3>
<p>Všechny operace, které ste právě dělali se dají mnohem snadněji a efektivněji udělat i v Clionu.
Dálší část budete delat už přímo v Clionu.</p>
<p>✅ Všichni si v Clionu otevřou složku se svým repozitářem.</p>
<details>
    <summary>Tip!</summary>
<p>Když si vlevo dolu rozklikněte modul <code>Git</code> uvidíte přehledne celou vaší historii <code>&quot;commitů&quot;</code> a také všechny <code>&quot;branche&quot;</code>, které git právě sleduje.
<code>&quot;Checkoutovat&quot;</code> můžete (pravé tlačítko myši) nejen do branchů ale také do jekéhokoliv <code>&quot;commitu&quot;</code>.</p>
</details>
<p>✅ Všichni si <code>&quot;pullnou&quot;</code> aktuální stav repozitáře pomocí modré sípky napravo nahoře (<code>Update project...</code>) a <code>&quot;checkoutnou&quot;</code> do lokálního <code>&quot;branchu&quot; main</code>.</p>
<p>✅ Jeden člen týmu vytvoří nový soubor s názvem <code>README.md</code> (pokud takový soubor ješte neexistuje), jeden soubor s názvem <code>.gitignore</code> (včetně tečky) a jeden textový soubor s názvem <code>random_file.txt</code>.</p>
<p>✅ Do souboru <code>README.md</code> společně doplňte stručný popis repozitáře pomocí <code>markdown</code> syntaxe.</p>
<details>
    <summary>Jak vypadá markdown?</summary>
<pre><code># Main title
This repository contains source files for the BPC-PRP cource ...

# Table of contents
* [Main title](#main-title)
* [Subtitle](#this-is-a-subtitle)
* [SubSubtitle](#this-is-a-sub-subtitle)
* [Itemizing](#itemizing)
* [Enumerating](#enumeration)
* [Tables](#tables)

## This is a subtitle
Our solution for winning the competition was ...

### This is a sub-subtitle
**BALD TEXT**: Our C++ class `short name in code format` uses the ... algorithm to solve the ...

    Long text displayed in code format.
    It contains excerptions of our code
    or other stuff.

[This](https://google.com) is a web page link.

### Itemizing
* Line 1.
* Line 2.

### Enumeration
1. Step one.
2. Step two.

### Tables
| Col 1  | Col 2  | Col 3  | Col 4  |
|--------|--------|--------|--------|
| Row 11 | Row 12 | Row 13 | Row 12 |
| Row 21 | Row 22 | Row 23 | Row 12 |
</code></pre>
</details>
<p>✅ Člen týmu, který soubor právě edituje klikne na modul <code>Commit</code> (vlevo), kde uvidí všechny aktuálne rozpracované soubory.
Po rozkliknutí souboru také přehledně uvidí všechny změny, které v tom souboru udělal.</p>
<p>✅ V části <code>Untracked files</code> uvidíte všechny nové soubory, které ste právě vytvořili.</p>
<p>✅ Člen týmu, který vytvářel soubory si otevře <code>.gitignore</code> a do něj přímo napíše název posledně vytvořeného textového souboru (tedy <code>random_file.txt</code>).
Pak se pak vráti do modulu <code>Commit</code> (vlevo).</p>
<details>
    <summary>Tip!</summary>
<p>Sledujte co se stalo v části <code>Untracked files</code>. Pokud tam zůstali ješte nejaké jiné neznáme soubory, můžete je stejně přidat do <code>.gitignore</code>.
Typicky to bývají soubory z <code>cmake</code> nebo od Clionu. Když do <code>.gitignore</code> vložíte <code>cmake*</code> bude git ignorovat všechno, co začína textem cmake (včetně složek).</p>
</details>
<details>
    <summary>Pro Tip!</summary>
<p>Podobné chování dosáhnete i přes soubor <code>.git/info/exclude</code>.
Rozdíl je v tom, že ten je přístupnej vždy jen lokálne pro Vás a to co do něj vložíte nikto jiný neuvidí a tedy ani u nikoho jiného fungovat nebude.</p>
</details>
<p>✅ Do okna dolu vloží info o <code>&quot;commitu&quot;</code> (takzvaný <code>commit message</code>), <code>&quot;pushne&quot;</code> stlačením <code>Commit and Push...</code> a potvrdí.</p>
<p>✅ Dva členové se opět pokusí vytvořit konflikt editovaním stejného řádku v jednom souboru.</p>
<p>✅ Nešťastný člen týmu opět dostane varováni o konfliktu a stačením <code>Rebase</code> se ho pokusí řešit.</p>
<p>✅ Řešitel konfliktu pak vybere možnost <code>Merge</code> a sloučí změny tak aby soubor obsahoval změny od obou členů.
Stlačením <code>Push...</code> (zelená šipka vpravo nahoře) odešle finálni verzi do <code>&quot;originu&quot;</code>.</p>
<p>Nový <code>branch</code> v Clionu vytvoříte v modulu <code>Git</code> stlačením ikonky <code>plus</code> vlevo.
Můžete také udělat nový <code>branch</code>, který přímo navazuje na jiný než ten aktuálni a to kliknutím pravým tlačítkem miší a výběrem <code>New branch from selected...</code>.</p>
<h3><a class="header" href="#podepisování-commitů-pomocí-gpg-klíčů-optional" id="podepisování-commitů-pomocí-gpg-klíčů-optional">Podepisování commitů pomocí GPG klíčů (optional)</a></h3>
<p>Pokud chcete svoje <code>&quot;commity&quot;</code> podepisovat jako &quot;ověřený&quot; užívatel, je nutné mít verifikovaný email ve Vašem gitlab účtu.</p>
<ol>
<li>Klíče vygenerujete pomocí příkazu <code>gpg --full-gen-key</code>, případne <code>gpg --gen-key</code>.</li>
</ol>
<details>
    <summary>Tip!</summary>
<p>Balíček <code>gpg</code> nainstalujete standardně příkazem <code>sudo apt install gpg</code></p>
</details>
<ol start="2">
<li>
<p>Následně jen stiskňete klávesu <code>Enter</code> (vybírame &quot;default&quot; možnost <code>RSA and RSA</code>).</p>
</li>
<li>
<p>Po vyzváni pak zadejte velikost klíče 4096.</p>
</li>
<li>
<p>V dalším kroku můžete opět jen stisknout <code>Enter</code> (vaším klíčem nikdy neskončí platnost) a pak potvrdíte zadaním <code>y</code>.</p>
</li>
<li>
<p>Teď budete postupně zadávat údaje o účtu, se kterým budou klíče asociovány:</p>
<p>5.1 Jméno doporučuji zvolit stejné jako máte nastavené v účtu na gitlabu.</p>
<p>5.2 Email musí být stejný jako máte ve svém účtu na gitlabu a musí být verifikován. Email musí být také stejný jako ste si nastavili v konfiguraci gitu (email <code>&quot;commitujicího&quot;</code>). Jinak Vám gitlab bude zobrazovat <code>&quot;commity&quot;</code> jako neověřené.</p>
<p>5.3 Jako poznámku můžete zadat třeba &quot;Gitlab VUT&quot; abyste pak klíč rozeznali.</p>
</li>
<li>
<p>Vyberte si heslo (tento krok nezle přeskočit).</p>
</li>
<li>
<p>Když se Vaše klíče vygenerují, pomocí příkazu <code>gpg --list-secret-keys --keyid-format LONG &lt;your-email&gt;</code> si zobrazíte váš privátni klíč.</p>
</li>
<li>
<p>Skopírujte sekvencií znaků (ID Vašeho klíče), která následuje hned po <code>sec rsa4096/</code> v prvním řádku.</p>
</li>
<li>
<p>Pomocí příkazu <code>gpg --armor --export &lt;skopirovane-ID-klice&gt;</code> vygenerujete veřejnou část vašeho páru klíčů.</p>
</li>
<li>
<p>Skopírujte všechno od <code>-----BEGIN PGP PUBLIC KEY BLOCK-----</code> až po <code>-----END PGP PUBLIC KEY BLOCK-----</code>, včetně obou.</p>
</li>
<li>
<p>V gitlabu přejdete do <code>Preferences &gt; GPG Keys</code>,  vložte skopírovaný obsah a potvrďte stlačením <code>Add key</code>.</p>
</li>
<li>
<p>V Clionu (kde máte otevřený svůj repozitář) přejdete do <code>Settings &gt; Git &gt; Configure GPG key</code> a vyberte se seznamu Váš klíč.</p>
</li>
</ol>
<details>
    <summary>Tip!</summary>
<p>Podívejte co se změnilo v souboru <code>.git/config</code>. To samé by se dalo opět dosáhnout editováním tohto souboru, avšak v Clionu je to mnohem jedndušší.</p>
</details>
<ol start="13">
<li>
<p>Jeden člen týmu zkusí cvične udělat nejaký <code>commit</code> (měl by dostat výzvu na zadáni hesla) a <code>&quot;pushnout&quot;</code>.</p>
</li>
<li>
<p>Pokud všechno probehlo správně měli by ste v gitlabu v historii <code>&quot;commitů&quot;</code> vidět svůj commit označený jako <code>verified</code>.</p>
</li>
</ol>
<details>
    <summary>Tip!</summary>
<p>Pro <code>&quot;commitování&quot;</code> s podpisem přes <code>Bash</code> se používa <code>git commit -S -m &quot;my signed commit&quot;</code></p>
</details>
<p><sup>*</sup>Detailnejší návody najdete také na stránkach <a href="https://git.robotika.ceitec.vutbr.cz:2223/help/user/project/repository/gpg_signed_commits/index.md">GitLabu</a> nebo <a href="https://docs.github.com/en/authentication/managing-commit-signature-verification">GitHubu</a>. <br /></p>
<h2><a class="header" href="#simulátor-cca-30-min" id="simulátor-cca-30-min">Simulátor (cca 30 min)</a></h2>
<p>Ze <a href="https://github.com/Robotics-BUT/BPC-PRP">stránek kurzu</a> si <code>&quot;naclonujte&quot;</code> aktuální stav repozitáře.</p>
<p>Ve složce <code>resources/</code> naleznete soubor <code>config.yaml</code>. Z něj si bude simulátor načítat hodnoty pro Vaší simulaci, mezi jinými nastavení síťové komunikace, simulované rozměry robota, parametry podvozku, rozmístění snímačů, a hlavně cestu k mapě, se kterou bude simulátor pracovat. Tu si upravte pro svůj vlastní souborový systém.</p>
<p>Dále se ve složce <code>resources/</code> nachází také jedna vzorová mapa. Nahlédněté do ní a všiměnte si struktury YAML dat. Nachází se zde informace o šířce čáry a následně je zde pole úseček definovaných vždy <code>[bod1_x, bod1_y, bod2_x, bod2_y]</code>. V budoucnu si budete vytvářet taky vlastní mapy.</p>
<details>
    <summary>Tip!</summary>
<p>Zkuste se zamyslet nad tím jak si zjednodušit tvorbu map. Můžete např. využít nějaký grafický nástroj, soubor si vyexportovat do nějakého vhodného formátu a pak prekonvertovat do <code>.yaml</code>. Řešení je na Vás.</p>
</details>
<p>✅ Nastavte si v souboru <code>config.yaml</code> validní cestu k mapě <code>route_1.yaml</code>.</p>
<p>✅ Po změně obsahu souboru si vyzkoušejte validitu <code>.yaml</code> souboru v <a href="http://www.yamllint.com/">online nástroji</a>.</p>
<p>Nyní zbývá si vyzkoušet oživit celý systém.
Repozitář obsahuje ve složce <code>bin/</code> skompilovanou binárku simulátoru nazvanou &quot;simulator&quot;. Pokud máte korektně nainstalovaný ROS, otevřete si 3 terminály.
Pokud ne, nainstalujte si ho podle návodu na <a href="https://robotics-but.github.io/BPC-PRP/chap_1_software/text/ros.html">stránkach kurzu</a> nebo přímo <a href="http://wiki.ros.org/noetic/Installation/Ubuntu">stránkach rosu</a>.</p>
<blockquote>
<p><strong>POZNÁMKA:</strong> Pokud nemáte ve svém <code>/home/&lt;user-name&gt;/.bashrc</code> souboru přidán příkaz <code>source /opt/ros/noetic/setup.bash</code> budete muset v každém novém okně vždy tento příkaz zavolat, jinak Váš počítač nepozná, že máte nainstalovaný ROS.</p>
</blockquote>
<details>
    <summary>Tip pro práci s více terminály</summary>
<p>Pro práci s více okny terminálů je dobré si nainstalovat pomocí balíčkovacího manažeru program &quot;terminator&quot; nebo &quot;tilix&quot;. Ten Vám umožní v jednom okně mít otevřených více terminálu.</p>
</details>
<details>
    <summary>Vím jak se pracuje s balíčkovacím manažerem, jen potřebuji osvěžit paměť.</summary>
<p><code>sudo apt install &lt;package-name&gt;</code></p>
</details>
<p>✅ V 1. terminále zapněte <code>roscore</code></p>
<p>✅ V 2. terminále spusťte binárku simulátoru, jako argument programu přidejte absolutní cestu ke konfiguračnímu souboru, který jste dříve editovali.</p>
<details>
    <summary>Vím jak se spouštějí binárky, jen potřebuji osvěžit paměť.</summary>
<p><code>./&lt;path-to-binary-file&gt;</code></p>
</details>
<p>✅ V 3. terminále zapněte <code>rviz</code> a přidejte si vizualizaci topicků </p>
<h3><a class="header" href="#konfigurace-rvizu" id="konfigurace-rvizu">Konfigurace RVizu</a></h3>
<p><img src="cviceni/../images/rviz_1.jpg" alt="empty RViz" /></p>
<p>Pokud běží simulátor, v levé dolní sekci tlačítkem <code>Add</code> otevřete okno pro přidání vizualizací.</p>
<p><img src="cviceni/../images/rviz_2.jpg" alt="RViz add topic by display type" /></p>
<p>V záložce <code>By Display Type</code> vyberte položku <code>TF</code> a dvojitým polikem jí přidejte do zobrazení. Dále v levé horní části v záložce <code>Global Options</code> nastavte položku <code>Fixed Frame</code> na hodnotu <code>origin</code>. Tímto jsme RVizu řekli, že má zobrazovat souřadný systém <code>origin</code> a vůči němu vykreslovat všechny ostatní souřadné systémy, se kterými simulátor pracuje.</p>
<p>Opětovně otevřete okno pro přidání vizualizací a přejděte do záložky <code>By Topic</code>. </p>
<p><img src="cviceni/../images/rviz_3.jpg" alt="RViz add topic by topic" /></p>
<p>Postupně si přidejte všenchy vizualizace markerů pod topicky (v obdélniku <code>Display Name</code> můžete vizualizaci topicu pojmenovat):</p>
<ul>
<li>/bpc_prp/line</li>
<li>/bpc_prp/robot_body</li>
<li>/bpc_prp/sensors</li>
<li>/bpc_prp/wheels/left</li>
<li>/bpc_prp/wheels/right</li>
</ul>
<p>Ihned po přidání nové vizualizace si jí můžete také přejmenovat použitím tlačítka <code>Rename</code> na penelu vlevo dole.</p>
<p>✅ Výsledek by měl vypadat následovně:</p>
<p><img src="cviceni/../images/prp_1.jpg" alt="RViz Ready" /></p>
<p>Současné nastavení RVizu uložíte klávesovou zkratkou CTRL+S</p>
<p>✅ Prozkoumejte další možnosti nastavení vizualizací v RVizu, jako velikost mříždy, průhlednost, barva pozadí, atd.</p>
<h1><a class="header" href="#udp-komunikace" id="udp-komunikace">UDP komunikace</a></h1>
<p>Cvičící: Ing. Tomáš Lázna</p>
<h2><a class="header" href="#založení-projektu-cca-10-minut" id="založení-projektu-cca-10-minut">Založení projektu (cca 10 minut)</a></h2>
<p>Zapněte CLion a vytvořte nový projekt (File &gt; New Project) typu <em>C++ Executable</em>. Zvolte umístění a název svého projektu (např. jméno týmu) a <em>Language standard</em> nastavte na <em>C++17</em>.</p>
<p>CLion by vám měl generovat prázdnou šablonu C++ aplikace. V prvé řadě budeme editovat soubor <em>CMakeLists.txt</em>, abychom kompilátoru řekli, kde má hledat hlavičkové a zdrojové soubory. 
Doporučuji si v adresářové struktuře projektu vytvořit složku <em>include</em> pro umístění .h souborů a složku <em>src</em> pro .cpp soubory (včetně <code>main.cpp</code>, který je defaultně v rootu projektu). 
Zároveň si k projektu přilinkujeme knihovny pro práci s YAML soubory pro načítání konfiguračních souborů (volitelné) a pro práci s vlákny (rovněž volitelné). Soubor by měl mít následující strukturu:</p>
<pre><code>cmake_minimum_required(VERSION 3.17)
project(bpc_prp_cool_name)

set(CMAKE_CXX_STANDARD 17)

find_package(Yaml-cpp)
find_package(Threads REQUIRED)

include_directories(include)

set(SOURCES
        src/main.cpp
        src/cool_code.cpp
        src/another_source_file.cpp)

add_executable(bpc_prp_cool_name ${SOURCES})
target_link_libraries(bpc_prp_cool_name yaml-cpp Threads::Threads) 
</code></pre>
<p>Pokud CMake nereloaduje konfiguraci automaticky, v CLionu vám vyskočí panel <em>CMake project needs to be reloaded</em>, kliknete na tlačítko <em>Reload changes</em>.</p>
<h2><a class="header" href="#zpracování-nmea-zpráv-cca-1-hodina" id="zpracování-nmea-zpráv-cca-1-hodina">Zpracování NMEA zpráv (cca 1 hodina)</a></h2>
<p>Komunikace se simulátorem probíhá formou NMEA zpráv posílaných přes UDP protokol. Pro sestavení, kontrolu a parsování NMEA zpráv je výhodné si vytvořit sadu utilitárních metod a zabalit je do třídy. Přikládám návrh deklarace
4 metod, kterým se můžete (ale nemusíte) inspirovat, pozornost věnujte zejména vstupním a návratovým typům:</p>
<pre><code>std::string string_to_nmea_message(const std::string&amp; message);
uint16_t get_message_checksum(const std::string&amp; message);
std::string extract_nmea_message_content(const std::string&amp; nmea_message);
bool is_nmea_message_valid(const std::string&amp; nmea_message);
</code></pre>
<p>Obecně je v C++ dobrým nápadem předávat metodám objekty, které nechcete modifikovat, jako konstantní reference (const type&amp;), tím pádem se funkci předá jen odkaz na daný objekt (nemusí se kopírovat) 
a přitom se (díky const) chráníte před tím, abyste omylem objekt modifikovali.</p>
<p>Metody můžete definovat jako statické, tj. pro jejich volání nebude nutné vytvářet instanci třídy.</p>
<p>Pozn. Struktura NMEA zprávy je následující:</p>
<pre><code>$MESSAGE_TYPE,PARAMETERS,SEPARATED,BY,COMMAS*checksum
</code></pre>
<p>Checksum je dvoučíslicové hexadecimální číslo (tj. v rozsahu 0-255), které vznikte jako bitová nonekvivalence (XOR) ASCII kódů všech znaků mezi $ a * (ty nejsou zahrnuty).</p>
<p>Následuje příklad volání jednotlivých metod s očekávanými výstupy tak, abyste si mohli ověřit správnost své implementace.</p>
<pre><code>string_to_nmea_message(&quot;PING,HELLO&quot;) -&gt; &quot;$PING,HELLO*7E&quot;
get_message_checksum(&quot;RESET,&quot;) -&gt; 121 (= 79 v hexa)
extract_nmea_message_content(&quot;$PONG,HELLO*78&quot;) -&gt; &quot;PONG,HELLO&quot;
is_nmea_message_valid(&quot;$PONG,HELLO*78&quot;) -&gt; true
is_nmea_message_valid(&quot;$PONG,HELLO*AA&quot;) -&gt; false
</code></pre>
<p>Pozn. Pro sestavování a parsování C++ řetězců (<code>std::string</code>) doporučuji využít třídu <code>std::stringstream</code> ze standardní knihovny <code>&lt;stringstream&gt;</code>.</p>
<p>Úspěšná implementace metod pro práci s NMEA zprávami je nutnou podmínkou pro úspěšnou komunikaci se simulátorem v dalším kroku.</p>
<h2><a class="header" href="#udp-komunikace-přes-socket-api-cca-40-minut" id="udp-komunikace-přes-socket-api-cca-40-minut">UDP komunikace přes socket API (cca 40 minut)</a></h2>
<p>Komunikace se simulátorem je realizována ve formě UDP paketů, které budeme odesílat a přijímat pomocí socket API, které je k dispozici ve standardních C knihovnách.</p>
<p>Pro úspěšné fungování je nutné includovat několik hlavičkových souborů:</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
</code></pre>
<p>Pro inicializaci socketu zavoláme funkci <code>socket</code>, která má následující předpis:</p>
<pre><code>int fd = socket(int domain, int type, int protocol);
</code></pre>
<p>Ve filosofii jazyka C se se sockety pracuje jako se soubory (lze do nich zapisovat a číst z nich), proto funkce vrací celé číslo <em>file descriptor</em>, pomocí kterého se daný socket referencuje dále v kódu.</p>
<p>Nápovědu k tomu, s jakými parametry socket inicializovat naleznete v dokumentaci funkce <code>socket</code> - budeme pracovat v doméně IPv4 a typem bude UDP (připomeňte si, co tato zkratka znamená). 
V běžných případech (jako i tento) je protokol již definován prostřednictvím typu, třetí parametr tedy může být nastaven na 0.</p>
<p>Korektní je po skončení práce se socketem jej uzavřít pomocí volání:</p>
<pre><code>close(fd)
</code></pre>
<h3><a class="header" href="#odesílání-zpráv" id="odesílání-zpráv">Odesílání zpráv</a></h3>
<p>Existují v zásadě dvě varianty, jak odesílat UDP zprávy. </p>
<ol>
<li>Datagramy je možné posílat i přes tzv. nepojmenované sockety (nemají přiřazenou žádnou adresu a port), přičemž adresát je specifikován ve volání funkce <code>sendto</code>. 
Pro pojmenování příjemce využijeme strukturu <code>sockaddr_in</code>, a to následujícím způsobem:</li>
</ol>
<pre><code>struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_addr.s_addr = inet_addr(&quot;ip.adresa.pri.jemce&quot;);
addr.sin_port = htons(11111);
</code></pre>
<p>Odeslání zprávy je realizováno následujícím voláním:</p>
<pre><code>std::string msg = &quot;message&quot;;
ssize_t no_of_sent_bytes = sendto(fd, msg.c_str(), msg.length(), 0, (struct sockaddr *) &amp;addr, sizeof(addr));
</code></pre>
<p>Funkci jsou předány tyto parametry: deskriptor socketu, obsah zprávy (typ char* = řetězec v C), délka zprávy, příznaky (flags), struktura s popisem adresáta, velikost této struktury. Vrácen je počet odeslaných bytů.</p>
<ol start="2">
<li>Pokud komunikuji opakovaně se stejným příjemcem, je možné socket tzv. pojmenovat a odesílání realizovat funkcí <code>send</code>, která nevyžaduje strukturu s adresátem (tato informace bude již předána přes deskriptor socketu).
Způsob pojmenování závisí na tom, zda je vaše aplikace klientem (aktivně se připojuje k jinému socketu) nebo serverem (naopak čeká, než se jiný socket připojí k vašemu). Pro variantu klienta použijeme funkci <code>connect</code>:</li>
</ol>
<pre><code>int res = connect(fd, (struct sockaddr *) &amp;addr, sizeof(addr));
</code></pre>
<p>Funkci jsou předány tyto parametry: deskriptor socketu, struktura s popisem serveru, velikost této struktury. V případě úspěchu je vrácena 0, při chybě -1.</p>
<p>Varianta serveru bude popsána později v sekci Přijímání zpráv, využívá se funkce <code>bind</code>.</p>
<p>K odeslání zprávy slouží následující volání:</p>
<pre><code>std::string msg = &quot;message&quot;;
ssize_t no_of_sent_bytes = send(fd, msg.c_str(), msg.length(), 0);
</code></pre>
<p>Parametry a návratová hodnota jsou analogické s funkcí <code>sendto</code>.</p>
<p>Při využití pojmenovaného socketu může nastat situace, kdy se spojení přeruší, v takovém případě je nutné jej obnovit opětovným voláním funkce <code>connect</code>. </p>
<h3><a class="header" href="#přijímání-zpráv" id="přijímání-zpráv">Přijímání zpráv</a></h3>
<p>Socket je před přijímáním zpráv nutné pojmenovat, a to pomocí funkce <code>bind</code>, kterou socketu sdělíme, přes jaké rozhraní má komunikovat: </p>
<pre><code>int res = bind(fd, (struct sockaddr *) &amp;addr, sizeof(addr));
</code></pre>
<p>Můžete si povšimnout, že volání je stejné jako v případě funkce <code>connect</code>. V případě úspěchu je vrácena 0, při chybě -1.</p>
<p>Pro pojmenování rozhraní využijeme opět strukturu <code>sockaddr_in</code>, a to následujícím způsobem:</p>
<pre><code>struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_addr.s_addr = htonl(INADDR_ANY);
addr.sin_port = htons(22222);
</code></pre>
<p>Všimněte si rozdílu na 3. řádku, kdy tentokrát nespecifikujeme konkrétní adresu, ale pomocí <code>INADDR_ANY</code> říkáme, že chceme přijímat zprávy přes libovolné místní síťové rozhraní.</p>
<p>Příjem zprávy je poté realizován následujícím voláním:</p>
<pre><code>unsigned char buffer[100];
socklen_t senderlen = sizeof(addr);

ssize_t no_of_received_bytes = recvfrom(fd, buffer, sizeof(buffer), 0, (struct sockaddr *) &amp;addr, &amp;senderlen);
std::string received_message(buffer, buffer + no_of_received_bytes);
</code></pre>
<p>Funkci jsou předány tyto parametry: deskriptor socketu, buffer pro příjem, délka bufferu, příznaky (flags), struktura s popisem rozhraní, <em>ukazatel</em> na velikost této struktury. Vrácen je počet přijatých bytů. 
Volání je obdobné jako v případě <code>sendto</code>, všimněte si ale, že tentokrát předáváme referenci na délku struktury, ne přímo délku; to proto, že funkce <code>recvfrom</code> do struktury zapisuje údaje o odesilateli zprávy 
a může její délku změnit.</p>
<p>Je-li socket správně nabindován/připojen a neřešíme konflikt s více odesilateli, které bychom potřebovali rozlišit pomocí struktury <code>sockaddr_in</code>, můžeme přijímat zjednodušeným způsobem pomocí funkce <code>recv</code>. 
K příjmu zprávy poté slouží následující volání:</p>
<pre><code>ssize_t no_of_received_bytes = recv(fd, buffer, sizeof(buffer), 0);
</code></pre>
<p>Parametry a návratová hodnota jsou analogické s funkcí <code>recvfrom</code>.</p>
<h2><a class="header" href="#testování-komunikace-se-simulátorem-cca-10-minut" id="testování-komunikace-se-simulátorem-cca-10-minut">Testování komunikace se simulátorem (cca 10 minut)</a></h2>
<p>Jak již bylo řečeno, se simulátorem komunikujeme UDP protokolem pomocí NMEA zpráv. V případě, že simulátor máte spuštěný na stejném stroji jako svůj program (což vřele doporučuji), budete zprávy odesílat na adresu <em>localhostu</em> 
(127.0.0.1). Simulátor komunikuje na portech specifikovaných v souboru <code>config.yaml</code>, vypíše je do konzole po spuštění. Všimněte se, že příjem a odesílání dat probíhá na jiných portech, budete tedy potřebovat dva sockety.</p>
<p>Základní fungování komunikace můžete ověřit pomocí zprávy <code>PING,&lt;dalsi-parametry&gt;</code>. Po přijetí vám simulátor vrátí zprávu <code>PONG,&lt;dalsi-parametry&gt;</code>.</p>
<p>Pozn. Simulátor očekává, že všechny příchozí zprávy mají minimálně dva segmenty (tj. minimálně jednu čárku), proto nestačí poslat pouze <code>PING</code>.</p>
<p>✅ Na konci cvičení musíte být schopní odeslat do simulátoru zprávu Ping a vypsat do konzole odpověď extrahovanou z NMEA zprávy (tj. bez znaků $, * a checksumu).</p>
<p>Doporučujeme, abyste dbali na kulturu kódu a používali třídy. Komunikace bude fungovat i pokud veškerý potřebný kód zahrnete do souboru <code>main.cpp</code>, ale s tímto přístupem by v brzké budoucnosti funkce <code>main</code> rychle nabobtnala
a stala se těžko přehlednou. Pokud se budete řídit příklady dobré praxe od počátku projektu, bude vás to na začátku stát více času, ale v pozdějších fázích jej naopak budete šetřit.</p>
<h2><a class="header" href="#bonus-vyčtení-dat-ze-senzorů" id="bonus-vyčtení-dat-ze-senzorů">Bonus: vyčtení dat ze senzorů</a></h2>
<p>Vyzkoušejte další zprávy pro komunikaci se simulátorem, které vrací hodnoty ze senzorů:</p>
<p>✅ Zpráva <code>SENSOR,&lt;id&gt;</code> posílá požadavec na měření senzoru číslo <code>&lt;id&gt;</code> (indexováno od nuly).</p>
<p>✅ Zprávy <code>LODO</code> a <code>RODO</code> posílají požadavek na zjištění ujeté vzdálenost levého, resp. pravého motoru.</p>
<p>✅ Ve zbývajícím čase můžete začít pracovat na funkci, která rozdělí příchozí zprávu na segmenty (oddělené čárkou) a převede texty na čísla (v závislosti na typu zprávy).</p>
<h1><a class="header" href="#přístup-k-hardware---i2c-gpio-adc" id="přístup-k-hardware---i2c-gpio-adc">Přístup k hardware - I2C, GPIO, ADC</a></h1>
<p>Cvičící: Ing. František Burian Ph.D.</p>
<h2><a class="header" href="#cile" id="cile">Cile</a></h2>
<ul>
<li>Pochopit princip sběrnice I2C která propojuje součásti robotu</li>
<li>Pochopit činnost GPIO expanderu</li>
<li>Pochopit činnost A/D převodníku</li>
</ul>
<h2><a class="header" href="#prerekvizity" id="prerekvizity">Prerekvizity</a></h2>
<ul>
<li>Předinstalované Raspberry PI s HATem v laboratoři</li>
</ul>
<h2><a class="header" href="#i2c-30-minut" id="i2c-30-minut">I2C (30 minut)</a></h2>
<h3><a class="header" href="#aktivace-i2c-hardwarového-softwarového-device-tree-overlay" id="aktivace-i2c-hardwarového-softwarového-device-tree-overlay">Aktivace I2C hardwarového, softwarového, device tree overlay</a></h3>
<p>Konfigurace device tree overlayů se dělá v <code>/boot/config.txt</code>. Po každé změně tohoto souboru je potřeba rasoberry 
rebootovat příkazem <code>sudo reboot</code></p>
<p>Pro aktivaci hardwarového i2c na pinech 2 a 3 platí následující výstřižek v <code>/boot/config.txt</code>:</p>
<pre><code>  dtparam=i2c_arm=on
  dtparam=i2c_baudrate=10000
</code></pre>
<p>Pro zjištění aktuálního baudrate můžete použít <code>sudo cat /sys/kernel/debug/clk/clk_summary</code></p>
<p><a href="https://elinux.org/BCM2835_datasheet_errata">ERRATA</a> Je třeba si všimnout že <strong>errata nevydal výrobce čipu</strong>, ten se k
němu nezná, je to levný výrobce!</p>
<p><strong>BUG1:</strong></p>
<p>Výrobce čipu implementoval chybně clock stretching, a pomalá periferie kompletně zruší přenos po sběrnici (vymaže jeden nebo více CLK pulsů). Sběrnice tedy musí běžet rychlostí podle nejpomalejší periferie.</p>
<p><strong>BUG2:</strong></p>
<p>Výrobce čipu neimplementoval správně nastavení rychlosti a od RpiV4 prakticky nejde zpomalit rychlost HW I2C sběrnice pod určitou mez (cca 100kbps - každé rpi to má jinak), ikdyž je v příkazu viz výše reportovaná hodnota jak byla nastavená. </p>
<p>Díky těmto chybám prakticky nelze použít konfiguraci viz výše a musíme použít softwarově definované I2C, které těmito problémy netrpí. Použijte konfiguraci v <code>/boot/config.txt</code> (předchozí řádky musí být zakomentované aby se dvě implementace nebily):</p>
<pre><code>  dtoverlay=i2c-gpio,i2c_gpio_sda=2,i2c_gpio_scl=3,i2c_gpio_delay_us=6,bus=3
</code></pre>
<p>Tato konfigurace vytvoří na pinech 2 a 3 sběrnici /dev/i2c-3 s periodou CLK pulsu 12us tj cca 90kHz, ale s výjimkou že bude 
funkční clock stretching, takže si pomalá periferie může sběrnici pozdržet (případ KM2, bude probírán na dalším cvičení)</p>
<p>Poznámka: Takto je v laboratoři Rpi připraveno, konfiguraci tedy nemusíte měnit, pouze ji zkontrolujte.</p>
<h3><a class="header" href="#shell-detekce-všech-připojených-zařízení-na-i2c-sběrnici" id="shell-detekce-všech-připojených-zařízení-na-i2c-sběrnici">Shell: Detekce všech připojených zařízení na I2C sběrnici</a></h3>
<p>Pro rychlé zjištění stavu I2C existuje spousta dobrých nástrojů z balíku <code>i2c-tools</code>. Omezíme se pouze na autodetekci 
připojených čipů:</p>
<pre><code class="language-bash">  i2cdetect -y 3
</code></pre>
<p>Vysvětlete z výpisu, a s použitím datasheetů, které čipy máte na sběrnici připojené (různé RPI budou mít různé výstupy!)</p>
<h3><a class="header" href="#stažení-vzorového-projektu" id="stažení-vzorového-projektu">Stažení vzorového projektu</a></h3>
<p>Vzorový projekt obsahuje následující kód: </p>
<pre><code class="language-cpp">#include &lt;roboutils/io/I2C.h&gt;
#include &lt;roboutils/util/timing.h&gt;

using namespace RoboUtils;
using namespace RoboUtils::IO;

int main()
{
  I2C i2c;
  i2c.open(&quot;/dev/i2c-3&quot;);

  uint8_t value = 0;

  while (true) {
    i2c.write(0x20, 0x06, ++value);
    delay(100);
  }
}
</code></pre>
<p>spusťte jej, popište jeho funkci, prohlédněte si header, způsob jeho dokumentace a jaké možnosti Vám nabízí.</p>
<h3><a class="header" href="#odchycení-zpráv-na-i2c-osciloskopem-identifikace-clock-stretchingu" id="odchycení-zpráv-na-i2c-osciloskopem-identifikace-clock-stretchingu">Odchycení zpráv na I2C osciloskopem, identifikace clock stretchingu</a></h3>
<p>Připojte na osciloskop sběrnici I2C, osciloskop sesynchronizujte tak,
abyste viděli stabilní průběh jedné úplné zprávy a ten popište.</p>
<p>Hledejte START, STOP, hodnoty jednotlivých bitů dat i adresy, ACK.</p>
<h2><a class="header" href="#gpio-60-minut" id="gpio-60-minut">GPIO (60 minut)</a></h2>
<h3><a class="header" href="#vzorový-projekt" id="vzorový-projekt">Vzorový projekt</a></h3>
<p>Založte na aktuáním &quot;master&quot; novou větev pojmenovanou &quot;hw-cv5-gpio&quot;, přepněte se do ní a upravte kód vzorového projektu tak, 
aby obsahoval následující kód:</p>
<pre><code class="language-cpp">#include &lt;roboutils/io/GPIO.h&gt;
#include &lt;roboutils/util/timing.h&gt;

using namespace RoboUtils;
using namespace RoboUtils::IO;

const auto LED1 = Pin::PB4;

int main()
{
  I2C i2c;
  GPIO gpio{i2c};
  
  i2c.open(&quot;/dev/i2c-3&quot;);

  gpio.output(LED1);

  while (true) {
      gpio.high(LED1);
      delay(50);
      gpio.low(LED1);
      delay(50);
  }
}
</code></pre>
<p>Popište jeho funkci, a ověřte ji spuštěním. Opět si prohlédněte dokumentaci a nabízené funkce.</p>
<p>COMMIT / PUSH</p>
<h3><a class="header" href="#reakce-na-tlačítko-ovládání-běhu-programu-pomocí-tlačítek" id="reakce-na-tlačítko-ovládání-běhu-programu-pomocí-tlačítek">Reakce na tlačítko, ovládání běhu programu pomocí tlačítek</a></h3>
<p>Zadefinujte tlačítka jako proměnné LBUT a RBUT, nastavte je jako
vstupní s pullupem.</p>
<p>Po stisknutí tlačítka RBUT ukončete program</p>
<p>Přenastavte výstupní port pro PB5 do režimu &quot;otevřený kolektor&quot;,
duplikujte stav LED1 a diskutujte viditelné rozdíly na pinech
PB4 a PB5 s použitím osciloskopu.</p>
<p>COMMIT / PUSH</p>
<h3><a class="header" href="#ošetření-zákmitů-tlačítka" id="ošetření-zákmitů-tlačítka">Ošetření zákmitů tlačítka</a></h3>
<p>Vytvořte si proměnnou value, a inicializujte ji na nulu.</p>
<p>Vytvořte z portu PB0 - PB5 &quot;bargraf&quot; zobrazující hodnotu value v
každém cyklu supersmyčky okamžitě, tedy bez zpoždění (odstraňte
všechny delaye).</p>
<p>Upravte program tak, aby tlačítkem při každém <strong>stisknutí</strong> zvýšil
hodnotu value o 1. Volitelně můžete použít i tisk na obrazovku.
Pozor na zákmity tlačítka !!</p>
<p>COMMIT / PUSH</p>
<h3><a class="header" href="#nmea-simulátor" id="nmea-simulátor">NMEA (simulátor)</a></h3>
<p>Pro obsluhu GPIO v simulátoru jsou vyhrazeny příkazy <a href="cviceni/./../simulator/zpravy/BEEP.html">BEEP</a>, <a href="cviceni/./../simulator/zpravy/LED.html">LED</a>, <a href="cviceni/./../simulator/zpravy/BTN.html">BTN</a>, případně nízkoúrovňové <a href="cviceni/./../simulator/zpravy/GPIO.GET.html">GPIO.GET</a>, <a href="cviceni/./../simulator/zpravy/GPIO.SET.html">GPIO.SET</a>, <a href="cviceni/./../simulator/zpravy/GPIO.DIR.html">GPIO.DIR</a>, avšak tyto nejsou nijak simulátorem zpracovávány. Implementujte je do svého programu pouze v okamžiku, pokud budete chtít získat 5b navíc jízdou reálného robotu na konci semestru.</p>
<h2><a class="header" href="#adc-60minut" id="adc-60minut">ADC (60minut)</a></h2>
<h3><a class="header" href="#vzorový-projekt-1" id="vzorový-projekt-1">Vzorový projekt</a></h3>
<p>Založte na aktuáním &quot;master&quot; novou větev pojmenovanou &quot;hw-cv5-adc&quot;, přepněte se do ní a upravte kód vzorového projektu tak, 
aby obsahoval následující kód:</p>
<pre><code class="language-cpp">#include &lt;roboutils/io/ADC.h&gt;
#include &lt;roboutils/util/timing.h&gt;

using namespace RoboUtils;
using namespace RoboUtils::IO;

int main()
{
  I2C i2c;
  ADC adc{i2c};
  
  i2c.open(&quot;/dev/i2c-3&quot;);

  while (true) {
    auto result = adc.Mode2Measure(0);
    std::cout &lt;&lt; result[0] &lt;&lt; std::endl;
    delay(100);
  }
}
</code></pre>
<p>Popište jeho funkci, a ověřte ji spuštěním. Opět si prohlédněte dokumentaci a nabízené funkce.</p>
<p>COMMIT / PUSH</p>
<h3><a class="header" href="#princip-měření" id="princip-měření">Princip měření</a></h3>
<p>Popište, jak funguje A/D převodník, a jaké hodnoty na svém výstupu dává.</p>
<p>S pomocí datasheetu popište, minimální, a maximální čtenou hodnotu na pinu ADC2 a případně chybějící kódy. 
Ověřte na reálném hardware s pomocí dodaného obyčejného potenciometru.</p>
<h3><a class="header" href="#vliv-vstupního-děliče" id="vliv-vstupního-děliče">Vliv vstupního děliče</a></h3>
<p>Podívejte se do schematu od desky MAINBOARD na dělič napětí na pinu ADC0 a spočítejte převodní konstantu, která
převede změřenou analogovou hodnotu na absolutní hodnotu napětí.</p>
<p>Konstantu implementujte v kódu a porovnejte s údajem zobrazeným na zdroji DIAMETRAL. Diskutujte
výsledky.</p>
<p>COMMIT / PUSH</p>
<h3><a class="header" href="#dosažitelná-přesnost-měření" id="dosažitelná-přesnost-měření">Dosažitelná přesnost měření</a></h3>
<p>Na desku byly osazeny rezistory s tolerancí 5%. Spočítejte, jaká bude tolerance měřeného napětí
v 10 bitovém, 14bitovém a 18bitovém režimu měření ? U všech tolerancí počítejte s obdélníkovým
tolerančním polem (značně si usnadníte práci)</p>
<p>Odpovídá pozorovaný údaj vypočítané toleranci měření ?</p>
<h3><a class="header" href="#nmea-simulátor-1" id="nmea-simulátor-1">NMEA (simulátor)</a></h3>
<p>Pro obsluhu analogově/digitálního převodníku v simulátoru je vyhrazen příkaz <a href="cviceni/./../simulator/zpravy/SENSOR.html">SENSOR</a>. 
Vraťte se tedy ke kódu předchozího cvičení (jiný projekt) a zkuste změřit na reálném robotu (nebo i simulovaném doma) 
úroveň napájecího napětí, tentokráte s pomocí NMEA zpráv.</p>
<p>(tuto část můžete již dělat na simulátoru doma, nezapomeňte commitovat/ pushovat aby i ostatní změny viděli !)</p>
<h1><a class="header" href="#očekávané-výstupy-práce-v-tomto-cvičení" id="očekávané-výstupy-práce-v-tomto-cvičení">Očekávané výstupy práce v tomto cvičení</a></h1>
<p>✅ Jste schopni na reálném hardware nastavit I2C sběrnici</p>
<p>✅ Chápete možné problémy a důsledky použití sběrnice I2C</p>
<p>✅ Rozumíte obecným GPIO na obvyklých embedded zařízeních</p>
<p>✅ Dokážete ošetřit jednoduché GPIO periferie (tlačítko, LED)</p>
<p>✅ Rozumíte principu AD převodníku</p>
<p>✅ Dokážete binární hodnotu převodníku převést na reálnou měřenou hodnotu dle schematu</p>
<p>✅ Dokážete diskutovat přesnost měření AD převodníku včetně vlivu měřicího řetězce</p>
<h1><a class="header" href="#Řízení-motorů" id="Řízení-motorů">Řízení motorů</a></h1>
<p>Cvičící: Ing. František Burian  Ph.D.</p>
<h2><a class="header" href="#cile-1" id="cile-1">Cile</a></h2>
<ul>
<li>Vyzkoušet chování reálného krokového motoru v reálných podmínkách</li>
<li>Rozpohybovat kola simulovaného robota tak, aby bylo možné řidit jeho pohyb pomocí kinematiky.</li>
<li>Zprovoznit čtení ujeté dráhy jednotlivých motorů.</li>
</ul>
<h2><a class="header" href="#prerekvizity-1" id="prerekvizity-1">Prerekvizity</a></h2>
<ul>
<li>Pro HW část funkční hardware</li>
<li>Funkční komunikace se simulátorem (ověřit pomocí zprávy <code>PING</code>)</li>
<li>Funkční parsování NMEA řetězců</li>
</ul>
<h2><a class="header" href="#komunikace-s-reálným-budičem-krokového-motoru" id="komunikace-s-reálným-budičem-krokového-motoru">Komunikace s reálným budičem krokového motoru</a></h2>
<h3><a class="header" href="#Řetězec-řízení" id="Řetězec-řízení">Řetězec řízení</a></h3>
<p>Raspberry -- I2C -- interpolátor -- budič -- motor -- převodovka -- kolo</p>
<h3><a class="header" href="#příklad-komunikace-s-krokovým-motorem" id="příklad-komunikace-s-krokovým-motorem">Příklad komunikace s krokovým motorem</a></h3>
<p>Vraťte se k programu z předchozího cvičení, založte novou větev &quot;hw-cv6-km2&quot; na původním masteru a vložte tento kód:</p>
<pre><code class="language-cpp">  using namespace RoboUtils;

  const auto LBUT = Pin::PA7;
  const auto RBUT = Pin::PA6;

  int main()
  {
    I2C i2c{&quot;/dev/i2c-3&quot;};
    GPIO gpio{&amp;i2c};
    KM2 km2{&amp;i2c};

    gpio.input(LBUT | RBUT, true);

    int spdl = 2, spdr = 2; // 2 mikrokroky za 1/40kHz

    while (true) {
      delay(50);                        // zajisteni periody smycky
      auto [ left, right] = km2.driveodo(spdl,spdr);

      // zde pracujte s odometrií a hodnotami rychlosti motoru

    }

    // dobra aplikace po sobe na konci uklidi
    km2.drive(0,0);
  }
</code></pre>
<p>COMMIT / PUSH</p>
<p>Program spusťte, motor by se měl pomalu roztočit. Prozkoumejte API knihovny jakým způsobem to je provedeno.</p>
<h3><a class="header" href="#motor-připojený-ke-kolu---metrický-popis-jednotek" id="motor-připojený-ke-kolu---metrický-popis-jednotek">Motor připojený ke kolu - metrický popis jednotek</a></h3>
<p>Krokový motor se s každým impulzem na vinutích posunuje o 1 krok (step). Tyto kroky je možné rozdělit na menší části, mikrokroky.</p>
<p>✅ Počet kroků na otáčku je vlastností daného krokového motoru. Mikrokrok a množství jeho úrovní je vlastností použitého budiče motorů.</p>
<p>✅ Z katalogového listu motoru byste zjistili, že rozměr kroku je 1.8°, na plnou otáčku tedy připadá kolik kroků?</p>
<details>
    <summary>Odpověď</summary>
    360 / 1.8 = 200
</details>
<p>✅ Zadaný budič motorů rozdělí krok do 32 mikrokroků, kolik mikrokroků připadá na celou otáčku?</p>
<details>
    <summary>Odpověď</summary>
    200 * 32 = 6400
</details>
<br/><br/>
<p>Pokud řídíme reálné fyzikální systémy je vhodné programovat pomocí reálných fyzikálních jednotek a vždy to dodržovat, nestane se, že nebudeme vědět jaký rozměr má nějaká proměnná.</p>
<p>Pro řízení motoru je vhodná úhlová rychlost zadaná v otáčkách za sekundu a tuto rychlost převeďte mikrokroky za sekundu.</p>
<details>
    <summary>Odpověď</summary>
    speedInMicrosteps = targetSpeed * microstepsPerRevolution
</details>
<p>Naopak, pro popis odometrie, tj ujeté vzdálenosti kolem je vhodné popsat veličinu v jednotkách SI tedy metrech. To samozřejmě ovlivňuje průměr (respektive obvod) kola. Jak to provedeme?</p>
<details>
    <summary>Odpověď</summary>
    targetPosition = positionInMicrosteps * wheelCircumference / microstepsPerRevolution
</details>
<h3><a class="header" href="#zjištění-maximálních-rychlostí-reálného-motoru" id="zjištění-maximálních-rychlostí-reálného-motoru">Zjištění maximálních rychlostí reálného motoru</a></h3>
<p>Upravte program v příkladu tak, abyste mohli pomocí tlačítek PB6 a PB7 přidávat a ubírat rychlost, kterou posílá do motorů. Sledujte vliv 
této rychlosti na napájecím proudu obou motorů (zdroj DIAMETRAL, měření proudu).</p>
<details>
    <summary>Pozorování</summary>
    Proud, tedy výkon dodávaný do zátěže od určité rychlosti začne klesat !
</details>
<p>COMMIT / PUSH</p>
<p>Vysvětlete pozorované chování a zhodnoťte důsledky pro řízení takovéhoto motoru</p>
<details>
    <summary>Odpověď</summary>
    V určitých otáčkách již nevyvineme sílu na pokračování otáčení motorem a motor se zastaví. 
</details>
<p>Upravte program tak, aby se po stisknutí tlačítka motor rozjel na rychlosti, při které byl naměřen <strong>poloviční</strong> proud v předchozím experimentu. 
Zkuste zatěžovat (prstem) motor, a pozorujte chování. Zkuste totéž při rychlosti, při které byl proud naměřený na diametralu <strong>maximální</strong>. 
Pozorujte chování a zhodnoťte pozorování.</p>
<details>
    <summary>Odpověď</summary>
    Při nejvyšším příkonu můžeme vyvinout nejvyšší sílu. Sílu temelínu najdeme v hermelínu. Čím vyšší bude mít robot hmotnost, tím více zatěžujeme motory a tím menší zrychlení utáhne. Problém lze obejít snížením síly potřebné pro otáčení - tj snížením zrychlení.
</details>
<p>COMMIT / PUSH</p>
<h3><a class="header" href="#rampový-generátor" id="rampový-generátor">Rampový generátor</a></h3>
<p>Snížení zrychlení lze realizovat různými způsoby (například interpolací po S-křivce). Jednodušší variantou je interpolace po obyčejné rychlostní<br />
(někdy též zvané trapézoidní) rampě, která je mnohem jednodušší.</p>
<p>✅ Algoritmus: V každém kroku řízení k momentální rychlosti motoru přičteme požadovanou diferenci rychlosti se stejným znaménkem jako má rozdíl <code>požadovaná rychlost - momentální rychlost</code>. Tuto diferenci však saturujeme na maximálních hodnotách.</p>
<p><img src="cviceni/../images/ramp_gen.jpg" alt="Generator Ramp" /></p>
<p>Generátor rampy, který běží periodicky, efektivně řeší problém s opakováním řídicích zpráv pro motory, stačí periodicky získávat novou hodnotu rychlosti z generátoru ramp a tu posílat budiči motoru (simulátoru).</p>
<p>Upravte program tak, aby se po stisknutí tlačítka motor rozjel na hodnotu rychlosti, při které byl naměřen <strong>poloviční</strong> proud v předchozím experimentu a porovnejte výsledky s předchozím měřením</p>
<details>
    <summary>Pozorování</summary>
    Motor se snížením rampy lze zatížit více a tím pádem dosáhnout vyšší rychlosti bez zastavení. Čím pomalejší rampa je, tím více síly motoru zbyde pro udržení rychlosti, ale reakce motoru se notně zpomalí.
</details>
<p>COMMIT / PUSH</p>
<h2><a class="header" href="#nmea-protokol" id="nmea-protokol">NMEA protokol</a></h2>
<p>Otevřete si projekt z minulého / předminulého cvičení, kde jste zpracovávali NMEA protokol. Následující body již nemusíte tvořit na cvičení, lze je realizovat i v simulátoru.</p>
<p>V tomto cvičení již budete ovládat robota pomocí NMEA zpráv, je tedy nutné pravidelně navracet simulátor do výchozího stavu.
Toho lze dosáhnout jak opětovným spuštěním jak simulátoru, tak vašeho programu, lze to ale řešit přímočařeji, a to tak,
že při startu vašeho programu simulátoru pošlete NMEA zprávu <a href="cviceni/./../simulator/zpravy/RESET.html">RESET</a>.</p>
<p>✅ Po odeslání resetu byste měli přijmout NMEA zprávu <code>$RESET,DONE</code>.</p>
<p>Pakliže nepřijmete DONE, program ukončete s chybou.</p>
<p>Simulátor simuluje chování dvou krokových motorů, na které jsou namonotována kola uživatelsky definovaného průměru.
Motory jsou řízeny pomocí NMEA zpráv <a href="cviceni/./../simulator/zpravy/SPEED.html">SPEED</a> a <a href="cviceni/./../simulator/zpravy/ODO.html">ODO</a> posílaných simulátoru.</p>
<h3><a class="header" href="#nastavení-rychlosti-kol" id="nastavení-rychlosti-kol">Nastavení rychlosti kol</a></h3>
<p>Příkaz pro nastavení rychlosti motoru je <a href="cviceni/./../simulator/zpravy/SPEED.html">SPEED</a>. Pošleme tedy tento příkaz simulátoru s nějakou malou 
rychlostí levého kola, třeba 0.05 otáčky za sekundu a nulovou rychlostí pravého kola.</p>
<p>✅ Pokud nám vše správně funguje, měl by se robot v simulátoru začít pomalu otáčet.</p>
<p>Motor se po asi 1 s otáčení zastaví, toto je bezpečnostní funkce, která je implementována v našich reálných budičích motorů. V případě softwarové chyby, kdy by spadl řídicí program, by se totiž robot mohl nekontrolovatelně rozjet.
Je tedy nutné řídicí příkazy posílat periodicky.</p>
<p>✅ Pokuste se najít maximální rychlost, které jste schopni v simulátoru bez rampy dosáhnout.</p>
<p>COMMIT / PUSH</p>
<h3><a class="header" href="#Čtení-ujeté-vzdálenosti" id="Čtení-ujeté-vzdálenosti">Čtení ujeté vzdálenosti</a></h3>
<p>Pro lokalizaci robota v prostředí lze využít výpočtu odometrie z ujeté vzdálenosti obou kol, to bude předmětem dalších cvičení, je ale vhodné
si to již teď připravit. Čtení ujeté vzdálenost je v simulátoru implementováno pomocí příkazu <a href="cviceni/./../simulator/zpravy/ODO.html">ODO</a>. Tento příkaz 
způsobí, že nám simulátor pošle ujetou vzdálenost v mikrokrocích pro obě kola a sám si vnitřní hodnotu ujeté vzdálenosti vynuluje.</p>
<p>✅ Vyzkoušejte si čtení ujeté vzdálenosti obou motorů a jejich přepočet na ujeté metry.</p>
<p>✅ Vyzkoušejte si, že se hodnota ujeté vzdálenosti opravdu nuluje.</p>
<h2><a class="header" href="#očekávané-výstupy-práce-v-tomto-cvičení-1" id="očekávané-výstupy-práce-v-tomto-cvičení-1">Očekávané výstupy práce v tomto cvičení</a></h2>
<p>✅ Jste schopni ovládat oba motory simulovaného robota v plném rozsahu rychlostí.</p>
<p>✅ Máte naimplementováno generování ramp pro oba motory.</p>
<p>✅ Jste schopni ze simulátoru získávat data o ujeté vzdálenosti pro oba motory.</p>
<h1><a class="header" href="#snímání-čáry" id="snímání-čáry">Snímání čáry</a></h1>
<p>Cvičící: Ing. Tomáš Jílek, Ph.D.</p>
<h2><a class="header" href="#cíle" id="cíle">Cíle</a></h2>
<ul>
<li>Realizovat zpracování signálu z emulovaného optočlenu CNY70.</li>
<li>Implementovat výpočet pozice/orientace čáry vzhledem k ose jízdy robotu s využitím jednoho nebo více emulovaných optočlenů CNY70.</li>
</ul>
<h2><a class="header" href="#prerekvizity-2" id="prerekvizity-2">Prerekvizity</a></h2>
<ul>
<li>Funkční komunikace se simulátorem (ověřit pomocí zprávy <code>PING</code>).</li>
<li>Funkční parsování NMEA řetězců.</li>
<li>Funkční ovládání motorů.</li>
<li>Funkční vyčítání dat z emulovaného KM2 pro výpočet odometrie.</li>
<li>Znalost práce s daty v MATLABu/GNU Octave/Excelu nebo jiném SW pro analýzu dat.</li>
</ul>
<h2><a class="header" href="#výstupy" id="výstupy">Výstupy</a></h2>
<ul>
<li>Spolehlivě fungující měření pozice vodicí čáry vzhledem k ose jízdy robotu s jedním optočlenem CNY70.</li>
<li>Základní verze měřicího systému složeného z více optočlenů CNY70 (např. diferenční zapojení se 2 ks CNY70).</li>
</ul>
<h2><a class="header" href="#odevzdání-výsledku-řešení-cvičení-do-následujícího-cvičení" id="odevzdání-výsledku-řešení-cvičení-do-následujícího-cvičení">Odevzdání výsledku řešení cvičení (do následujícího cvičení)</a></h2>
<ul>
<li>Do složky <code>labs/lab-07/</code> v repozitáři Vašeho projektu uložte:
<ul>
<li>graf změřené statické převodní charakteristiky samotného senzoru bez jakéhokoliv zpracování,</li>
<li>graf statické převodní charakteristiky senzoru po Vašem zpracování,</li>
<li>textový soubor formátovaný v jazyce Markdown, který krátce popisuje Vámi zvolený způsob zpracování dat ze senzoru a odkazuje se na dva předchozí grafy (krátká technická zpráva, rozsah postačí ekv. 1/2 A4, mnohem důležitější je úroveň obsahu, než množství textu).</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#Úkol-č-1-realizace-měření-převodní-charakteristiky-senzoru-cny70" id="Úkol-č-1-realizace-měření-převodní-charakteristiky-senzoru-cny70">Úkol č. 1: Realizace měření převodní charakteristiky senzoru CNY70</a></h2>
<p>Proveďte implementaci automatizovaného měření převodní charakteristiky emulovaného senzoru CNY70. Jedná se o závislost <code>u_raw=f(dD)</code> nebo <code>u_raw=f(dA)</code>, kde <code>u_raw</code> je celočíselná hodnota reprezentující měřené napětí, která je získána z AD převodníku s 12 bitovým registrem pro uložení výsledku AD převodu. Veličina <code>dD</code> odpovídá délkové odchylce senzoru od vodicí čáry. Veličina <code>dA</code> odpovídá úhlové odchylce senzoru od vodicí čáry.</p>
<p>Hodnotu, která je výsledkem A/D převodu, získáte pomocí NMEA zprávy <code>SENSOR</code>, která je ve formátu: <code>$SENSOR,&lt;id&gt;*&lt;chksum&gt;</code>, kde <code>id</code> odpovídá pořadovému číslu senzoru, který je součástí robotu. Senzory jsou indexované od nuly. Registr, ze kterého jsou data čteny, je 12bitový. Skutečné rozlišení použitého převodníku je ale pouze 10bitové, spodní 2 bity jsou tedy vždy nulové. Emulátor navrací zprávu <code>$SENSOR,&lt;id&gt;,&lt;value&gt;*&lt;chksum&gt;</code>, kde <code>value</code> je celočíselná hodnota, která je výsledkem A/D převodu.</p>
<h3><a class="header" href="#možný-způsob-řešení-nápověda" id="možný-způsob-řešení-nápověda">Možný způsob řešení (nápověda)</a></h3>
<p>Charakteristiku <code>u_raw=f(dD)</code> můžete získat např. tak, že robotem nakolmo přejedete čáru a uložíte si změřené hodnoty <code>u_raw</code>, <code>dGamma1</code> a <code>dGamma2</code>. <code>dGamma1</code> a <code>dGamma2</code> jsou počty mikrokroků ujeté každým kolem během příslušné periody vzorkování. Charakteristiku <code>u_raw=f(dA)</code> můžete získat obdobným způsobem, t.j. robot stojí na místě a otáčí se kolem své osy.</p>
<h2><a class="header" href="#Úkol-č-2-návrh-detekčního-systému-s-jedním-optočlenem-cny70-pro-měření-pozice-čáry-vzhledem-k-ose-jízdy-robotu" id="Úkol-č-2-návrh-detekčního-systému-s-jedním-optočlenem-cny70-pro-měření-pozice-čáry-vzhledem-k-ose-jízdy-robotu">Úkol č. 2: Návrh detekčního systému s jedním optočlenem CNY70 pro měření pozice čáry vzhledem k ose jízdy robotu</a></h2>
<p>Navrhněte vlastní systém pro měření pozice čáry s využitím optočlenu CNY70. Pro snažší pochopení chování optočlenu v uvedené aplikaci Vám může pomoci proměření vlivu vzdálenosti odrazné roviny na převodní charakteristiku. Umístěte senzor na robot tak, aby bylo možné snímat vychýlení optočlenu od osy vodící čary v co největším rozsahu a současně spolehlivě! Výstupní hodnotu algoritmu pro zpracování měřených dat kalibrujte ve vhodných fyzikálních jednotkách (metry / milimetry / atd.).</p>
<h2><a class="header" href="#Úkol-č-3-návrh-detekčního-systému-s-více-optočleny-cny70-pro-měření-poziceorientace-čáry-vzhledem-k-ose-jízdy-robotu" id="Úkol-č-3-návrh-detekčního-systému-s-více-optočleny-cny70-pro-měření-poziceorientace-čáry-vzhledem-k-ose-jízdy-robotu">Úkol č. 3: Návrh detekčního systému s více optočleny CNY70 pro měření pozice/orientace čáry vzhledem k ose jízdy robotu</a></h2>
<p>Pro zvýšení měřicího rozsahu a robustnosti měření je možné použít více optočlenů CNY70, které budou vhodně prostorově rozmístěny. Nejprve je doporučeno vyzkoušet diferenční zapojení dvou optočlenů a až potom se pouštět do sofistikovanějších zapojení s více optočleny.</p>
<p>Při návrhu měřicího systému vhodného pro detekci pozice/orientace vodicí čáry je doporučeno zvážit minimálně tyto parametry/vlastnosti:</p>
<ul>
<li>minimální počet potřebných optočlenů CNY70,</li>
<li>prostorové rozmístění optočlenů CNY70 (jejich souřadnice <code>x</code>, <code>y</code>, <code>z</code> v souřadnicovém systému robotu),</li>
<li>linearizace převodní charakteristiky jednotlivých optočlenů/celého detekčního systému,</li>
<li>kalibrace jednotlivých optočlenů (statická - po zapnutí / dynamická - po celou dobu jízdy),</li>
<li>způsob vyhodnocení dat ze senzoru - charakter výstupní veličiny (počet diskrétních stavů - 2 a nebo více).</li>
</ul>
<h2><a class="header" href="#nápověda-č-1-zápis-naměřených-dat-do-souboru" id="nápověda-č-1-zápis-naměřených-dat-do-souboru">Nápověda č. 1: Zápis naměřených dat do souboru</a></h2>
<p>Naměřená data je doporučeno prozatím logovat do souborů. Kdo zvládne logovat přes síť, může použít i tento způsob. Real-time sběr telemetrie bude náplní jednoho z dalších cvičení.</p>
<p>Pro snadnou, rychlou a bezproblémovou práci je doporučeno ukládat měřená data do snáze čitelného formátu souboru, který bude používán v aplikaci, kterou budete naměřená data analyzovat. Doporučen je primárně <code>MATLAB</code> nebo <code>GNU Octave</code>. Kdo s tím má problém, je to jeho problém. Příznivci jazyka Python mohou použít např. prostředí <code>Spyder</code> a v něm balíček <code>NumPy</code>. V nouzi postačí i tabulkový procesor (<code>MS Office Excel</code>, <code>LibreOffice Calc</code>, atd.).</p>
<h3><a class="header" href="#formát-csv-comma-separated-values-souboru" id="formát-csv-comma-separated-values-souboru">Formát CSV (Comma-separated values) souboru</a></h3>
<p>Čísla jsou v textovém vyjádření, desetinným oddělovačem je tečka, odělovačem hodnot v řádku je čárka, oddělovačem nových řádků v tabulce je konec řádku <code>&lt;CR&gt;&lt;LF&gt;</code> pro platformu Windows, pro Linux je to jen <code>&lt;LF&gt;</code>.</p>
<h3><a class="header" href="#zápis-dat-do-souboru-v-jazyce-c" id="zápis-dat-do-souboru-v-jazyce-c">Zápis dat do souboru v jazyce C</a></h3>
<pre><code>#include &lt;stdio.h&gt;
FILE *fopen(const char *pathname, const char *mode);
int fprintf(FILE *stream, const char *format, ...);
int fflush(FILE *stream);
int fclose(FILE *stream);
</code></pre>
<h2><a class="header" href="#nápověda-č-2-přístup-k-souborům-a-jejich-přenos-mimo-os-linux" id="nápověda-č-2-přístup-k-souborům-a-jejich-přenos-mimo-os-linux">Nápověda č. 2: Přístup k souborům a jejich přenos mimo OS Linux</a></h2>
<p>Naměřená data, která jste si uložili v OS Linux budete chtít nejspíše analyzovat mimo tento systém. Uložené soubory tedy budete v tomto případě potřebovat přenést na jiné zařízení nebo např. z hostovaného OS (Ubuntu), který vám běží ve VM do hostujícího OS (např. Windows), na kterém běžně pracujete. Existuje několik způsobů jak toto realizovat:</p>
<ul>
<li>zpřístupnit lokální složku v OS Linux prostřednictvím protokolu SMB (externí přístup z platforem Windows, Linux i Mac k souborům na Ubuntu přes sdílenou síťovou složku),</li>
<li>přenést soubory přes síť s využitím protokolu SFTP (dostupné aplikace: <code>WinSCP</code>, <code>FileZilla</code>, <code>psftp</code>, <code>Total Commander</code> + <code>SFTP plugin</code>, atd.),</li>
<li>soubory přenést na externí úložiště připojené v Ubuntu přes rozhraní USB (flash disk, HDD/SSD) nebo síť (NAS, atd.).</li>
</ul>
<h2><a class="header" href="#nápověda-č-3-zobrazení-naměřených-dat-v-matlabu--gnu-octave" id="nápověda-č-3-zobrazení-naměřených-dat-v-matlabu--gnu-octave">Nápověda č. 3: Zobrazení naměřených dat v MATLABu / GNU Octave</a></h2>
<h3><a class="header" href="#načtení-souboru-ve-formátu-csv-s-naměřenými-daty" id="načtení-souboru-ve-formátu-csv-s-naměřenými-daty">Načtení souboru ve formátu CSV s naměřenými daty</a></h3>
<pre><code>M = csvread(filename)
</code></pre>
<h3><a class="header" href="#vykreslení-grafu" id="vykreslení-grafu">Vykreslení grafu</a></h3>
<pre><code>figure(f)
clf
plot(X, Y, LineSpec)
plot(X, Y, LineSpec, 'LineWidth', width, 'MarkerSize', size)
xlabel(txt)
ylabel(txt)
title(txt)
legend(label1,...,labelN)
</code></pre>
<h2><a class="header" href="#nápověda-č-4-textový-bargraf-v-konzoli" id="nápověda-č-4-textový-bargraf-v-konzoli">Nápověda č. 4: Textový bargraf v konzoli</a></h2>
<pre><code>// funkce na vytvoreni jedne hodnoty grafu do konzole
// buffer ... predalokovany pracovni buffer do ktereho se bude zapisovat text
// nchars ... pocet znaku v bufferu
// val ... hodnota (0...1) k vytisteni
// navratovou hodnotu lze rovnou pouzit jako parametr do printf (&quot;%s&quot;, s)
const char *graf(char* buffer, int nchars, float value)
{
  int end = (int)(value * nchars) - 3; // start pipe, end pipe a koncova nula

  buffer[0] = '|';
  int i=1;

  while (i &lt; end)
    buffer[i++] = '=';

  buffer[i++] = '|';

  while (i &lt; nchars)
    buffer[i++] = ' ';

  buffer[nchars-1] = 0;
  return buffer;
}

printf(&quot;%d %%: %s&quot;, value, graf(buffer, 20, value));
</code></pre>
<h1><a class="header" href="#návrh-regulační-smyčky" id="návrh-regulační-smyčky">Návrh regulační smyčky</a></h1>
<p>Cvičící: Ing. Tomáš Jílek, Ph.D.</p>
<h2><a class="header" href="#cíle-1" id="cíle-1">Cíle</a></h2>
<ul>
<li>Implementovat ovládání diferenciálně řízeného podvozku.</li>
<li>Navrhnout a implementovat spolehlivý regulátor pro sledování trasy.</li>
</ul>
<h2><a class="header" href="#prerekvizity-3" id="prerekvizity-3">Prerekvizity</a></h2>
<ul>
<li>Funkční komunikace se simulátorem - ovládání motorů + čtení stavu senzorů.</li>
<li>Funkční měření odchylky robotu od žádané trajektorie.</li>
<li>Funkční generátor žádané trajektorie.</li>
</ul>
<h2><a class="header" href="#výstupy-1" id="výstupy-1">Výstupy</a></h2>
<ul>
<li>Spolehlivě fungující implementace sledování trajektorie.</li>
</ul>
<h2><a class="header" href="#odevzdání-výsledku-řešení-cvičení-do-následujícího-cvičení-1" id="odevzdání-výsledku-řešení-cvičení-do-následujícího-cvičení-1">Odevzdání výsledku řešení cvičení (do následujícího cvičení)</a></h2>
<ul>
<li>Do složky <code>labs/lab-08</code> v repozitáři Vašeho projektu uložte:
<ul>
<li>3 grafy časového vývoje regulační odchylky + akčních zásahů při:
<ul>
<li>sledování přímé trasy,</li>
<li>sledování trasy reprezentované kruhovým obloukem o poloměru 20 cm,</li>
<li>sledování trasy reprezentované kruhovým obloukem o poloměru 5 cm,</li>
</ul>
</li>
<li>textový soubor formátovaný v jazyce Markdown, který krátce popisuje zvolené a implementované řešení včetně postupu nalezení konstant regulátoru.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#Úkol-č-1-implementace-ovládání-diferenciálně-řízeného-podvozku" id="Úkol-č-1-implementace-ovládání-diferenciálně-řízeného-podvozku">Úkol č. 1: Implementace ovládání diferenciálně řízeného podvozku</a></h2>
<p>Implementujte inverzní kinematiku pro diferenciálně řízený podvozek. Identifikujte hodnoty konstant, které jsou k výpočtu potřeba.</p>
<pre><code>motor_left_speed  = (robot_linear_speed + 0.5 * C_TW * robot_angular_speed) * C_L
motor_right_speed = (robot_linear_speed - 0.5 * C_TW * robot_angular_speed) * C_R
</code></pre>
<p>V proměnných <code>left_motor_speed</code> a <code>right_motor_speed</code> jsou již přímo hodnoty, které je třeba zapsat do emulovaného ovladače krokových motorů. Konstanta <code>C_TW</code> je rozteč kol (šířka nápravy) [m]. Konstanty C_L a C_R jsou v jednotkách <code>[microstep/m]</code>, konstanty tedy vyjadřují potřebný počet mikrokroků na 1 metr ujeté vzdálenosti daným kolem.</p>
<p>Parametry použitých komponent</p>
<pre><code>             Wheel: wheel_diameter * pi [m/turn]
     Stepper motor: 200 [step/turn]
      Motor driver: 32 [microstep/step]
</code></pre>
<h3><a class="header" href="#postup-výpočtu" id="postup-výpočtu">Postup výpočtu</a></h3>
<pre><code>ROBOT(v [m/s], omega [rad/s]) -&gt; WHEEL(v_left, v_right [m/s]) -&gt; MOTOR(omega_left, omega_right [microstep/s])
</code></pre>
<h2><a class="header" href="#Úkol-č-2-ověření-správnosti-implementace-řešené-v-předchozím-bodu" id="Úkol-č-2-ověření-správnosti-implementace-řešené-v-předchozím-bodu">Úkol č. 2: Ověření správnosti implementace řešené v předchozím bodu.</a></h2>
<p>Než přistoupíte k návrhu a nastavování regulátoru, je vhodné ověřit, že robot opravdu vykonává pohyb, který je od něho očekáván. Správnou funkčnost je možné ověřit např. na těchto pohybech:</p>
<ul>
<li>jízda po přímce (<code>v</code> je nenulové, <code>omega = 0 deg/s</code>)
<ul>
<li>např. při <code>v = 1 cm/s</code> by měl robot za 10 sekund ujet vzdálenost 10 cm</li>
</ul>
</li>
<li>otáčení na místě (<code>v = 0 m/s</code>, <code>omega</code> je nenulová)
<ul>
<li>např. při <code>omega = 36 deg/s</code> by se robot měl za 10 sekund otočit kolem své osy o 360 deg, tj. dostat se do výchozí orientace</li>
</ul>
</li>
<li>jízda po kruhovém oblouku (<code>v</code> i <code>omega</code> jsou nenulové)
<ul>
<li>např. při <code>v = 1 cm/s</code> a <code>omega = 36 deg/s</code> by trajektorie robotu měla být kružnice o poloměru cca 1,6 cm (změna ujeté vzdálenosti bude 10 cm, změna orientace bude 360 deg)</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#Úkol-č-3-návrh-a-implementace-regulátoru-pro-sledování-trajektorie" id="Úkol-č-3-návrh-a-implementace-regulátoru-pro-sledování-trajektorie">Úkol č. 3: Návrh a implementace regulátoru pro sledování trajektorie</a></h2>
<p>Navrhněte a implementujte regulační strukturu tak, aby robot spolehlivě sledoval trajektorii (nikdy z ní nesjel) a současně byla rychlost sledování trajektorie maximální možná.</p>
<p>Pro ty, kteří zatím netuší, jak postupovat, zde je malý návod, co vyzkoušet:</p>
<ul>
<li>Lineární rychlost pohybu robotu nastavte na pevnou hodnotu (nižší jednotky cm/s, např. 2 cm/s). Pro regulaci úhlové rychlosti pohybu robotu použijte P regulátor. Zesílení P složky postupně zvyšujte od nulové hodnoty.</li>
<li>Přidejte sumační a diferenční složku do regulátoru. Nastavte konstanty PSD regulátoru.</li>
<li>Implementujte ovládání/regulaci lineární složky pohybu robotu (tj. tento akční zásah již nebude konstantní).</li>
<li>Vyhodnoťte, které složky (P/S/D) jsou v regulátoru potřeba a jak pozitivně/negativně ovlivňují regulační děj (sledování trasy).</li>
<li>Zkuste se trochu hlouběji zamyslet, jaký má vliv umístění senzorického systému na průběh regulačního děje, příp. jak ovlivňuje potřebnou strukturu regulačního obvodu a požadavky na regulátor.</li>
<li>Na základě zjištěných informací se pokuste navrhnout vlastní regulační schéma pro dosažení co nejlepších výsledků sledování trasy.</li>
</ul>
<h1><a class="header" href="#návrh-regulátorů-a-regulační-smyčky-pro-spolehlivé-sledování-čáry-při-vyšších-rychlostech-jízdy" id="návrh-regulátorů-a-regulační-smyčky-pro-spolehlivé-sledování-čáry-při-vyšších-rychlostech-jízdy">Návrh regulátorů a regulační smyčky pro spolehlivé sledování čáry při vyšších rychlostech jízdy</a></h1>
<p>Cvičící: Ing. Tomáš Jílek, Ph.D.</p>
<h2><a class="header" href="#cíle-2" id="cíle-2">Cíle</a></h2>
<ul>
<li>Implementovat spolehlivou navigaci robotu podél žádané trajektorie při současné maximalizaci průměrné rychlosti jízdy.</li>
</ul>
<h2><a class="header" href="#prerekvizity-4" id="prerekvizity-4">Prerekvizity</a></h2>
<ul>
<li>Funkční komunikace se simulátorem - ovládání motorů + čtení stavu senzorů.</li>
<li>Funkční generátor žádané trajektorie.</li>
<li>Funkční kalibrovaný senzorický systém měřící jeho vzdálenost od referenční oblasti na vodicí čáře nebo jeho orientaci k vodicí čáře.</li>
<li>Funkční kalibrované ovládání pohybu robotu.</li>
<li>Funkční základní regulační smyčka.</li>
</ul>
<h2><a class="header" href="#výstupy-2" id="výstupy-2">Výstupy</a></h2>
<ul>
<li>Správně implementovaný a fungující PSD regulátor pro regulaci úhlové rychlosti robotu.</li>
<li>Ovládání rychlosti jízdy robotu maximalizující jeho průměrnou rychlost jízdy na celé trase.</li>
<li>(NEPOVINNÉ) Parametrizovatelný senzorický systém pro měření úhlové a/nebo vzdálenostní odchylky robotu od vodicí čáry.</li>
</ul>
<h2><a class="header" href="#odevzdání-výsledku-řešení-cvičení-do-následujícího-cvičení-2" id="odevzdání-výsledku-řešení-cvičení-do-následujícího-cvičení-2">Odevzdání výsledku řešení cvičení (do následujícího cvičení)</a></h2>
<ul>
<li>Do složky <code>labs/lab-09</code> v repozitáři Vašeho projektu uložte:
<ul>
<li>schéma výsledné regulační struktury,</li>
<li>3 grafy časového vývoje regulační odchylky + VŠECH akčních zásahů do soustavy (výsledná reg. struktura) při:
<ul>
<li>sledování přímé trasy,</li>
<li>sledování trasy reprezentované kruhovým obloukem o poloměru 20 cm,</li>
<li>sledování trasy reprezentované kruhovým obloukem o poloměru 5 cm,</li>
</ul>
</li>
<li>textový soubor formátovaný v jazyce Markdown, který krátce popisuje navržené a implementované řešení včetně postupu nalezení konstant regulátorů.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#Úkol-č-1-implementace-psd-regulátoru" id="Úkol-č-1-implementace-psd-regulátoru">Úkol č. 1: Implementace PSD regulátoru</a></h2>
<p>Proveďte implementaci PSD regulátoru a všech souvisejících potřebných interních algoritmů regulátoru, které jsou nutné pro použití v reálné regulační smyčce (anti-windup, atd.).</p>
<h2><a class="header" href="#Úkol-č-2-nastavení-konstant-psd-regulátoru" id="Úkol-č-2-nastavení-konstant-psd-regulátoru">Úkol č. 2: Nastavení konstant PSD regulátoru</a></h2>
<p>Nastavte konstanty PSD regulátoru úhlové rychlosti robotu tak, aby zajistil sledování žádané trajektorie s vyhovující přesností při maximální možné průměrné rychlosti jízdy. Porovnejte mezi sebou různá nastavení regulátoru získaná pomocí návrhových metod, které byly probrány v kurzech Řízení a regulace.</p>
<h2><a class="header" href="#Úkol-č-3-návrh-a-úprava-regulační-struktury" id="Úkol-č-3-návrh-a-úprava-regulační-struktury">Úkol č. 3: Návrh a úprava regulační struktury</a></h2>
<p>Identifikujte nedostatky stávající regulační struktury a navrhněte a implementujte její úpravu tak, aby došlo k potlačení nebo úplné eliminaci nežádoucích vlastností stávající regulační struktury. Do návrhu zakomponujte např. maximalizaci průměrné rychlosti jízdy na celé trajektorii.</p>
<h2><a class="header" href="#Úkol-č-4-implementace-měření-pozice-a-orientace-robotu" id="Úkol-č-4-implementace-měření-pozice-a-orientace-robotu">Úkol č. 4: Implementace měření pozice a orientace robotu</a></h2>
<p>Implementujte výpočet odometrie ze zpráv ODO:</p>
<ul>
<li>ujetá vzdálenost levým a pravým kolem za poslední periodu vzorkování,</li>
<li>ujetá vzdálenost robotem za poslední periodu vzorkování,</li>
<li>změna orientace robotu za poslední periodu vzorkování,</li>
<li>změna pozičních souřadnic robotu za poslední periodu vzorkování,</li>
<li>aktuální pozici a orientaci robotu.</li>
</ul>
<h2><a class="header" href="#Úkol-č-5-nepovinnÉ-implementace-parametrizovatelného-senzorického-systému" id="Úkol-č-5-nepovinnÉ-implementace-parametrizovatelného-senzorického-systému">Úkol č. 5: (NEPOVINNÉ) Implementace parametrizovatelného senzorického systému</a></h2>
<h2><a class="header" href="#Úkol-č-6-nepovinnÉ-přenos-a-parametrizace-řešení-na-reálný-hw-platforma-kambot" id="Úkol-č-6-nepovinnÉ-přenos-a-parametrizace-řešení-na-reálný-hw-platforma-kambot">Úkol č. 6: (NEPOVINNÉ) Přenos a parametrizace řešení na reálný HW (platforma KAMbot)</a></h2>
<h1><a class="header" href="#telemetrie-a-vizualizace" id="telemetrie-a-vizualizace">Telemetrie a vizualizace</a></h1>
<p>Cvičící: Ing. Adam Ligocki, Ph.D., Ing. Tomáš Horeličan</p>
<p>Před cvičením si zopakujte návod <a href="cviceni/../chap_1_software/text/ros.html">ROS</a> z kapitoly <a href="cviceni/../chap_1_software/text/intro.html">Softwarové vybavení</a></p>
<h1><a class="header" href="#tvorba-vlastního-ros-nodu-cca-1h" id="tvorba-vlastního-ros-nodu-cca-1h">Tvorba vlastního ROS nodu (cca 1h)</a></h1>
<p>V první fázi cvičení si vytvoříme svůj vlastní ROS workspace (složka, která obsahuje ROS package) a ROS package (CMakeList projekt, který pracuje s ROS knihovnama).</p>
<p>Přistup je dvojí. Je možné použít příkazy z příkazové řádky (<code>catkin_pkg_create</code>, <code>catkin_make</code>, ...) pro automatickou tvorbu všech výchozích souborů, knihoven a složek pro daný package.</p>
<p>Oficiální tutoriály pro práci s CLI:</p>
<ul>
<li><a href="http://wiki.ros.org/ROS/Tutorials/NavigatingTheFilesystem">ROS File Systém</a></li>
<li><a href="http://wiki.ros.org/ROS/Tutorials/CreatingPackage">Tvorba balíčku</a></li>
<li><a href="http://wiki.ros.org/ROS/Tutorials/BuildingPackages">Kompilace balíčku</a></li>
<li><a href="http://wiki.ros.org/ROS/Tutorials/UnderstandingNodes">Vysvětlení ROS nodu</a></li>
<li><a href="http://wiki.ros.org/ROS/Tutorials">Ostatní tutoriálny</a></li>
</ul>
<p>My si však dnes vytvoříme balíčky ručně a při tom si vysvětlíme jednotlivé kroky, které první způsob právě automatizuje.</p>
<p>V prvním kroku si vytvoříme na libovolném místě ve file systému složku <code>ros_ws</code>. Jméno složky však může být libovolné. Je jen dobré zachovávat &quot;best practice&quot; postupy. Uvnitř právě vytvořené složky <code>ros_ws</code> si vyrobíme složku <code>src</code>. Tímto jsme vytořili ROS workspace.</p>
<p>Nyní se přesuneme do podsložky <code>ros_ws/src/</code>. Nacházíme se v místě, kde se umisťují tzv. ROS balíčky (package), tedy CMake projekty, které pracují s ROS knihovnou. V našem případě si vytvoříme jeden balíček tak, že vytvoříme složku <code>my_first_ros_project</code>. Uvnitř této složky pak vytvoříme složky <code>include</code> a <code>src</code>, a soubory <code>package.xml</code> a <code>CMakeLists.txt</code>. Ve složce <code>src</code> pak soubor <code>main.cpp</code> a ve složce <code>include</code> soubor <code>RosExampleClass.h</code>.</p>
<p>Struktura celého workspacu bude tedy vypadat následovně.</p>
<pre><code>ros_ws/
└── src/
    └── my_first_ros_package/
        ├── CMakeLists.txt
        ├── include/
        │   └── RosExampleClass.h
        ├── package.xml
        └── src/
            └── main.cpp
</code></pre>
<p>Nejprve si napíšeme obsah <code>CMakeLists.txt</code> souboru. Ten bude následovný.</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.10.0)
project(my_first_ros_project)

## Find catkin and any catkin packages (ros client libraries)
find_package(catkin REQUIRED COMPONENTS roscpp std_msgs)

## Declare a catkin package (internal catkin macro, process package.xml)
catkin_package()

## Add our include directory and include directories with ROS headers
include_directories(include ${catkin_INCLUDE_DIRS})

add_executable(cpp_ros_example src/main.cpp)
target_link_libraries(cpp_ros_example ${catkin_LIBRARIES})
</code></pre>
<p>Dále pak soubor <code>package.xml</code></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;package format=&quot;2&quot;&gt;
    &lt;name&gt;my_first_ros_project&lt;/name&gt;
    &lt;version&gt;0.1.0&lt;/version&gt;
    &lt;description&gt;Example ros c++ publisher project&lt;/description&gt;

    &lt;maintainer email=&quot;my@email.todo&quot;&gt;adash&lt;/maintainer&gt;

    &lt;license&gt;TODO&lt;/license&gt;
    &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;
    &lt;build_depend&gt;roscpp&lt;/build_depend&gt;
    &lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;
    &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;
&lt;/package&gt;
</code></pre>
<p>A nyní si již můžeme projekt otevřít jako CMake projekt v CLionu a napsat kód v <code>main.cpp</code>.</p>
<blockquote>
<p><strong>POZOR!</strong> - Je potřeba otevřít CLion v termiále, kde už máte načtené prostředí ROSu (<code>source /opt/ros/noetic/setup.bash</code>) a nebo si všechny potřebné ROS proměnné do otevřeného CLionu doimportovat. </p>
</blockquote>
<pre><code class="language-cpp">#include &lt;ros/ros.h&gt;
#include &quot;RosExampleClass.h&quot;

int main(int argc, char* argv[]) {
    ros::init(argc, argv, &quot;cpp_ros_example&quot;);       // connects node with ros core
    auto node = ros::NodeHandle();                            // API for ros functionality

    auto example_class = RosExampleClass(node, &quot;my_topic&quot;, 1.0);

    while (ros::ok()) {     // main loop
        // your main loop
        ros::spinOnce();    // allows publishers, timers and subscribers to do their job
    }

    // ros::spin(); blocking alternative of while loop above
    return 0;
}
</code></pre>
<p>Vidíte, že v main includujeme <code>RosExampleClass.h</code> a poté vytváříme její instanci. Pojďme tedy tuto třídu vytvořit ve složce <code>include/</code></p>
<pre><code class="language-cpp">#pragma once

#include &lt;iostream&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/Float32.h&gt;

class RosExampleClass {

public:
    RosExampleClass(ros::NodeHandle&amp; node, const std::string&amp; topic, const float freq) : node_{node} {
        publisher_ = node.advertise&lt;std_msgs::Float32&gt;(topic, 0);
        subscriber_ = node.subscribe(topic, 0, &amp;RosExampleClass::subscriber_callback, this);
        timer_ = node.createTimer(freq, &amp;RosExampleClass::timer_callback, this);
        start_time_ = ros::Time::now();
    }

private:

    void timer_callback(const ros::TimerEvent&amp; event) const {
        std::cout &lt;&lt; &quot;Timer callback called&quot; &lt;&lt; std::endl;
        auto uptime = (ros::Time::now() - start_time_).toSec();
        publish_message(uptime);
    }

    void subscriber_callback(const std_msgs::Float32 msg) const {
        std::cout &lt;&lt; &quot;Just received: &quot; &lt;&lt; msg &lt;&lt; std::endl;
    }

    void publish_message(float value_to_publish) const {
        std_msgs::Float32 msg;
        msg.data = value_to_publish;
        publisher_.publish(msg);
        std::cout &lt;&lt; &quot;Just sent: &quot; &lt;&lt; msg.data &lt;&lt; std::endl;
    }

    ros::NodeHandle &amp;node_;
    ros::Publisher publisher_;
    ros::Subscriber subscriber_;
    ros::Timer timer_;
    ros::Time start_time_;
};
</code></pre>
<p>Ti z Vás, kteří si pročetli <a href="cviceni/../chap_1_software/text/ros.html">ROS návody</a> vědí, že ROS funguje na princípu tzv. &quot;uzlů&quot; (<code>node</code>), které můžou (kromě jiného) &quot;publikovat&quot; (<code>publisher</code>) a &quot;odebírat&quot; (<code>subscriber</code>) dáta do/z různych &quot;topiců&quot; (<code>topic</code>).</p>
<p>✅  Prostudujte si kód, který jste právě zkopírovali (nedělám si žádne iluze 🙂) a zkuste si nejprve tipnout co bude náš program dělat když ho spustíme.</p>
<p>Nýní můžeme v CLionu projekt zkompilovat a spustit.</p>
<p>Alternativně je možné přejít do kořene workspacu, zkompilovat balíčky a zavolat <code>rosrun &lt;jmeno_balicku&gt; &lt;jmeno_binarky&gt;</code>:</p>
<pre><code>catkin_make
source devel/setup.bash
rosrun my_first_ros_project cpp_ros_example 
</code></pre>
<p>Čímž jsme řekli:</p>
<ol>
<li><code>catkin_make</code> - zkompiluj celý ROS workspace,</li>
<li><code>source devel/setup.bash</code> - načti právě zkompilované balíčky a</li>
<li><code>rosrun my_first_ros_project cpp_ros_example</code> - zapni program <code>cpp_ros_example</code> z balíčku <code>my_first_ros_project</code>.</li>
</ol>
<p>Pokud se náš program úspěšně spustil, můžeme si vypsat zprávy z topiců přímo v terminále:</p>
<pre><code>rostopic echo &lt;nazev_topicu&gt;
</code></pre>
<details>
    <summary>Tip!</summary>
<p>Všechny právě aktivní topicy si můžeme vypsat příkazem <code>rostopic list</code>.</p>
</details>
<p>Podívat se na vzájemné propojení a komunikaci mezi všemi aktivními komponenty pomocí programu <code>rqt_graph</code>:</p>
<pre><code>rqt_graph
</code></pre>
<p>Či dokonce si vykreslit časový průběh dát z topiců v programu <code>rqt_plot</code>:</p>
<pre><code>rqt_plot
</code></pre>
<p>Ukázka odeslání float hodnoty skrze <code>ros::Publisher</code>:</p>
<pre><code class="language-cpp">
ros::Publisher float_publisher;
float_publisher = node-&gt;advertise&lt;std_msgs::Float32&gt;(&quot;some_topic&quot;, 0);
...
float_publisher.publish(float_value);
</code></pre>
<p>Tímto spůsobem je možné si například vizualizovat požadované a skutečné rychlosti kol (ověřit si strmost rampy), vykreslit si do grafu výstupy snímačů a přepočet na pozici vůči čáře, či si například vizualizovat odezvy jednotlivých složek PID regulátoru.</p>
<p><img src="cviceni/../images/qrt_plot.png" alt="diff_chassis_model" /></p>
<h1><a class="header" href="#integrace-ros-klientské-knihovny-do-bpc-prp-projektu-cca-30-min" id="integrace-ros-klientské-knihovny-do-bpc-prp-projektu-cca-30-min">Integrace ROS klientské knihovny do BPC-PRP projektu (cca 30 min)</a></h1>
<p>Nyní se pokuste transformovat Váš BPC-PRP projekt tak, aby byl ROS Nodem, podle výše uvedeného návodu a aby Váš projekt byl chopen publishovat ROS zprávy.</p>
<blockquote>
<p><strong>POZOR!</strong> - Zvažte, zda se vydáte cesout blokujicího <code>ros::spin()</code>, v tom případě si zablokujete Vaší main smyčku, nebo se vydáte cestou while smyčky s <code>ros::spinOnce()</code>. V tom případě ale publishery, subscribery a timery přijmou/odešlou zprávu, nebo zavolají timer callback pouze, když se provede řádek <code>ros::spinOnce()</code>.</p>
</blockquote>
<pre><code>while (ros::ok()) {     // main loop
    /* your code */
    ros::spinOnce();    // allows publishers, timers and subscribers to do their job
}
</code></pre>
<h1><a class="header" href="#vizualizace-v-rviz-cca-1h" id="vizualizace-v-rviz-cca-1h">Vizualizace v RViz (cca 1h)</a></h1>
<p>Nyní se podíváme, jak vytvářet vizualizace pro RViz.</p>
<p>Neprve si nastudujte oficiální dokumentaci k <a href="http://wiki.ros.org/rviz">vizualizaci v RViz</a>, případně tutoriál k tzv. <a href="http://wiki.ros.org/rviz/DisplayTypes/Marker">markerům</a>.</p>
<p>Jedná se o zprávy z ROS knihovny <code>visualization_msgs</code>. Tyto zprávy umoňují vizualizaci geometrických těles, šipek, úseček, polyúseček, mračna bodů, textu, nebo mesh gridů.</p>
<p>My si nyní napíšeme třídu, která bude vizualizovat krychli, jenž bude plavat 3D prostředím a nad ní budem vypisovat její aktuální polohu.</p>
<pre><code class="language-cpp">#pragma once
#include &lt;iostream&gt;
#include &lt;ros/ros.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;

#define format std::fixed &lt;&lt; std::setw(5) &lt;&lt; std::showpos &lt;&lt; std::setprecision(2)

class RvizExampleClass {

    class Pose {
    public:
        Pose(float x, float y, float z) : x_{x}, y_{y}, z_{z} {}
        float x() const {return x_;}
        float y() const {return y_;}
        float z() const {return z_;}
    private:
        const float x_, y_, z_;
    };

public:

    RvizExampleClass(ros::NodeHandle&amp; node, const std::string&amp; topic, float freq) : node_{node} {
        timer_ = node.createTimer(freq, &amp;RvizExampleClass::timer_callback, this);
        markers_publisher_ = node.advertise&lt;visualization_msgs::MarkerArray&gt;(topic, 0);
    }

private:

    void timer_callback(const ros::TimerEvent&amp; event) {
        auto time = ros::Time::now().toSec();
        auto pose = Pose(sin(time), cos(time), 0.5 * sin(time*3));

        visualization_msgs::MarkerArray msg;
        msg.markers.push_back(make_cube_marker(pose));
        msg.markers.push_back(make_text_marker(pose));
        markers_publisher_.publish(msg);
    }

    visualization_msgs::Marker make_cube_marker(const Pose&amp; pose) {
        visualization_msgs::Marker cube;

        // Coordination system
        cube.header.frame_id = &quot;origin&quot;;

        // Timestamp
        cube.header.stamp = ros::Time();

        // Marker Type
        cube.type = visualization_msgs::Marker::CUBE;
        cube.action = visualization_msgs::Marker::ADD;
        cube.id = 0;

        // Position
        cube.pose.position.x = pose.x();
        cube.pose.position.y = pose.y();
        cube.pose.position.z = pose.z();

        // Rotation (quaternion, see https://quaternions.online/)
        cube.pose.orientation.x = 0.0;
        cube.pose.orientation.y = 0.0;
        cube.pose.orientation.z = 0.0;
        cube.pose.orientation.w = 1.0;

        // Size
        cube.scale.x = cube.scale.y = cube.scale.z = 0.1;

        // Color
        cube.color.a = 1.0; // alpha - visibility
        cube.color.r = 0.0;
        cube.color.g = 1.0;
        cube.color.b = 0.0;

        return cube;
    }

    visualization_msgs::Marker make_text_marker(const Pose&amp; pose) {
        visualization_msgs::Marker text;

        // Coordination system
        text.header.frame_id = &quot;origin&quot;;

        // Timestamp
        text.header.stamp = ros::Time();

        // Marker Type
        text.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
        text.action = visualization_msgs::Marker::ADD;
        text.id = 1;

        // Position
        text.pose.position.x = pose.x();
        text.pose.position.y = pose.y();
        text.pose.position.z = pose.z() + 0.3;

        // Size
        text.scale.z = 0.1;

        // Text
        std::stringstream stream;
        stream &lt;&lt; &quot;* Cool Cube *&quot; &lt;&lt; std::endl
               &lt;&lt; &quot;  x: &quot; &lt;&lt; format &lt;&lt; pose.x() &lt;&lt; std::endl
               &lt;&lt; &quot;  y: &quot; &lt;&lt; format &lt;&lt; pose.y() &lt;&lt; std::endl
               &lt;&lt; &quot;  z: &quot; &lt;&lt; format &lt;&lt; pose.z();
        text.text = stream.str();

        // Color
        text.color.a = 1.0; // alpha - visibility
        text.color.r = 1.0;
        text.color.g = 1.0;
        text.color.b = 0.0;
        return text;
    }

    ros::NodeHandle&amp; node_;
    ros::Timer timer_;
    ros::Publisher markers_publisher_;
};
</code></pre>
<p>v souboru <code>main.cpp</code> pak</p>
<pre><code class="language-cpp">#include &lt;ros/ros.h&gt;
#include &quot;RvizExampleClass.h&quot;

int main(int argc, char* argv[]) {

    ros::init(argc, argv, &quot;cool_node_name&quot;);
    auto node = ros::NodeHandle();
    auto rviz_visualizer = RvizExampleClass(node, &quot;rviz_topic&quot;, 30.0);
    
    ros::spin();
    return 0;
}
</code></pre>
<p>Topic na kterém publikujete zprávu si zobrazte v RVizu.</p>
<p>✅  Inspirujte se touto třídou a vytvořte v rámci Vašeho BPC-PRP projektu modul, který bude vypisovat nad robotem jeho aktuální rychlost kol a hodnotu ze všech senzorů. </p>
<p>✅  Publikujte do Vámi nazvaného topicu skalár vzdálenosti robota od čáry. Tuto hodnotu vizualizujte v <code>rqt_plot</code>.</p>
<h1><a class="header" href="#optional-visualizace-plánované-trajektorie-cca-30min" id="optional-visualizace-plánované-trajektorie-cca-30min">Optional: visualizace plánované trajektorie (cca 30min)</a></h1>
<p>Ukážeme si další možný příklad užitečné vizualizace v RVizu. Na základě znalosti aktuální rychlosti kol si dokážeme vypočítat lineární a úhlovou rychlost robota.</p>
<p><img src="cviceni/../images/diff_chassis.png" alt="diff_chassis_model" /></p>
<p>Ze znalosti lineární a úhlové rychlosti pak dokážeme vypočítat trajektorii, kterou robot projede, pokud zachová konstantní rychlosti.</p>
<p><img src="cviceni/../images/arc_trajectory.png" alt="diff_chassis_model" /></p>
<p>Příklad ukazuje funkci, která na vstupu přijmá jako argumenty právě dopřednou a úhlovou rychlost v SI jednotkách (m/s a rad/s) a na základě této informace vykreslí v RVizu budoucí trajektorii.</p>
<pre><code class="language-cpp">void draw_predicted_trajectory(float lin_vel, float ang_vel) {
    
    // Create message instance
    auto msg = visualization_msgs::Marker{};
    
    // Define frame and timestamp 
    msg.header.frame_id = &quot;robot&quot;; // frame &quot;robot&quot; means, that (0,0) point is in the origin of your robot
    msg.header.stamp = ros::Time().now();
    msg.id = 0;

    // Define marker type
    msg.type = visualization_msgs::Marker::LINE_STRIP; // lines that interconnect set of points
    msg.action = visualization_msgs::Marker::ADD;

    // Define 
    msg.pose.orientation.w = 1.0; // avoid invalid quaternion
    msg.scale.x = 0.005; // line strip width in meters

    // Purple color
    msg.color.b = 1.0;
    msg.color.r = 1.0;
    msg.color.a = 1.0;

    // First point (robot origin)
    geometry_msgs::Point previous_p;
    previous_p.x = 0.0;
    previous_p.y = 0.0;
    previous_p.z = 0.0;
    
    float theta = 0.0f;
    float dt = 0.1;     // trajectory approximation step
    for (size_t i = 0; i &lt; 50; ++i){    // 0.1s * 50 = 5s of prediction
        geometry_msgs::Point p = previous_p;
        
        // Arc trajectory
        if (ang_vel != 0) {
            float radius = lin_vel / ang_vel;
            p.x += -radius * sin(theta) + radius * sin(theta + ang_vel*dt); // see the arc trajectory model
            p.y +=  radius * cos(theta) - radius * cos(theta + ang_vel*dt);
            theta += ang_vel*dt;
        } 
        // Directly forward
        else {
            p.x = previous_p.x + lin_vel * dt;
        }
        
        // Add trajectory point to message
        msg.points.push_back(p); 
        previous_p = p;
    }
    
    // Send trajectory to RViz
    trajectory_publisher_.publish(msg); 
}
</code></pre>
<p>Příklad možné výsledné implementace</p>
<p><img src="cviceni/../images/telemetry_trajectory.png" alt="diff_chassis_model" /></p>
<h1><a class="header" href="#principy" id="principy">Principy</a></h1>
<h1><a class="header" href="#supersmyčka-a-regulace-v-ní" id="supersmyčka-a-regulace-v-ní">Supersmyčka a regulace v ní</a></h1>
<pre><code class="language-c++">const int T = 30;
long long ms = millis() + T;
while(rum) {
    comm.send(sensor.BuildReads());
    comm.send(drive.BuildReads());
    
    while (ms &lt; millis())
      comm.loop();
      
    ms = millis() + T;
    
    sensor.ProcessLineSensors();
    drive.ComputeOdometry();
    
    controller.Control();                                                       
    
    drive.ComputeMotorRamps();        
    comm.send(sensor.BuildWrites());
    comm.send(drive.BuildWrites());
  }
</code></pre>
<h1><a class="header" href="#mediatorobserver-parser-processing" id="mediatorobserver-parser-processing">Mediator/Observer parser processing</a></h1>
<p>Někdy potřebujeme vytvořit implementaci</p>
<p>Deferred processing</p>
<pre><code class="language-c++">std::vector&lt;Msg&gt; ProcessIncoming(const Msg &amp;msg) {
  auto res = map.find(msg[0]);
  if (res == map.end())
    return {}
    
  return (res-&gt;second)(msg);
}
</code></pre>
<p>Data pro popis stavu robotu</p>
<pre><code class="language-c++">std::vector&lt;Msg&gt; MyRobotData::ODOReceived(const Msg &amp;msg)
{
  if (msg.size() != 3)
    return {};
    
  OdoL = std::stod(msg[1]);
  OdoR = std::stod(msg[2]);  
  return {};
}

std::vector&lt;Msg&gt; MyRobotData::BuildReads() 
{
  return {
    {&quot;ODO&quot;},
    {&quot;SENSOR&quot;,&quot;1&quot;},
    {&quot;SENSOR&quot;,&quot;2&quot;},
    };
}

std::vector&lt;Msg&gt; MyRobotData::BuildWrites() 
{
  return {
    {&quot;SPEED&quot;, std::to_string(LeftSpeed), std::string(RightSpeed)},
    {&quot;LED&quot;},
    };
}
</code></pre>
<h1><a class="header" href="#controller" id="controller">Controller</a></h1>
<p>Někdy je třeba řídit robot v různých okamžicích různým způsobem (např. robot nejprve musí zkalibrovat senzor čáry, aby 
mohl vyrazit na soutěžní trať ), přičemž potřebujeme, aby důležité části chodu supersmyčky probíhaly ve správném čase</p>
<p>Ideální je implementace stavového automatu. Jde ji řešit hloupým a nepřehledným způsobem <strong>switch-case</strong> nebo <strong>funkcionálně</strong></p>
<h2><a class="header" href="#funkcionální-přístup" id="funkcionální-přístup">Funkcionální přístup</a></h2>
<p>Nejprve musíme deklarovat <strong>ukazatel</strong> na prováděcí <strong>funkci stavu</strong>. </p>
<p>Pokud budou všechny stavy obsluhovány jedním objektem, je možné vytvořit ukazatel na metodu aktuálního objektu. </p>
<pre><code class="language-c++">using State = void(StateController::*)();                                       // ukazatel na stavovou funkci
State state;                                                                    // stav automatu
state = &amp;StateController::DoSearchLine;                                         // změna stavu
(this-&gt;*state)();                                                               // vyvolání stavové funkce
</code></pre>
<p>Pokud však bude obsluha ve více objektech, je nutné použít lambda funkcí a std::function</p>
<pre><code class="language-c++">using State = void();                                                           // ukazatel na stavovou funkci
std::function&lt;State&gt; state;                                                     // stav automatu
state = [=](){ regulator-&gt;DoSearchLine(); }                                     // změna stavu
(*state)();                                                                     // vyvolání stavové funkce
</code></pre>
<p>Doporučuji první způsob.</p>
<h3><a class="header" href="#Řešení-funkcionálním-přístupem-s-pomocí-metod-aktuálního-objektu" id="Řešení-funkcionálním-přístupem-s-pomocí-metod-aktuálního-objektu">Řešení funkcionálním přístupem s pomocí metod aktuálního objektu</a></h3>
<p>Deklarace Controlleru</p>
<pre><code class="language-c++">class StateController {
  using State = void(StateController::*)();                                     // MAGIE: ukazatel na metodu controlleru
public:
  State state{&amp;StateController::DoSearchLine}                                   // Robot po startu zacne hledat caru, prvni stav
  
  void Control();                                                               // funkce která bude volána z main
  
  // jednotlive stavove &quot;funkce&quot;
  void DoSearchLine();
  void DoFollowLine();
  void DoTryFollowMissingLine();
  void DoDanceOnFloor();
  void DoBurnEverything();
  // ...
}
</code></pre>
<p>Příklad implementací jednotlivých stavů automatu:</p>
<pre><code class="language-c++">void StateController::Control()
{
  (this-&gt;*state)();                                                             // MAGIE: provede volání aktuálně vybrané funkce
}

// Robot hleda caru
void StateController::DoSearchLine() 
{
  if (!sensor.LineMissing)
    state = &amp;StateController::DoFollowLine;
}  

// robot reguluje pozici na care
void StateController::DoFollowLine()
{
    drive.Regulate(ForwardSpeed, sensor.ComputedDistanceFromLine);
    
    if (sensor.LineMissing)
      state = &amp;StateController::DoTryFollowMissingLine;
}

// robot se pokousi znovu nalezt prerusenou caru
void StateController::DoTryFollowMissingLine()
{
    if (!sensor.LineMissing)
       state = &amp;StateController::DoTryFollowMissingLine;
}
</code></pre>
<p>A samozřejmě supersmyčka v main:</p>
<pre><code class="language-c++">StateController controller{&amp;drive, &amp;sensor};                                    // konstrukce controlleru nad daty

while(rum) {
    comm.send(sensor.BuildReads());
    comm.send(drive.BuildReads());
    
    while (ms &lt; millis())
      comm.loop();
      
    ms = millis() + T;
    
    sensor.ProcessLineSensors();
    drive.ComputeOdometry();
    
    controller.Control();                                                       // provede jeden krok aktualniho stavu
    
    drive.ComputeMotorRamps();        
    comm.send(sensor.BuildWrites());
    comm.send(drive.BuildWrites());
  }
</code></pre>
<h2><a class="header" href="#přístup-switch-case" id="přístup-switch-case">Přístup switch-case</a></h2>
<p>Deklarace Controlleru</p>
<pre><code class="language-c++">enum State {
    SearchLine,
    FollowLine,
    TryFollowMissingLine,
    DanceOnFloor,
    DoBurnEverything,
  };                                                                            // Deklarace stavu
  
class StateController {
public:
  State state{SearchLine};                                                      // Robot po startu zacne hledat caru, prvni stav
  
  void Control();                                                               // funkce která bude volána z main
}
</code></pre>
<p>Příklad implementací jednotlivých stavů automatu:</p>
<pre><code class="language-c++">void StateController::Control()
{
  switch (state) {
  default:
  case SearchLine:
    if (!sensor.LineMissing)
      state = FollowLine;
    break;  
    
  case FollowLine:
    drive.Regulate(ForwardSpeed, sensor.ComputedDistanceFromLine);
    
    if (sensor.LineMissing)
      state = TryFollowMissingLine;
    break;
      
  case TryFollowMissingLine:
    if (!sensor.LineMissing)
      state = FollowLine;
    break;
  }  
}
</code></pre>
<p><strong>Poznámka:</strong> V příkladech chybí deklarace lokálních proměnných objektu, příklady jsou uvedeny jen jako vzorové, pro pochopení funkce. Konkrétní implementaci si musíte vytvořit sami.</p>
<p>Chytrého nakopni, hloupého kopni, blbého zakopej 4 metry pod zem ...</p>
<h1><a class="header" href="#protokolový-stack" id="protokolový-stack">Protokolový stack</a></h1>
<pre><code class="language-c++">void loop() 
{
  auto [sender, received] = udp.receive();                                      // udp -&gt; buffer
  if (sender.empty())
    return;
  auto rpacket = from_buffer(received);                                         // buffer -&gt; transport
  std::vector&lt;Msg&gt; replies;    
  for (auto &amp;request : ParseAll(rpacket)) {                                     // transport -&gt; aplikace
    replies.append(ProcessIncoming(request));                                   // obsluha aplikacniho protokolu
  }
  if (!replies.empty()) {
    auto tpacket = BuildAll(replies);                                           // aplikace -&gt; transport
    auto transmit = to_buffer(tpacket);                                         // transport -&gt; mezivrstva
    udp.send(sender, transmit);                                                 // mezivrstva -&gt; udp 
  }
}

void send(std::vector&lt;Msg&gt; msgs) 
{
   auto tpacket = BuildAll(msgs);                                               // aplikace -&gt; transport
   auto transmit = to_buffer(tpacket);                                          // transport -&gt; buffer
   udp.send(sender, transmit);                                                  // buffer -&gt; udp
}
</code></pre>
<h1><a class="header" href="#doporučená-organizace-projektu" id="doporučená-organizace-projektu">Doporučená organizace projektu</a></h1>
<p>Rozdělení do tříd (abecedně):</p>
<ul>
<li><code>Comm</code> - Obsluha kompletní komunikace</li>
<li><code>Configuration</code> - Konfigurace načtená z yaml souboru</li>
<li><code>Controller</code> - Hlavní logika ovládání programu</li>
<li><code>Drive</code> - Obsluha a řízení podvozku</li>
<li><code>Nmea</code> - Implementace převodu NMEA zpráv</li>
<li><code>Sensor</code> - Obsluha měření a identifikace čáry</li>
<li><code>main.cpp</code> - Supersmyčka</li>
</ul>
<p>Doporučen způsob práce kdy za funkcionalitu jedné třídy zodpovídá jedna osoba 
(ideálně se jménem napsaným v komentáři na začátku souboru). Nikdo jiný 
než vybraná osoba nesmí daný soubor commitovat.</p>
<p>Main je kolizní, můžou do něj všichni, ideálně v malých jednořádkových commitech. 
Main pokud možno modifikovat jen když jste všichni spolu a definujete API 
(rozdáváte práci)</p>
<h2><a class="header" href="#maincpp" id="maincpp">main.cpp</a></h2>
<p>Řeší:</p>
<ul>
<li>obsluha argumentů příkazové řádky</li>
<li>instanciace ostatních tříd</li>
<li>hlavní supersmyčka</li>
</ul>
<p>Závisí na:</p>
<ul>
<li><code>Comm</code> - instanciace a obsluha v supersmy4ce</li>
<li><code>Drive</code> - instanciace a obsluha</li>
<li><code>Sensor</code> - instanciace a obsluha</li>
<li><code>Configuration</code> - instanciace, načtení</li>
<li><code>Controller</code> - instanciace a volání v supersmyčce</li>
</ul>
<p>POZOR KOLIZNÍ SOUBOR (commitovat vždy zvlášť, modifikovat pouze velmi malé změny kvůli častým konfliktům)</p>
<h2><a class="header" href="#nmea" id="nmea">Nmea</a></h2>
<p>Řeší:</p>
<ul>
<li>převod z frame na zprávu</li>
<li>převod ze zprávy na frame</li>
</ul>
<p>Závisí na:</p>
<ul>
<li>nic</li>
</ul>
<p>Realizace:</p>
<ul>
<li>Implementace 4. týden</li>
<li>Spolehlivost 6. týden</li>
</ul>
<h2><a class="header" href="#comm" id="comm">Comm</a></h2>
<p>Řeší:</p>
<ul>
<li>obsluha příjmu a odesílání UDP zpráv</li>
<li>Mediátor zpráv do ostatních objektů</li>
</ul>
<p>Závisí na</p>
<ul>
<li><code>Nmea</code> - převod protokolu</li>
<li><code>Configuration</code> VOLITELNE - port</li>
</ul>
<p>Realizace:</p>
<ul>
<li>Implementace 6. týden</li>
<li>Spolehlivost 8. týden</li>
</ul>
<h2><a class="header" href="#drive" id="drive">Drive</a></h2>
<p>Řeší:</p>
<ul>
<li>Obsluha komunikace s podvozkem</li>
<li>Výpočty nad podvozkem</li>
<li>Odometrie</li>
</ul>
<p>Závisí na</p>
<ul>
<li><code>Nmea</code> - deklarace zpráv</li>
<li><code>Configuration</code> VOLITELNE - poloměr kola, rozteč</li>
</ul>
<p>Realizace:</p>
<ul>
<li>Implementace 6. týden</li>
<li>Spolehlivost 8. týden</li>
</ul>
<h2><a class="header" href="#sensor-1" id="sensor-1">Sensor</a></h2>
<p>Řeší:</p>
<ul>
<li>Obsluha komunikace se senzory</li>
<li>Parametrizace /detekce pozice čáry</li>
</ul>
<p>Závisí na</p>
<ul>
<li><code>Nmea</code> - deklarace zpráv</li>
<li><code>Configuration</code> VOLITELNE - pozice senzoru</li>
</ul>
<p>Realizace:</p>
<ul>
<li>Implementace 7. týden</li>
<li>Spolehlivost 8. týden</li>
</ul>
<h2><a class="header" href="#configuration" id="configuration">Configuration</a></h2>
<ul>
<li>Načítání parametrů z yaml souboru</li>
<li>Volitelná třída, lze implementovat za pomocí konstant v kódu</li>
<li>výhodné použití <code>yaml-cpp</code> knihovny</li>
</ul>
<p>Závisí na</p>
<p>nic</p>
<p>Realizace:</p>
<ul>
<li>Implementace 8. týden</li>
<li>Spolehlivost 10. týden</li>
</ul>
<h2><a class="header" href="#controller-1" id="controller-1">Controller</a></h2>
<p>Řeší:</p>
<ul>
<li>Logika jízdy robotu</li>
<li>Stavový automat pro:
<ul>
<li>inicializace / kalibrace senzorů</li>
<li>jízda po čáře (regulátor)</li>
<li>jízda po přerušené čáře</li>
<li>jízda po křižovatce</li>
</ul>
</li>
</ul>
<p>Závisí na</p>
<ul>
<li><code>Drive</code> - zápis rychlostí robotu</li>
<li><code>Sensor</code> - čtení čáry</li>
<li><code>Configuration</code> VOLITELNE - délka přerušení</li>
</ul>
<p>Realizace:</p>
<ul>
<li>Implementace 8. týden</li>
<li>Spolehlivost 10. týden</li>
</ul>
<h1><a class="header" href="#oddělení-modulů---zrychlení-kompilace" id="oddělení-modulů---zrychlení-kompilace">Oddělení modulů - Zrychlení kompilace</a></h1>
<p>Při návrhu objektového API se setkáváme s nutností oddělení jednotlivých modulů tak, aby <strong>navzájem spolupracovaly</strong> 
(jeden modul využívá druhý), ale současně <strong>změna v impleentaci</strong> jednoho modulu nevyvolala <strong>nutnost rekompilace</strong> 
modulu druhého. Typickým příkladem je vazba <strong>nadřazený-podřazený</strong>, ale lze takto vytvořit i <strong>cyklickou závislost</strong></p>
<p>Velmi špatným řešením v aplikacích bývá vytvoření <strong>globální proměnné</strong>.</p>
<p>Řešení lze docílit měkkou vazbou přes <strong>ukazatel na nedefinovaný objekt</strong> (tzv forward).</p>
<p><strong>Příklad:</strong> Máme objekt <code>Controller</code>, který ve svých metodách potřebuje používat funkce z objektů <code>Drive</code> a <code>Sensor</code>.
Objekty <code>Drive</code> a <code>Sensor</code> jsou singletony (existují v aplikaci v právě jedné instanci, vytvořené nejspíše jako
lokální proměnné ve funkci <code>main</code>.</p>
<h2><a class="header" href="#forward" id="forward">Forward</a></h2>
<p>Aby mohly jednotlivé metody <code>Controller</code>u pracovat s <code>Drive</code>, musí mít <code>Controller</code> v sobě uložený odkaz na instanci
objektu <code>Drive</code>. Nejspíše takto:</p>
<pre><code class="language-c++">#include &quot;Drive.h&quot;

class Controller {
public:
  Drive *drv;
}
</code></pre>
<p>Pokud však s třídou <code>Drive</code> pracuje pouze implementace <code>Controlleru</code>, kompilátor potřebuje pouze vědět, že
<code>Drive</code> je třída (a nic víc!) a není tak potřeba vkládat celý soubor s definicí <code>API</code> třídy <code>Drive</code>. Lze toto
zjednodušit na:</p>
<pre><code class="language-c++">class Drive;    // pouze forward

class Controller {
public:
  Drive *drv;
}
</code></pre>
<p>a soubor s deklarací Drive vkládáme až do cpp souboru</p>
<pre><code class="language-c++">#include &quot;Controller.h&quot;
#include &quot;Drive.h&quot;

Controller:: ......
</code></pre>
<p>Toto lze použít při splnění podmínek:</p>
<ul>
<li>Všechny přístupy ke třídě <code>Drive</code> jsou přes ukazatel, nikoliv přímo 
<ul>
<li>instance objektu potřebuje znát velikost tedy plnou deklaraci !</li>
</ul>
</li>
<li>k obsahu <code>drv</code> se nepřistupuje v headeru ale v kódu cpp.
<ul>
<li>Jakékoliv inline funkce používající obsah drv potřebují znát plnou deklaraci !</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#neměnný-ukazatel" id="neměnný-ukazatel">Neměnný ukazatel</a></h2>
<p>Dále <code>drive</code> by měl být konstantní ukazatel na nekonstantní instanci třídy <code>Drive</code>. Ukazatel nechceme nikdy měnit, ale
vlastní objekt měnit můžeme. S tím kam umístíme <code>const</code> bývá začátečnický problém, pro shrnutí: </p>
<pre><code class="language-c++">Drive *drv;               // ukazatel na Drive. Lze změnit ukazatel i Data na které ukazuje.
const Drive *drv;         // ukazatel na konstantní Drive. Lze změnit ukazatel, Data na které ukazuje lze pouze číst.
Drive * const drv;        // konstantní ukazatel na Drive. Lze změnit data, na které ukazuje. Ukazatel lze pouze číst.
const Drive * const drv;  // konstantní ukazatel na konstantní Drive. Data i ukazatel lze pouze číst.
</code></pre>
<p>Dále nechceme, aby do ukazatele v inicializaci instance <code>Controller</code>u někdo vložil <code>nullptr</code> (nedává to v API smysl, 
bez instance <code>Drive</code> neumí <code>Controller</code> žít). Navíc nechceme použít <strong>pointerovou aritmetiku</strong> (z principu se jí 
vyhýbáme, kde to jde). Místo konstantního ukazatele <code>Drive * const ptr</code> použijeme referenci <code>Drive &amp; ptr</code>. 
Pozor reference je vždy konstantní, takže nám jedno <code>const</code> odpadá ! </p>
<pre><code class="language-c++">Drive &amp; drv;              // reference na Drive. Lze změnit Data na které ukazuje. Ukazatel ne.
</code></pre>
<h2><a class="header" href="#vzorové-řešení" id="vzorové-řešení">Vzorové řešení</a></h2>
<p>Objekt <code>Controller</code> tedy deklarujeme v headeru takto: </p>
<pre><code class="language-c++">class Drive;    // pouze forward

class Controller {
public:
  Controller(Drive &amp; aDrive); 
  
  void Method();
  
private:
  Drive &amp; drv;
}
</code></pre>
<p>A implementujeme v cpp souboru takto:</p>
<pre><code class="language-c++">#include &quot;Controller.h&quot;
#include &quot;Drive.h&quot;          // metody controlleru už smí používat API Drive

Controller::Controller(Drive &amp; aDrive)
 : drv{aDrive}
{
} 

void Controller::Method()
{
  drv-&gt;CallMe();            // Můžeme používat API
}
</code></pre>
<h2><a class="header" href="#cyklická-závislost" id="cyklická-závislost">Cyklická závislost</a></h2>
<p>Stejným způsobem lze definovat, že <code>Drive</code> může přistupovat k prvkům <code>Controlleru</code>. Standardním způsobem deklarace 
bysme vytvořili cyklickou závislost mezi headery a kód by (logicky) nešel zkompilovat:</p>
<p>Drive.h:</p>
<pre><code class="language-c++">#include &quot;Controller.h&quot;

class Drive {
 Controller &amp; ctrl;
}
</code></pre>
<p>Controller.h:</p>
<pre><code class="language-c++">#include &quot;Drive.h&quot;

class Controller {
 Drive &amp; drv;
}
</code></pre>
<p><strong>Řešení</strong> cyklické závislosti bylo již uvedeno:</p>
<pre><code class="language-c++">class Controller;

class Drive {
 Controller &amp; ctrl;
}
</code></pre>
<p>Controller.h:</p>
<pre><code class="language-c++">class Drive;

class Controller {
 Drive &amp; drv;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
